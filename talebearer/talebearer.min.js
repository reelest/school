(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/mithril/render/vnode.js
  var require_vnode = __commonJS({
    "node_modules/mithril/render/vnode.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      function Vnode(tag, key, attrs, children, text, dom) {
        return { tag, key, attrs, children, text, dom, domSize: void 0, state: void 0, events: void 0, instance: void 0 };
      }
      Vnode.normalize = function(node) {
        if (Array.isArray(node))
          return Vnode("[", void 0, void 0, Vnode.normalizeChildren(node), void 0, void 0);
        if (node == null || typeof node === "boolean")
          return null;
        if (typeof node === "object")
          return node;
        return Vnode("#", void 0, void 0, String(node), void 0, void 0);
      };
      Vnode.normalizeChildren = function(input) {
        var children = [];
        if (input.length) {
          var isKeyed = input[0] != null && input[0].key != null;
          for (var i = 1; i < input.length; i++) {
            if ((input[i] != null && input[i].key != null) !== isKeyed) {
              throw new TypeError(
                isKeyed && (input[i] != null || typeof input[i] === "boolean") ? "In fragments, vnodes must either all have keys or none have keys. You may wish to consider using an explicit keyed empty fragment, m.fragment({key: ...}), instead of a hole." : "In fragments, vnodes must either all have keys or none have keys."
              );
            }
          }
          for (var i = 0; i < input.length; i++) {
            children[i] = Vnode.normalize(input[i]);
          }
        }
        return children;
      };
      module.exports = Vnode;
    }
  });

  // node_modules/mithril/render/hyperscriptVnode.js
  var require_hyperscriptVnode = __commonJS({
    "node_modules/mithril/render/hyperscriptVnode.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      var Vnode = require_vnode();
      module.exports = function() {
        var attrs = arguments[this], start = this + 1, children;
        if (attrs == null) {
          attrs = {};
        } else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {
          attrs = {};
          start = this;
        }
        if (arguments.length === start + 1) {
          children = arguments[start];
          if (!Array.isArray(children))
            children = [children];
        } else {
          children = [];
          while (start < arguments.length)
            children.push(arguments[start++]);
        }
        return Vnode("", attrs.key, attrs, children);
      };
    }
  });

  // node_modules/mithril/util/hasOwn.js
  var require_hasOwn = __commonJS({
    "node_modules/mithril/util/hasOwn.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      module.exports = {}.hasOwnProperty;
    }
  });

  // node_modules/mithril/render/hyperscript.js
  var require_hyperscript = __commonJS({
    "node_modules/mithril/render/hyperscript.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      var Vnode = require_vnode();
      var hyperscriptVnode = require_hyperscriptVnode();
      var hasOwn = require_hasOwn();
      var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g;
      var selectorCache = {};
      function isEmpty(object) {
        for (var key in object)
          if (hasOwn.call(object, key))
            return false;
        return true;
      }
      function compileSelector(selector) {
        var match, tag = "div", classes = [], attrs = {};
        while (match = selectorParser.exec(selector)) {
          var type = match[1], value = match[2];
          if (type === "" && value !== "")
            tag = value;
          else if (type === "#")
            attrs.id = value;
          else if (type === ".")
            classes.push(value);
          else if (match[3][0] === "[") {
            var attrValue = match[6];
            if (attrValue)
              attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\");
            if (match[4] === "class")
              classes.push(attrValue);
            else
              attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true;
          }
        }
        if (classes.length > 0)
          attrs.className = classes.join(" ");
        return selectorCache[selector] = { tag, attrs };
      }
      function execSelector(state, vnode) {
        var attrs = vnode.attrs;
        var hasClass = hasOwn.call(attrs, "class");
        var className = hasClass ? attrs.class : attrs.className;
        vnode.tag = state.tag;
        vnode.attrs = {};
        if (!isEmpty(state.attrs) && !isEmpty(attrs)) {
          var newAttrs = {};
          for (var key in attrs) {
            if (hasOwn.call(attrs, key))
              newAttrs[key] = attrs[key];
          }
          attrs = newAttrs;
        }
        for (var key in state.attrs) {
          if (hasOwn.call(state.attrs, key) && key !== "className" && !hasOwn.call(attrs, key)) {
            attrs[key] = state.attrs[key];
          }
        }
        if (className != null || state.attrs.className != null)
          attrs.className = className != null ? state.attrs.className != null ? String(state.attrs.className) + " " + String(className) : className : state.attrs.className != null ? state.attrs.className : null;
        if (hasClass)
          attrs.class = null;
        for (var key in attrs) {
          if (hasOwn.call(attrs, key) && key !== "key") {
            vnode.attrs = attrs;
            break;
          }
        }
        return vnode;
      }
      function hyperscript(selector) {
        if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
          throw Error("The selector must be either a string or a component.");
        }
        var vnode = hyperscriptVnode.apply(1, arguments);
        if (typeof selector === "string") {
          vnode.children = Vnode.normalizeChildren(vnode.children);
          if (selector !== "[")
            return execSelector(selectorCache[selector] || compileSelector(selector), vnode);
        }
        vnode.tag = selector;
        return vnode;
      }
      module.exports = hyperscript;
    }
  });

  // node_modules/mithril/render/trust.js
  var require_trust = __commonJS({
    "node_modules/mithril/render/trust.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      var Vnode = require_vnode();
      module.exports = function(html) {
        if (html == null)
          html = "";
        return Vnode("<", void 0, void 0, html, void 0, void 0);
      };
    }
  });

  // node_modules/mithril/render/fragment.js
  var require_fragment = __commonJS({
    "node_modules/mithril/render/fragment.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      var Vnode = require_vnode();
      var hyperscriptVnode = require_hyperscriptVnode();
      module.exports = function() {
        var vnode = hyperscriptVnode.apply(0, arguments);
        vnode.tag = "[";
        vnode.children = Vnode.normalizeChildren(vnode.children);
        return vnode;
      };
    }
  });

  // node_modules/mithril/hyperscript.js
  var require_hyperscript2 = __commonJS({
    "node_modules/mithril/hyperscript.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      var hyperscript = require_hyperscript();
      hyperscript.trust = require_trust();
      hyperscript.fragment = require_fragment();
      module.exports = hyperscript;
    }
  });

  // node_modules/mithril/promise/polyfill.js
  var require_polyfill = __commonJS({
    "node_modules/mithril/promise/polyfill.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      var PromisePolyfill = function(executor) {
        if (!(this instanceof PromisePolyfill))
          throw new Error("Promise must be called with 'new'.");
        if (typeof executor !== "function")
          throw new TypeError("executor must be a function.");
        var self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false);
        var instance = self._instance = { resolvers, rejectors };
        var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout;
        function handler(list, shouldAbsorb) {
          return function execute(value) {
            var then;
            try {
              if (shouldAbsorb && value != null && (typeof value === "object" || typeof value === "function") && typeof (then = value.then) === "function") {
                if (value === self)
                  throw new TypeError("Promise can't be resolved with itself.");
                executeOnce(then.bind(value));
              } else {
                callAsync(function() {
                  if (!shouldAbsorb && list.length === 0)
                    console.error("Possible unhandled promise rejection:", value);
                  for (var i = 0; i < list.length; i++)
                    list[i](value);
                  resolvers.length = 0, rejectors.length = 0;
                  instance.state = shouldAbsorb;
                  instance.retry = function() {
                    execute(value);
                  };
                });
              }
            } catch (e) {
              rejectCurrent(e);
            }
          };
        }
        function executeOnce(then) {
          var runs = 0;
          function run(fn) {
            return function(value) {
              if (runs++ > 0)
                return;
              fn(value);
            };
          }
          var onerror = run(rejectCurrent);
          try {
            then(run(resolveCurrent), onerror);
          } catch (e) {
            onerror(e);
          }
        }
        executeOnce(executor);
      };
      PromisePolyfill.prototype.then = function(onFulfilled, onRejection) {
        var self = this, instance = self._instance;
        function handle(callback, list, next, state) {
          list.push(function(value) {
            if (typeof callback !== "function")
              next(value);
            else
              try {
                resolveNext(callback(value));
              } catch (e) {
                if (rejectNext)
                  rejectNext(e);
              }
          });
          if (typeof instance.retry === "function" && state === instance.state)
            instance.retry();
        }
        var resolveNext, rejectNext;
        var promise = new PromisePolyfill(function(resolve, reject) {
          resolveNext = resolve, rejectNext = reject;
        });
        handle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false);
        return promise;
      };
      PromisePolyfill.prototype.catch = function(onRejection) {
        return this.then(null, onRejection);
      };
      PromisePolyfill.prototype.finally = function(callback) {
        return this.then(
          function(value) {
            return PromisePolyfill.resolve(callback()).then(function() {
              return value;
            });
          },
          function(reason) {
            return PromisePolyfill.resolve(callback()).then(function() {
              return PromisePolyfill.reject(reason);
            });
          }
        );
      };
      PromisePolyfill.resolve = function(value) {
        if (value instanceof PromisePolyfill)
          return value;
        return new PromisePolyfill(function(resolve) {
          resolve(value);
        });
      };
      PromisePolyfill.reject = function(value) {
        return new PromisePolyfill(function(resolve, reject) {
          reject(value);
        });
      };
      PromisePolyfill.all = function(list) {
        return new PromisePolyfill(function(resolve, reject) {
          var total = list.length, count = 0, values = [];
          if (list.length === 0)
            resolve([]);
          else
            for (var i = 0; i < list.length; i++) {
              (function(i2) {
                function consume(value) {
                  count++;
                  values[i2] = value;
                  if (count === total)
                    resolve(values);
                }
                if (list[i2] != null && (typeof list[i2] === "object" || typeof list[i2] === "function") && typeof list[i2].then === "function") {
                  list[i2].then(consume, reject);
                } else
                  consume(list[i2]);
              })(i);
            }
        });
      };
      PromisePolyfill.race = function(list) {
        return new PromisePolyfill(function(resolve, reject) {
          for (var i = 0; i < list.length; i++) {
            list[i].then(resolve, reject);
          }
        });
      };
      module.exports = PromisePolyfill;
    }
  });

  // node_modules/mithril/promise/promise.js
  var require_promise = __commonJS({
    "node_modules/mithril/promise/promise.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      var PromisePolyfill = require_polyfill();
      if (typeof window !== "undefined") {
        if (typeof window.Promise === "undefined") {
          window.Promise = PromisePolyfill;
        } else if (!window.Promise.prototype.finally) {
          window.Promise.prototype.finally = PromisePolyfill.prototype.finally;
        }
        module.exports = window.Promise;
      } else if (typeof global !== "undefined") {
        if (typeof global.Promise === "undefined") {
          global.Promise = PromisePolyfill;
        } else if (!global.Promise.prototype.finally) {
          global.Promise.prototype.finally = PromisePolyfill.prototype.finally;
        }
        module.exports = global.Promise;
      } else {
        module.exports = PromisePolyfill;
      }
    }
  });

  // node_modules/mithril/render/render.js
  var require_render = __commonJS({
    "node_modules/mithril/render/render.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      var Vnode = require_vnode();
      module.exports = function($window) {
        var $doc = $window && $window.document;
        var currentRedraw;
        var nameSpace = {
          svg: "http://www.w3.org/2000/svg",
          math: "http://www.w3.org/1998/Math/MathML"
        };
        function getNameSpace(vnode) {
          return vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag];
        }
        function checkState(vnode, original) {
          if (vnode.state !== original)
            throw new Error("'vnode.state' must not be modified.");
        }
        function callHook(vnode) {
          var original = vnode.state;
          try {
            return this.apply(original, arguments);
          } finally {
            checkState(vnode, original);
          }
        }
        function activeElement() {
          try {
            return $doc.activeElement;
          } catch (e) {
            return null;
          }
        }
        function createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {
          for (var i = start; i < end; i++) {
            var vnode = vnodes[i];
            if (vnode != null) {
              createNode(parent, vnode, hooks, ns, nextSibling);
            }
          }
        }
        function createNode(parent, vnode, hooks, ns, nextSibling) {
          var tag = vnode.tag;
          if (typeof tag === "string") {
            vnode.state = {};
            if (vnode.attrs != null)
              initLifecycle(vnode.attrs, vnode, hooks);
            switch (tag) {
              case "#":
                createText(parent, vnode, nextSibling);
                break;
              case "<":
                createHTML(parent, vnode, ns, nextSibling);
                break;
              case "[":
                createFragment(parent, vnode, hooks, ns, nextSibling);
                break;
              default:
                createElement(parent, vnode, hooks, ns, nextSibling);
            }
          } else
            createComponent(parent, vnode, hooks, ns, nextSibling);
        }
        function createText(parent, vnode, nextSibling) {
          vnode.dom = $doc.createTextNode(vnode.children);
          insertNode(parent, vnode.dom, nextSibling);
        }
        var possibleParents = { caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup" };
        function createHTML(parent, vnode, ns, nextSibling) {
          var match = vnode.children.match(/^\s*?<(\w+)/im) || [];
          var temp = $doc.createElement(possibleParents[match[1]] || "div");
          if (ns === "http://www.w3.org/2000/svg") {
            temp.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg">' + vnode.children + "</svg>";
            temp = temp.firstChild;
          } else {
            temp.innerHTML = vnode.children;
          }
          vnode.dom = temp.firstChild;
          vnode.domSize = temp.childNodes.length;
          vnode.instance = [];
          var fragment = $doc.createDocumentFragment();
          var child;
          while (child = temp.firstChild) {
            vnode.instance.push(child);
            fragment.appendChild(child);
          }
          insertNode(parent, fragment, nextSibling);
        }
        function createFragment(parent, vnode, hooks, ns, nextSibling) {
          var fragment = $doc.createDocumentFragment();
          if (vnode.children != null) {
            var children = vnode.children;
            createNodes(fragment, children, 0, children.length, hooks, null, ns);
          }
          vnode.dom = fragment.firstChild;
          vnode.domSize = fragment.childNodes.length;
          insertNode(parent, fragment, nextSibling);
        }
        function createElement(parent, vnode, hooks, ns, nextSibling) {
          var tag = vnode.tag;
          var attrs = vnode.attrs;
          var is = attrs && attrs.is;
          ns = getNameSpace(vnode) || ns;
          var element = ns ? is ? $doc.createElementNS(ns, tag, { is }) : $doc.createElementNS(ns, tag) : is ? $doc.createElement(tag, { is }) : $doc.createElement(tag);
          vnode.dom = element;
          if (attrs != null) {
            setAttrs(vnode, attrs, ns);
          }
          insertNode(parent, element, nextSibling);
          if (!maybeSetContentEditable(vnode)) {
            if (vnode.children != null) {
              var children = vnode.children;
              createNodes(element, children, 0, children.length, hooks, null, ns);
              if (vnode.tag === "select" && attrs != null)
                setLateSelectAttrs(vnode, attrs);
            }
          }
        }
        function initComponent(vnode, hooks) {
          var sentinel;
          if (typeof vnode.tag.view === "function") {
            vnode.state = Object.create(vnode.tag);
            sentinel = vnode.state.view;
            if (sentinel.$$reentrantLock$$ != null)
              return;
            sentinel.$$reentrantLock$$ = true;
          } else {
            vnode.state = void 0;
            sentinel = vnode.tag;
            if (sentinel.$$reentrantLock$$ != null)
              return;
            sentinel.$$reentrantLock$$ = true;
            vnode.state = vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function" ? new vnode.tag(vnode) : vnode.tag(vnode);
          }
          initLifecycle(vnode.state, vnode, hooks);
          if (vnode.attrs != null)
            initLifecycle(vnode.attrs, vnode, hooks);
          vnode.instance = Vnode.normalize(callHook.call(vnode.state.view, vnode));
          if (vnode.instance === vnode)
            throw Error("A view cannot return the vnode it received as argument");
          sentinel.$$reentrantLock$$ = null;
        }
        function createComponent(parent, vnode, hooks, ns, nextSibling) {
          initComponent(vnode, hooks);
          if (vnode.instance != null) {
            createNode(parent, vnode.instance, hooks, ns, nextSibling);
            vnode.dom = vnode.instance.dom;
            vnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0;
          } else {
            vnode.domSize = 0;
          }
        }
        function updateNodes(parent, old, vnodes, hooks, nextSibling, ns) {
          if (old === vnodes || old == null && vnodes == null)
            return;
          else if (old == null || old.length === 0)
            createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns);
          else if (vnodes == null || vnodes.length === 0)
            removeNodes(parent, old, 0, old.length);
          else {
            var isOldKeyed = old[0] != null && old[0].key != null;
            var isKeyed = vnodes[0] != null && vnodes[0].key != null;
            var start = 0, oldStart = 0;
            if (!isOldKeyed)
              while (oldStart < old.length && old[oldStart] == null)
                oldStart++;
            if (!isKeyed)
              while (start < vnodes.length && vnodes[start] == null)
                start++;
            if (isOldKeyed !== isKeyed) {
              removeNodes(parent, old, oldStart, old.length);
              createNodes(parent, vnodes, start, vnodes.length, hooks, nextSibling, ns);
            } else if (!isKeyed) {
              var commonLength = old.length < vnodes.length ? old.length : vnodes.length;
              start = start < oldStart ? start : oldStart;
              for (; start < commonLength; start++) {
                o = old[start];
                v = vnodes[start];
                if (o === v || o == null && v == null)
                  continue;
                else if (o == null)
                  createNode(parent, v, hooks, ns, getNextSibling(old, start + 1, nextSibling));
                else if (v == null)
                  removeNode(parent, o);
                else
                  updateNode(parent, o, v, hooks, getNextSibling(old, start + 1, nextSibling), ns);
              }
              if (old.length > commonLength)
                removeNodes(parent, old, start, old.length);
              if (vnodes.length > commonLength)
                createNodes(parent, vnodes, start, vnodes.length, hooks, nextSibling, ns);
            } else {
              var oldEnd = old.length - 1, end = vnodes.length - 1, map, o, v, oe, ve, topSibling;
              while (oldEnd >= oldStart && end >= start) {
                oe = old[oldEnd];
                ve = vnodes[end];
                if (oe.key !== ve.key)
                  break;
                if (oe !== ve)
                  updateNode(parent, oe, ve, hooks, nextSibling, ns);
                if (ve.dom != null)
                  nextSibling = ve.dom;
                oldEnd--, end--;
              }
              while (oldEnd >= oldStart && end >= start) {
                o = old[oldStart];
                v = vnodes[start];
                if (o.key !== v.key)
                  break;
                oldStart++, start++;
                if (o !== v)
                  updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), ns);
              }
              while (oldEnd >= oldStart && end >= start) {
                if (start === end)
                  break;
                if (o.key !== ve.key || oe.key !== v.key)
                  break;
                topSibling = getNextSibling(old, oldStart, nextSibling);
                moveNodes(parent, oe, topSibling);
                if (oe !== v)
                  updateNode(parent, oe, v, hooks, topSibling, ns);
                if (++start <= --end)
                  moveNodes(parent, o, nextSibling);
                if (o !== ve)
                  updateNode(parent, o, ve, hooks, nextSibling, ns);
                if (ve.dom != null)
                  nextSibling = ve.dom;
                oldStart++;
                oldEnd--;
                oe = old[oldEnd];
                ve = vnodes[end];
                o = old[oldStart];
                v = vnodes[start];
              }
              while (oldEnd >= oldStart && end >= start) {
                if (oe.key !== ve.key)
                  break;
                if (oe !== ve)
                  updateNode(parent, oe, ve, hooks, nextSibling, ns);
                if (ve.dom != null)
                  nextSibling = ve.dom;
                oldEnd--, end--;
                oe = old[oldEnd];
                ve = vnodes[end];
              }
              if (start > end)
                removeNodes(parent, old, oldStart, oldEnd + 1);
              else if (oldStart > oldEnd)
                createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns);
              else {
                var originalNextSibling = nextSibling, vnodesLength = end - start + 1, oldIndices = new Array(vnodesLength), li = 0, i = 0, pos = 2147483647, matched = 0, map, lisIndices;
                for (i = 0; i < vnodesLength; i++)
                  oldIndices[i] = -1;
                for (i = end; i >= start; i--) {
                  if (map == null)
                    map = getKeyMap(old, oldStart, oldEnd + 1);
                  ve = vnodes[i];
                  var oldIndex = map[ve.key];
                  if (oldIndex != null) {
                    pos = oldIndex < pos ? oldIndex : -1;
                    oldIndices[i - start] = oldIndex;
                    oe = old[oldIndex];
                    old[oldIndex] = null;
                    if (oe !== ve)
                      updateNode(parent, oe, ve, hooks, nextSibling, ns);
                    if (ve.dom != null)
                      nextSibling = ve.dom;
                    matched++;
                  }
                }
                nextSibling = originalNextSibling;
                if (matched !== oldEnd - oldStart + 1)
                  removeNodes(parent, old, oldStart, oldEnd + 1);
                if (matched === 0)
                  createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns);
                else {
                  if (pos === -1) {
                    lisIndices = makeLisIndices(oldIndices);
                    li = lisIndices.length - 1;
                    for (i = end; i >= start; i--) {
                      v = vnodes[i];
                      if (oldIndices[i - start] === -1)
                        createNode(parent, v, hooks, ns, nextSibling);
                      else {
                        if (lisIndices[li] === i - start)
                          li--;
                        else
                          moveNodes(parent, v, nextSibling);
                      }
                      if (v.dom != null)
                        nextSibling = vnodes[i].dom;
                    }
                  } else {
                    for (i = end; i >= start; i--) {
                      v = vnodes[i];
                      if (oldIndices[i - start] === -1)
                        createNode(parent, v, hooks, ns, nextSibling);
                      if (v.dom != null)
                        nextSibling = vnodes[i].dom;
                    }
                  }
                }
              }
            }
          }
        }
        function updateNode(parent, old, vnode, hooks, nextSibling, ns) {
          var oldTag = old.tag, tag = vnode.tag;
          if (oldTag === tag) {
            vnode.state = old.state;
            vnode.events = old.events;
            if (shouldNotUpdate(vnode, old))
              return;
            if (typeof oldTag === "string") {
              if (vnode.attrs != null) {
                updateLifecycle(vnode.attrs, vnode, hooks);
              }
              switch (oldTag) {
                case "#":
                  updateText(old, vnode);
                  break;
                case "<":
                  updateHTML(parent, old, vnode, ns, nextSibling);
                  break;
                case "[":
                  updateFragment(parent, old, vnode, hooks, nextSibling, ns);
                  break;
                default:
                  updateElement(old, vnode, hooks, ns);
              }
            } else
              updateComponent(parent, old, vnode, hooks, nextSibling, ns);
          } else {
            removeNode(parent, old);
            createNode(parent, vnode, hooks, ns, nextSibling);
          }
        }
        function updateText(old, vnode) {
          if (old.children.toString() !== vnode.children.toString()) {
            old.dom.nodeValue = vnode.children;
          }
          vnode.dom = old.dom;
        }
        function updateHTML(parent, old, vnode, ns, nextSibling) {
          if (old.children !== vnode.children) {
            removeHTML(parent, old);
            createHTML(parent, vnode, ns, nextSibling);
          } else {
            vnode.dom = old.dom;
            vnode.domSize = old.domSize;
            vnode.instance = old.instance;
          }
        }
        function updateFragment(parent, old, vnode, hooks, nextSibling, ns) {
          updateNodes(parent, old.children, vnode.children, hooks, nextSibling, ns);
          var domSize = 0, children = vnode.children;
          vnode.dom = null;
          if (children != null) {
            for (var i = 0; i < children.length; i++) {
              var child = children[i];
              if (child != null && child.dom != null) {
                if (vnode.dom == null)
                  vnode.dom = child.dom;
                domSize += child.domSize || 1;
              }
            }
            if (domSize !== 1)
              vnode.domSize = domSize;
          }
        }
        function updateElement(old, vnode, hooks, ns) {
          var element = vnode.dom = old.dom;
          ns = getNameSpace(vnode) || ns;
          if (vnode.tag === "textarea") {
            if (vnode.attrs == null)
              vnode.attrs = {};
          }
          updateAttrs(vnode, old.attrs, vnode.attrs, ns);
          if (!maybeSetContentEditable(vnode)) {
            updateNodes(element, old.children, vnode.children, hooks, null, ns);
          }
        }
        function updateComponent(parent, old, vnode, hooks, nextSibling, ns) {
          vnode.instance = Vnode.normalize(callHook.call(vnode.state.view, vnode));
          if (vnode.instance === vnode)
            throw Error("A view cannot return the vnode it received as argument");
          updateLifecycle(vnode.state, vnode, hooks);
          if (vnode.attrs != null)
            updateLifecycle(vnode.attrs, vnode, hooks);
          if (vnode.instance != null) {
            if (old.instance == null)
              createNode(parent, vnode.instance, hooks, ns, nextSibling);
            else
              updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, ns);
            vnode.dom = vnode.instance.dom;
            vnode.domSize = vnode.instance.domSize;
          } else if (old.instance != null) {
            removeNode(parent, old.instance);
            vnode.dom = void 0;
            vnode.domSize = 0;
          } else {
            vnode.dom = old.dom;
            vnode.domSize = old.domSize;
          }
        }
        function getKeyMap(vnodes, start, end) {
          var map = /* @__PURE__ */ Object.create(null);
          for (; start < end; start++) {
            var vnode = vnodes[start];
            if (vnode != null) {
              var key = vnode.key;
              if (key != null)
                map[key] = start;
            }
          }
          return map;
        }
        var lisTemp = [];
        function makeLisIndices(a) {
          var result = [0];
          var u = 0, v = 0, i = 0;
          var il = lisTemp.length = a.length;
          for (var i = 0; i < il; i++)
            lisTemp[i] = a[i];
          for (var i = 0; i < il; ++i) {
            if (a[i] === -1)
              continue;
            var j = result[result.length - 1];
            if (a[j] < a[i]) {
              lisTemp[i] = j;
              result.push(i);
              continue;
            }
            u = 0;
            v = result.length - 1;
            while (u < v) {
              var c = (u >>> 1) + (v >>> 1) + (u & v & 1);
              if (a[result[c]] < a[i]) {
                u = c + 1;
              } else {
                v = c;
              }
            }
            if (a[i] < a[result[u]]) {
              if (u > 0)
                lisTemp[i] = result[u - 1];
              result[u] = i;
            }
          }
          u = result.length;
          v = result[u - 1];
          while (u-- > 0) {
            result[u] = v;
            v = lisTemp[v];
          }
          lisTemp.length = 0;
          return result;
        }
        function getNextSibling(vnodes, i, nextSibling) {
          for (; i < vnodes.length; i++) {
            if (vnodes[i] != null && vnodes[i].dom != null)
              return vnodes[i].dom;
          }
          return nextSibling;
        }
        function moveNodes(parent, vnode, nextSibling) {
          var frag = $doc.createDocumentFragment();
          moveChildToFrag(parent, frag, vnode);
          insertNode(parent, frag, nextSibling);
        }
        function moveChildToFrag(parent, frag, vnode) {
          while (vnode.dom != null && vnode.dom.parentNode === parent) {
            if (typeof vnode.tag !== "string") {
              vnode = vnode.instance;
              if (vnode != null)
                continue;
            } else if (vnode.tag === "<") {
              for (var i = 0; i < vnode.instance.length; i++) {
                frag.appendChild(vnode.instance[i]);
              }
            } else if (vnode.tag !== "[") {
              frag.appendChild(vnode.dom);
            } else if (vnode.children.length === 1) {
              vnode = vnode.children[0];
              if (vnode != null)
                continue;
            } else {
              for (var i = 0; i < vnode.children.length; i++) {
                var child = vnode.children[i];
                if (child != null)
                  moveChildToFrag(parent, frag, child);
              }
            }
            break;
          }
        }
        function insertNode(parent, dom, nextSibling) {
          if (nextSibling != null)
            parent.insertBefore(dom, nextSibling);
          else
            parent.appendChild(dom);
        }
        function maybeSetContentEditable(vnode) {
          if (vnode.attrs == null || vnode.attrs.contenteditable == null && vnode.attrs.contentEditable == null)
            return false;
          var children = vnode.children;
          if (children != null && children.length === 1 && children[0].tag === "<") {
            var content = children[0].children;
            if (vnode.dom.innerHTML !== content)
              vnode.dom.innerHTML = content;
          } else if (children != null && children.length !== 0)
            throw new Error("Child node of a contenteditable must be trusted.");
          return true;
        }
        function removeNodes(parent, vnodes, start, end) {
          for (var i = start; i < end; i++) {
            var vnode = vnodes[i];
            if (vnode != null)
              removeNode(parent, vnode);
          }
        }
        function removeNode(parent, vnode) {
          var mask = 0;
          var original = vnode.state;
          var stateResult, attrsResult;
          if (typeof vnode.tag !== "string" && typeof vnode.state.onbeforeremove === "function") {
            var result = callHook.call(vnode.state.onbeforeremove, vnode);
            if (result != null && typeof result.then === "function") {
              mask = 1;
              stateResult = result;
            }
          }
          if (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {
            var result = callHook.call(vnode.attrs.onbeforeremove, vnode);
            if (result != null && typeof result.then === "function") {
              mask |= 2;
              attrsResult = result;
            }
          }
          checkState(vnode, original);
          if (!mask) {
            onremove(vnode);
            removeChild(parent, vnode);
          } else {
            if (stateResult != null) {
              var next = function() {
                if (mask & 1) {
                  mask &= 2;
                  if (!mask)
                    reallyRemove();
                }
              };
              stateResult.then(next, next);
            }
            if (attrsResult != null) {
              var next = function() {
                if (mask & 2) {
                  mask &= 1;
                  if (!mask)
                    reallyRemove();
                }
              };
              attrsResult.then(next, next);
            }
          }
          function reallyRemove() {
            checkState(vnode, original);
            onremove(vnode);
            removeChild(parent, vnode);
          }
        }
        function removeHTML(parent, vnode) {
          for (var i = 0; i < vnode.instance.length; i++) {
            parent.removeChild(vnode.instance[i]);
          }
        }
        function removeChild(parent, vnode) {
          while (vnode.dom != null && vnode.dom.parentNode === parent) {
            if (typeof vnode.tag !== "string") {
              vnode = vnode.instance;
              if (vnode != null)
                continue;
            } else if (vnode.tag === "<") {
              removeHTML(parent, vnode);
            } else {
              if (vnode.tag !== "[") {
                parent.removeChild(vnode.dom);
                if (!Array.isArray(vnode.children))
                  break;
              }
              if (vnode.children.length === 1) {
                vnode = vnode.children[0];
                if (vnode != null)
                  continue;
              } else {
                for (var i = 0; i < vnode.children.length; i++) {
                  var child = vnode.children[i];
                  if (child != null)
                    removeChild(parent, child);
                }
              }
            }
            break;
          }
        }
        function onremove(vnode) {
          if (typeof vnode.tag !== "string" && typeof vnode.state.onremove === "function")
            callHook.call(vnode.state.onremove, vnode);
          if (vnode.attrs && typeof vnode.attrs.onremove === "function")
            callHook.call(vnode.attrs.onremove, vnode);
          if (typeof vnode.tag !== "string") {
            if (vnode.instance != null)
              onremove(vnode.instance);
          } else {
            var children = vnode.children;
            if (Array.isArray(children)) {
              for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (child != null)
                  onremove(child);
              }
            }
          }
        }
        function setAttrs(vnode, attrs, ns) {
          if (vnode.tag === "input" && attrs.type != null)
            vnode.dom.setAttribute("type", attrs.type);
          var isFileInput = attrs != null && vnode.tag === "input" && attrs.type === "file";
          for (var key in attrs) {
            setAttr(vnode, key, null, attrs[key], ns, isFileInput);
          }
        }
        function setAttr(vnode, key, old, value, ns, isFileInput) {
          if (key === "key" || key === "is" || value == null || isLifecycleMethod(key) || old === value && !isFormAttribute(vnode, key) && typeof value !== "object" || key === "type" && vnode.tag === "input")
            return;
          if (key[0] === "o" && key[1] === "n")
            return updateEvent(vnode, key, value);
          if (key.slice(0, 6) === "xlink:")
            vnode.dom.setAttributeNS("http://www.w3.org/1999/xlink", key.slice(6), value);
          else if (key === "style")
            updateStyle(vnode.dom, old, value);
          else if (hasPropertyKey(vnode, key, ns)) {
            if (key === "value") {
              if ((vnode.tag === "input" || vnode.tag === "textarea") && vnode.dom.value === "" + value && (isFileInput || vnode.dom === activeElement()))
                return;
              if (vnode.tag === "select" && old !== null && vnode.dom.value === "" + value)
                return;
              if (vnode.tag === "option" && old !== null && vnode.dom.value === "" + value)
                return;
              if (isFileInput && "" + value !== "") {
                console.error("`value` is read-only on file inputs!");
                return;
              }
            }
            vnode.dom[key] = value;
          } else {
            if (typeof value === "boolean") {
              if (value)
                vnode.dom.setAttribute(key, "");
              else
                vnode.dom.removeAttribute(key);
            } else
              vnode.dom.setAttribute(key === "className" ? "class" : key, value);
          }
        }
        function removeAttr(vnode, key, old, ns) {
          if (key === "key" || key === "is" || old == null || isLifecycleMethod(key))
            return;
          if (key[0] === "o" && key[1] === "n")
            updateEvent(vnode, key, void 0);
          else if (key === "style")
            updateStyle(vnode.dom, old, null);
          else if (hasPropertyKey(vnode, key, ns) && key !== "className" && key !== "title" && !(key === "value" && (vnode.tag === "option" || vnode.tag === "select" && vnode.dom.selectedIndex === -1 && vnode.dom === activeElement())) && !(vnode.tag === "input" && key === "type")) {
            vnode.dom[key] = null;
          } else {
            var nsLastIndex = key.indexOf(":");
            if (nsLastIndex !== -1)
              key = key.slice(nsLastIndex + 1);
            if (old !== false)
              vnode.dom.removeAttribute(key === "className" ? "class" : key);
          }
        }
        function setLateSelectAttrs(vnode, attrs) {
          if ("value" in attrs) {
            if (attrs.value === null) {
              if (vnode.dom.selectedIndex !== -1)
                vnode.dom.value = null;
            } else {
              var normalized = "" + attrs.value;
              if (vnode.dom.value !== normalized || vnode.dom.selectedIndex === -1) {
                vnode.dom.value = normalized;
              }
            }
          }
          if ("selectedIndex" in attrs)
            setAttr(vnode, "selectedIndex", null, attrs.selectedIndex, void 0);
        }
        function updateAttrs(vnode, old, attrs, ns) {
          if (old && old === attrs) {
            console.warn("Don't reuse attrs object, use new object for every redraw, this will throw in next major");
          }
          if (attrs != null) {
            if (vnode.tag === "input" && attrs.type != null)
              vnode.dom.setAttribute("type", attrs.type);
            var isFileInput = vnode.tag === "input" && attrs.type === "file";
            for (var key in attrs) {
              setAttr(vnode, key, old && old[key], attrs[key], ns, isFileInput);
            }
          }
          var val;
          if (old != null) {
            for (var key in old) {
              if ((val = old[key]) != null && (attrs == null || attrs[key] == null)) {
                removeAttr(vnode, key, val, ns);
              }
            }
          }
        }
        function isFormAttribute(vnode, attr) {
          return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === activeElement() || vnode.tag === "option" && vnode.dom.parentNode === $doc.activeElement;
        }
        function isLifecycleMethod(attr) {
          return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate";
        }
        function hasPropertyKey(vnode, key, ns) {
          return ns === void 0 && (vnode.tag.indexOf("-") > -1 || vnode.attrs != null && vnode.attrs.is || key !== "href" && key !== "list" && key !== "form" && key !== "width" && key !== "height") && key in vnode.dom;
        }
        var uppercaseRegex = /[A-Z]/g;
        function toLowerCase(capital) {
          return "-" + capital.toLowerCase();
        }
        function normalizeKey(key) {
          return key[0] === "-" && key[1] === "-" ? key : key === "cssFloat" ? "float" : key.replace(uppercaseRegex, toLowerCase);
        }
        function updateStyle(element, old, style) {
          if (old === style) {
          } else if (style == null) {
            element.style.cssText = "";
          } else if (typeof style !== "object") {
            element.style.cssText = style;
          } else if (old == null || typeof old !== "object") {
            element.style.cssText = "";
            for (var key in style) {
              var value = style[key];
              if (value != null)
                element.style.setProperty(normalizeKey(key), String(value));
            }
          } else {
            for (var key in style) {
              var value = style[key];
              if (value != null && (value = String(value)) !== String(old[key])) {
                element.style.setProperty(normalizeKey(key), value);
              }
            }
            for (var key in old) {
              if (old[key] != null && style[key] == null) {
                element.style.removeProperty(normalizeKey(key));
              }
            }
          }
        }
        function EventDict() {
          this._ = currentRedraw;
        }
        EventDict.prototype = /* @__PURE__ */ Object.create(null);
        EventDict.prototype.handleEvent = function(ev) {
          var handler = this["on" + ev.type];
          var result;
          if (typeof handler === "function")
            result = handler.call(ev.currentTarget, ev);
          else if (typeof handler.handleEvent === "function")
            handler.handleEvent(ev);
          if (this._ && ev.redraw !== false)
            (0, this._)();
          if (result === false) {
            ev.preventDefault();
            ev.stopPropagation();
          }
        };
        function updateEvent(vnode, key, value) {
          if (vnode.events != null) {
            vnode.events._ = currentRedraw;
            if (vnode.events[key] === value)
              return;
            if (value != null && (typeof value === "function" || typeof value === "object")) {
              if (vnode.events[key] == null)
                vnode.dom.addEventListener(key.slice(2), vnode.events, false);
              vnode.events[key] = value;
            } else {
              if (vnode.events[key] != null)
                vnode.dom.removeEventListener(key.slice(2), vnode.events, false);
              vnode.events[key] = void 0;
            }
          } else if (value != null && (typeof value === "function" || typeof value === "object")) {
            vnode.events = new EventDict();
            vnode.dom.addEventListener(key.slice(2), vnode.events, false);
            vnode.events[key] = value;
          }
        }
        function initLifecycle(source, vnode, hooks) {
          if (typeof source.oninit === "function")
            callHook.call(source.oninit, vnode);
          if (typeof source.oncreate === "function")
            hooks.push(callHook.bind(source.oncreate, vnode));
        }
        function updateLifecycle(source, vnode, hooks) {
          if (typeof source.onupdate === "function")
            hooks.push(callHook.bind(source.onupdate, vnode));
        }
        function shouldNotUpdate(vnode, old) {
          do {
            if (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") {
              var force = callHook.call(vnode.attrs.onbeforeupdate, vnode, old);
              if (force !== void 0 && !force)
                break;
            }
            if (typeof vnode.tag !== "string" && typeof vnode.state.onbeforeupdate === "function") {
              var force = callHook.call(vnode.state.onbeforeupdate, vnode, old);
              if (force !== void 0 && !force)
                break;
            }
            return false;
          } while (false);
          vnode.dom = old.dom;
          vnode.domSize = old.domSize;
          vnode.instance = old.instance;
          vnode.attrs = old.attrs;
          vnode.children = old.children;
          vnode.text = old.text;
          return true;
        }
        var currentDOM;
        return function(dom, vnodes, redraw) {
          if (!dom)
            throw new TypeError("DOM element being rendered to does not exist.");
          if (currentDOM != null && dom.contains(currentDOM)) {
            throw new TypeError("Node is currently being rendered to and thus is locked.");
          }
          var prevRedraw = currentRedraw;
          var prevDOM = currentDOM;
          var hooks = [];
          var active = activeElement();
          var namespace = dom.namespaceURI;
          currentDOM = dom;
          currentRedraw = typeof redraw === "function" ? redraw : void 0;
          try {
            if (dom.vnodes == null)
              dom.textContent = "";
            vnodes = Vnode.normalizeChildren(Array.isArray(vnodes) ? vnodes : [vnodes]);
            updateNodes(dom, dom.vnodes, vnodes, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? void 0 : namespace);
            dom.vnodes = vnodes;
            if (active != null && activeElement() !== active && typeof active.focus === "function")
              active.focus();
            for (var i = 0; i < hooks.length; i++)
              hooks[i]();
          } finally {
            currentRedraw = prevRedraw;
            currentDOM = prevDOM;
          }
        };
      };
    }
  });

  // node_modules/mithril/render.js
  var require_render2 = __commonJS({
    "node_modules/mithril/render.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      module.exports = require_render()(typeof window !== "undefined" ? window : null);
    }
  });

  // node_modules/mithril/api/mount-redraw.js
  var require_mount_redraw = __commonJS({
    "node_modules/mithril/api/mount-redraw.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      var Vnode = require_vnode();
      module.exports = function(render, schedule, console2) {
        var subscriptions = [];
        var pending = false;
        var offset = -1;
        function sync() {
          for (offset = 0; offset < subscriptions.length; offset += 2) {
            try {
              render(subscriptions[offset], Vnode(subscriptions[offset + 1]), redraw);
            } catch (e) {
              console2.error(e);
            }
          }
          offset = -1;
        }
        function redraw() {
          if (!pending) {
            pending = true;
            schedule(function() {
              pending = false;
              sync();
            });
          }
        }
        redraw.sync = sync;
        function mount(root, component) {
          if (component != null && component.view == null && typeof component !== "function") {
            throw new TypeError("m.mount expects a component, not a vnode.");
          }
          var index = subscriptions.indexOf(root);
          if (index >= 0) {
            subscriptions.splice(index, 2);
            if (index <= offset)
              offset -= 2;
            render(root, []);
          }
          if (component != null) {
            subscriptions.push(root, component);
            render(root, Vnode(component), redraw);
          }
        }
        return { mount, redraw };
      };
    }
  });

  // node_modules/mithril/mount-redraw.js
  var require_mount_redraw2 = __commonJS({
    "node_modules/mithril/mount-redraw.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      var render = require_render2();
      module.exports = require_mount_redraw()(render, typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : null, typeof console !== "undefined" ? console : null);
    }
  });

  // node_modules/mithril/querystring/build.js
  var require_build = __commonJS({
    "node_modules/mithril/querystring/build.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      module.exports = function(object) {
        if (Object.prototype.toString.call(object) !== "[object Object]")
          return "";
        var args = [];
        for (var key in object) {
          destructure(key, object[key]);
        }
        return args.join("&");
        function destructure(key2, value) {
          if (Array.isArray(value)) {
            for (var i = 0; i < value.length; i++) {
              destructure(key2 + "[" + i + "]", value[i]);
            }
          } else if (Object.prototype.toString.call(value) === "[object Object]") {
            for (var i in value) {
              destructure(key2 + "[" + i + "]", value[i]);
            }
          } else
            args.push(encodeURIComponent(key2) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""));
        }
      };
    }
  });

  // node_modules/mithril/util/assign.js
  var require_assign = __commonJS({
    "node_modules/mithril/util/assign.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      var hasOwn = require_hasOwn();
      module.exports = Object.assign || function(target, source) {
        for (var key in source) {
          if (hasOwn.call(source, key))
            target[key] = source[key];
        }
      };
    }
  });

  // node_modules/mithril/pathname/build.js
  var require_build2 = __commonJS({
    "node_modules/mithril/pathname/build.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      var buildQueryString = require_build();
      var assign = require_assign();
      module.exports = function(template, params) {
        if (/:([^\/\.-]+)(\.{3})?:/.test(template)) {
          throw new SyntaxError("Template parameter names must be separated by either a '/', '-', or '.'.");
        }
        if (params == null)
          return template;
        var queryIndex = template.indexOf("?");
        var hashIndex = template.indexOf("#");
        var queryEnd = hashIndex < 0 ? template.length : hashIndex;
        var pathEnd = queryIndex < 0 ? queryEnd : queryIndex;
        var path3 = template.slice(0, pathEnd);
        var query = {};
        assign(query, params);
        var resolved = path3.replace(/:([^\/\.-]+)(\.{3})?/g, function(m3, key, variadic) {
          delete query[key];
          if (params[key] == null)
            return m3;
          return variadic ? params[key] : encodeURIComponent(String(params[key]));
        });
        var newQueryIndex = resolved.indexOf("?");
        var newHashIndex = resolved.indexOf("#");
        var newQueryEnd = newHashIndex < 0 ? resolved.length : newHashIndex;
        var newPathEnd = newQueryIndex < 0 ? newQueryEnd : newQueryIndex;
        var result = resolved.slice(0, newPathEnd);
        if (queryIndex >= 0)
          result += template.slice(queryIndex, queryEnd);
        if (newQueryIndex >= 0)
          result += (queryIndex < 0 ? "?" : "&") + resolved.slice(newQueryIndex, newQueryEnd);
        var querystring = buildQueryString(query);
        if (querystring)
          result += (queryIndex < 0 && newQueryIndex < 0 ? "?" : "&") + querystring;
        if (hashIndex >= 0)
          result += template.slice(hashIndex);
        if (newHashIndex >= 0)
          result += (hashIndex < 0 ? "" : "&") + resolved.slice(newHashIndex);
        return result;
      };
    }
  });

  // node_modules/mithril/request/request.js
  var require_request = __commonJS({
    "node_modules/mithril/request/request.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      var buildPathname = require_build2();
      var hasOwn = require_hasOwn();
      module.exports = function($window, Promise2, oncompletion) {
        var callbackCount = 0;
        function PromiseProxy(executor) {
          return new Promise2(executor);
        }
        PromiseProxy.prototype = Promise2.prototype;
        PromiseProxy.__proto__ = Promise2;
        function makeRequest(factory) {
          return function(url, args) {
            if (typeof url !== "string") {
              args = url;
              url = url.url;
            } else if (args == null)
              args = {};
            var promise = new Promise2(function(resolve, reject) {
              factory(buildPathname(url, args.params), args, function(data) {
                if (typeof args.type === "function") {
                  if (Array.isArray(data)) {
                    for (var i = 0; i < data.length; i++) {
                      data[i] = new args.type(data[i]);
                    }
                  } else
                    data = new args.type(data);
                }
                resolve(data);
              }, reject);
            });
            if (args.background === true)
              return promise;
            var count = 0;
            function complete() {
              if (--count === 0 && typeof oncompletion === "function")
                oncompletion();
            }
            return wrap(promise);
            function wrap(promise2) {
              var then = promise2.then;
              promise2.constructor = PromiseProxy;
              promise2.then = function() {
                count++;
                var next = then.apply(promise2, arguments);
                next.then(complete, function(e) {
                  complete();
                  if (count === 0)
                    throw e;
                });
                return wrap(next);
              };
              return promise2;
            }
          };
        }
        function hasHeader(args, name) {
          for (var key in args.headers) {
            if (hasOwn.call(args.headers, key) && key.toLowerCase() === name)
              return true;
          }
          return false;
        }
        return {
          request: makeRequest(function(url, args, resolve, reject) {
            var method = args.method != null ? args.method.toUpperCase() : "GET";
            var body = args.body;
            var assumeJSON = (args.serialize == null || args.serialize === JSON.serialize) && !(body instanceof $window.FormData || body instanceof $window.URLSearchParams);
            var responseType = args.responseType || (typeof args.extract === "function" ? "" : "json");
            var xhr = new $window.XMLHttpRequest(), aborted = false, isTimeout = false;
            var original = xhr, replacedAbort;
            var abort = xhr.abort;
            xhr.abort = function() {
              aborted = true;
              abort.call(this);
            };
            xhr.open(method, url, args.async !== false, typeof args.user === "string" ? args.user : void 0, typeof args.password === "string" ? args.password : void 0);
            if (assumeJSON && body != null && !hasHeader(args, "content-type")) {
              xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8");
            }
            if (typeof args.deserialize !== "function" && !hasHeader(args, "accept")) {
              xhr.setRequestHeader("Accept", "application/json, text/*");
            }
            if (args.withCredentials)
              xhr.withCredentials = args.withCredentials;
            if (args.timeout)
              xhr.timeout = args.timeout;
            xhr.responseType = responseType;
            for (var key in args.headers) {
              if (hasOwn.call(args.headers, key)) {
                xhr.setRequestHeader(key, args.headers[key]);
              }
            }
            xhr.onreadystatechange = function(ev) {
              if (aborted)
                return;
              if (ev.target.readyState === 4) {
                try {
                  var success = ev.target.status >= 200 && ev.target.status < 300 || ev.target.status === 304 || /^file:\/\//i.test(url);
                  var response = ev.target.response, message;
                  if (responseType === "json") {
                    if (!ev.target.responseType && typeof args.extract !== "function") {
                      try {
                        response = JSON.parse(ev.target.responseText);
                      } catch (e) {
                        response = null;
                      }
                    }
                  } else if (!responseType || responseType === "text") {
                    if (response == null)
                      response = ev.target.responseText;
                  }
                  if (typeof args.extract === "function") {
                    response = args.extract(ev.target, args);
                    success = true;
                  } else if (typeof args.deserialize === "function") {
                    response = args.deserialize(response);
                  }
                  if (success)
                    resolve(response);
                  else {
                    var completeErrorResponse = function() {
                      try {
                        message = ev.target.responseText;
                      } catch (e) {
                        message = response;
                      }
                      var error = new Error(message);
                      error.code = ev.target.status;
                      error.response = response;
                      reject(error);
                    };
                    if (xhr.status === 0) {
                      setTimeout(function() {
                        if (isTimeout)
                          return;
                        completeErrorResponse();
                      });
                    } else
                      completeErrorResponse();
                  }
                } catch (e) {
                  reject(e);
                }
              }
            };
            xhr.ontimeout = function(ev) {
              isTimeout = true;
              var error = new Error("Request timed out");
              error.code = ev.target.status;
              reject(error);
            };
            if (typeof args.config === "function") {
              xhr = args.config(xhr, args, url) || xhr;
              if (xhr !== original) {
                replacedAbort = xhr.abort;
                xhr.abort = function() {
                  aborted = true;
                  replacedAbort.call(this);
                };
              }
            }
            if (body == null)
              xhr.send();
            else if (typeof args.serialize === "function")
              xhr.send(args.serialize(body));
            else if (body instanceof $window.FormData || body instanceof $window.URLSearchParams)
              xhr.send(body);
            else
              xhr.send(JSON.stringify(body));
          }),
          jsonp: makeRequest(function(url, args, resolve, reject) {
            var callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++;
            var script = $window.document.createElement("script");
            $window[callbackName] = function(data) {
              delete $window[callbackName];
              script.parentNode.removeChild(script);
              resolve(data);
            };
            script.onerror = function() {
              delete $window[callbackName];
              script.parentNode.removeChild(script);
              reject(new Error("JSONP request failed"));
            };
            script.src = url + (url.indexOf("?") < 0 ? "?" : "&") + encodeURIComponent(args.callbackKey || "callback") + "=" + encodeURIComponent(callbackName);
            $window.document.documentElement.appendChild(script);
          })
        };
      };
    }
  });

  // node_modules/mithril/request.js
  var require_request2 = __commonJS({
    "node_modules/mithril/request.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      var PromisePolyfill = require_promise();
      var mountRedraw = require_mount_redraw2();
      module.exports = require_request()(typeof window !== "undefined" ? window : null, PromisePolyfill, mountRedraw.redraw);
    }
  });

  // node_modules/mithril/querystring/parse.js
  var require_parse = __commonJS({
    "node_modules/mithril/querystring/parse.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      function decodeURIComponentSave(str) {
        try {
          return decodeURIComponent(str);
        } catch (err) {
          return str;
        }
      }
      module.exports = function(string) {
        if (string === "" || string == null)
          return {};
        if (string.charAt(0) === "?")
          string = string.slice(1);
        var entries = string.split("&"), counters = {}, data = {};
        for (var i = 0; i < entries.length; i++) {
          var entry = entries[i].split("=");
          var key = decodeURIComponentSave(entry[0]);
          var value = entry.length === 2 ? decodeURIComponentSave(entry[1]) : "";
          if (value === "true")
            value = true;
          else if (value === "false")
            value = false;
          var levels = key.split(/\]\[?|\[/);
          var cursor = data;
          if (key.indexOf("[") > -1)
            levels.pop();
          for (var j = 0; j < levels.length; j++) {
            var level = levels[j], nextLevel = levels[j + 1];
            var isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10));
            if (level === "") {
              var key = levels.slice(0, j).join();
              if (counters[key] == null) {
                counters[key] = Array.isArray(cursor) ? cursor.length : 0;
              }
              level = counters[key]++;
            } else if (level === "__proto__")
              break;
            if (j === levels.length - 1)
              cursor[level] = value;
            else {
              var desc = Object.getOwnPropertyDescriptor(cursor, level);
              if (desc != null)
                desc = desc.value;
              if (desc == null)
                cursor[level] = desc = isNumber ? [] : {};
              cursor = desc;
            }
          }
        }
        return data;
      };
    }
  });

  // node_modules/mithril/pathname/parse.js
  var require_parse2 = __commonJS({
    "node_modules/mithril/pathname/parse.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      var parseQueryString = require_parse();
      module.exports = function(url) {
        var queryIndex = url.indexOf("?");
        var hashIndex = url.indexOf("#");
        var queryEnd = hashIndex < 0 ? url.length : hashIndex;
        var pathEnd = queryIndex < 0 ? queryEnd : queryIndex;
        var path3 = url.slice(0, pathEnd).replace(/\/{2,}/g, "/");
        if (!path3)
          path3 = "/";
        else {
          if (path3[0] !== "/")
            path3 = "/" + path3;
          if (path3.length > 1 && path3[path3.length - 1] === "/")
            path3 = path3.slice(0, -1);
        }
        return {
          path: path3,
          params: queryIndex < 0 ? {} : parseQueryString(url.slice(queryIndex + 1, queryEnd))
        };
      };
    }
  });

  // node_modules/mithril/pathname/compileTemplate.js
  var require_compileTemplate = __commonJS({
    "node_modules/mithril/pathname/compileTemplate.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      var parsePathname = require_parse2();
      module.exports = function(template) {
        var templateData = parsePathname(template);
        var templateKeys = Object.keys(templateData.params);
        var keys = [];
        var regexp = new RegExp("^" + templateData.path.replace(
          /:([^\/.-]+)(\.{3}|\.(?!\.)|-)?|[\\^$*+.()|\[\]{}]/g,
          function(m3, key, extra) {
            if (key == null)
              return "\\" + m3;
            keys.push({ k: key, r: extra === "..." });
            if (extra === "...")
              return "(.*)";
            if (extra === ".")
              return "([^/]+)\\.";
            return "([^/]+)" + (extra || "");
          }
        ) + "$");
        return function(data) {
          for (var i = 0; i < templateKeys.length; i++) {
            if (templateData.params[templateKeys[i]] !== data.params[templateKeys[i]])
              return false;
          }
          if (!keys.length)
            return regexp.test(data.path);
          var values = regexp.exec(data.path);
          if (values == null)
            return false;
          for (var i = 0; i < keys.length; i++) {
            data.params[keys[i].k] = keys[i].r ? values[i + 1] : decodeURIComponent(values[i + 1]);
          }
          return true;
        };
      };
    }
  });

  // node_modules/mithril/util/censor.js
  var require_censor = __commonJS({
    "node_modules/mithril/util/censor.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      var hasOwn = require_hasOwn();
      var magic = new RegExp("^(?:key|oninit|oncreate|onbeforeupdate|onupdate|onbeforeremove|onremove)$");
      module.exports = function(attrs, extras) {
        var result = {};
        if (extras != null) {
          for (var key in attrs) {
            if (hasOwn.call(attrs, key) && !magic.test(key) && extras.indexOf(key) < 0) {
              result[key] = attrs[key];
            }
          }
        } else {
          for (var key in attrs) {
            if (hasOwn.call(attrs, key) && !magic.test(key)) {
              result[key] = attrs[key];
            }
          }
        }
        return result;
      };
    }
  });

  // node_modules/mithril/api/router.js
  var require_router = __commonJS({
    "node_modules/mithril/api/router.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      var Vnode = require_vnode();
      var m3 = require_hyperscript();
      var Promise2 = require_promise();
      var buildPathname = require_build2();
      var parsePathname = require_parse2();
      var compileTemplate = require_compileTemplate();
      var assign = require_assign();
      var censor = require_censor();
      var sentinel = {};
      function decodeURIComponentSave(component) {
        try {
          return decodeURIComponent(component);
        } catch (e) {
          return component;
        }
      }
      module.exports = function($window, mountRedraw) {
        var callAsync = $window == null ? null : typeof $window.setImmediate === "function" ? $window.setImmediate : $window.setTimeout;
        var p = Promise2.resolve();
        var scheduled = false;
        var ready = false;
        var state = 0;
        var compiled, fallbackRoute;
        var currentResolver = sentinel, component, attrs, currentPath, lastUpdate;
        var RouterRoot = {
          onbeforeupdate: function() {
            state = state ? 2 : 1;
            return !(!state || sentinel === currentResolver);
          },
          onremove: function() {
            $window.removeEventListener("popstate", fireAsync, false);
            $window.removeEventListener("hashchange", resolveRoute, false);
          },
          view: function() {
            if (!state || sentinel === currentResolver)
              return;
            var vnode = [Vnode(component, attrs.key, attrs)];
            if (currentResolver)
              vnode = currentResolver.render(vnode[0]);
            return vnode;
          }
        };
        var SKIP = route.SKIP = {};
        function resolveRoute() {
          scheduled = false;
          var prefix = $window.location.hash;
          if (route.prefix[0] !== "#") {
            prefix = $window.location.search + prefix;
            if (route.prefix[0] !== "?") {
              prefix = $window.location.pathname + prefix;
              if (prefix[0] !== "/")
                prefix = "/" + prefix;
            }
          }
          var path3 = prefix.concat().replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponentSave).slice(route.prefix.length);
          var data = parsePathname(path3);
          assign(data.params, $window.history.state);
          function reject(e) {
            console.error(e);
            setPath(fallbackRoute, null, { replace: true });
          }
          loop(0);
          function loop(i) {
            for (; i < compiled.length; i++) {
              if (compiled[i].check(data)) {
                var payload = compiled[i].component;
                var matchedRoute = compiled[i].route;
                var localComp = payload;
                var update = lastUpdate = function(comp) {
                  if (update !== lastUpdate)
                    return;
                  if (comp === SKIP)
                    return loop(i + 1);
                  component = comp != null && (typeof comp.view === "function" || typeof comp === "function") ? comp : "div";
                  attrs = data.params, currentPath = path3, lastUpdate = null;
                  currentResolver = payload.render ? payload : null;
                  if (state === 2)
                    mountRedraw.redraw();
                  else {
                    state = 2;
                    mountRedraw.redraw.sync();
                  }
                };
                if (payload.view || typeof payload === "function") {
                  payload = {};
                  update(localComp);
                } else if (payload.onmatch) {
                  p.then(function() {
                    return payload.onmatch(data.params, path3, matchedRoute);
                  }).then(update, path3 === fallbackRoute ? null : reject);
                } else
                  update("div");
                return;
              }
            }
            if (path3 === fallbackRoute) {
              throw new Error("Could not resolve default route " + fallbackRoute + ".");
            }
            setPath(fallbackRoute, null, { replace: true });
          }
        }
        function fireAsync() {
          if (!scheduled) {
            scheduled = true;
            callAsync(resolveRoute);
          }
        }
        function setPath(path3, data, options) {
          path3 = buildPathname(path3, data);
          if (ready) {
            fireAsync();
            var state2 = options ? options.state : null;
            var title = options ? options.title : null;
            if (options && options.replace)
              $window.history.replaceState(state2, title, route.prefix + path3);
            else
              $window.history.pushState(state2, title, route.prefix + path3);
          } else {
            $window.location.href = route.prefix + path3;
          }
        }
        function route(root, defaultRoute, routes) {
          if (!root)
            throw new TypeError("DOM element being rendered to does not exist.");
          compiled = Object.keys(routes).map(function(route2) {
            if (route2[0] !== "/")
              throw new SyntaxError("Routes must start with a '/'.");
            if (/:([^\/\.-]+)(\.{3})?:/.test(route2)) {
              throw new SyntaxError("Route parameter names must be separated with either '/', '.', or '-'.");
            }
            return {
              route: route2,
              component: routes[route2],
              check: compileTemplate(route2)
            };
          });
          fallbackRoute = defaultRoute;
          if (defaultRoute != null) {
            var defaultData = parsePathname(defaultRoute);
            if (!compiled.some(function(i) {
              return i.check(defaultData);
            })) {
              throw new ReferenceError("Default route doesn't match any known routes.");
            }
          }
          if (typeof $window.history.pushState === "function") {
            $window.addEventListener("popstate", fireAsync, false);
          } else if (route.prefix[0] === "#") {
            $window.addEventListener("hashchange", resolveRoute, false);
          }
          ready = true;
          mountRedraw.mount(root, RouterRoot);
          resolveRoute();
        }
        route.set = function(path3, data, options) {
          if (lastUpdate != null) {
            options = options || {};
            options.replace = true;
          }
          lastUpdate = null;
          setPath(path3, data, options);
        };
        route.get = function() {
          return currentPath;
        };
        route.prefix = "#!";
        route.Link = {
          view: function(vnode) {
            var child = m3(
              vnode.attrs.selector || "a",
              censor(vnode.attrs, ["options", "params", "selector", "onclick"]),
              vnode.children
            );
            var options, onclick, href;
            if (child.attrs.disabled = Boolean(child.attrs.disabled)) {
              child.attrs.href = null;
              child.attrs["aria-disabled"] = "true";
            } else {
              options = vnode.attrs.options;
              onclick = vnode.attrs.onclick;
              href = buildPathname(child.attrs.href, vnode.attrs.params);
              child.attrs.href = route.prefix + href;
              child.attrs.onclick = function(e) {
                var result;
                if (typeof onclick === "function") {
                  result = onclick.call(e.currentTarget, e);
                } else if (onclick == null || typeof onclick !== "object") {
                } else if (typeof onclick.handleEvent === "function") {
                  onclick.handleEvent(e);
                }
                if (result !== false && !e.defaultPrevented && (e.button === 0 || e.which === 0 || e.which === 1) && (!e.currentTarget.target || e.currentTarget.target === "_self") && !e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey) {
                  e.preventDefault();
                  e.redraw = false;
                  route.set(href, null, options);
                }
              };
            }
            return child;
          }
        };
        route.param = function(key) {
          return attrs && key != null ? attrs[key] : attrs;
        };
        return route;
      };
    }
  });

  // node_modules/mithril/route.js
  var require_route = __commonJS({
    "node_modules/mithril/route.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      var mountRedraw = require_mount_redraw2();
      module.exports = require_router()(typeof window !== "undefined" ? window : null, mountRedraw);
    }
  });

  // node_modules/mithril/index.js
  var require_mithril = __commonJS({
    "node_modules/mithril/index.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      var hyperscript = require_hyperscript2();
      var request = require_request2();
      var mountRedraw = require_mount_redraw2();
      var m3 = function m4() {
        return hyperscript.apply(this, arguments);
      };
      m3.m = hyperscript;
      m3.trust = hyperscript.trust;
      m3.fragment = hyperscript.fragment;
      m3.Fragment = "[";
      m3.mount = mountRedraw.mount;
      m3.route = require_route();
      m3.render = require_render2();
      m3.redraw = mountRedraw.redraw;
      m3.request = request.request;
      m3.jsonp = request.jsonp;
      m3.parseQueryString = require_parse();
      m3.buildQueryString = require_build();
      m3.parsePathname = require_parse2();
      m3.buildPathname = require_build2();
      m3.vnode = require_vnode();
      m3.PromisePolyfill = require_polyfill();
      m3.censor = require_censor();
      module.exports = m3;
    }
  });

  // src/mithril.shim.js
  var import_mithril;
  var init_mithril_shim = __esm({
    "src/mithril.shim.js"() {
      import_mithril = __toESM(require_mithril());
    }
  });

  // node_modules/mime-db/db.json
  var require_db = __commonJS({
    "node_modules/mime-db/db.json"(exports, module) {
      module.exports = {
        "application/1d-interleaved-parityfec": {
          source: "iana"
        },
        "application/3gpdash-qoe-report+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/3gpp-ims+xml": {
          source: "iana",
          compressible: true
        },
        "application/3gpphal+json": {
          source: "iana",
          compressible: true
        },
        "application/3gpphalforms+json": {
          source: "iana",
          compressible: true
        },
        "application/a2l": {
          source: "iana"
        },
        "application/ace+cbor": {
          source: "iana"
        },
        "application/activemessage": {
          source: "iana"
        },
        "application/activity+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-costmap+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-costmapfilter+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-directory+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-endpointcost+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-endpointcostparams+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-endpointprop+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-endpointpropparams+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-error+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-networkmap+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-networkmapfilter+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-updatestreamcontrol+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-updatestreamparams+json": {
          source: "iana",
          compressible: true
        },
        "application/aml": {
          source: "iana"
        },
        "application/andrew-inset": {
          source: "iana",
          extensions: ["ez"]
        },
        "application/applefile": {
          source: "iana"
        },
        "application/applixware": {
          source: "apache",
          extensions: ["aw"]
        },
        "application/at+jwt": {
          source: "iana"
        },
        "application/atf": {
          source: "iana"
        },
        "application/atfx": {
          source: "iana"
        },
        "application/atom+xml": {
          source: "iana",
          compressible: true,
          extensions: ["atom"]
        },
        "application/atomcat+xml": {
          source: "iana",
          compressible: true,
          extensions: ["atomcat"]
        },
        "application/atomdeleted+xml": {
          source: "iana",
          compressible: true,
          extensions: ["atomdeleted"]
        },
        "application/atomicmail": {
          source: "iana"
        },
        "application/atomsvc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["atomsvc"]
        },
        "application/atsc-dwd+xml": {
          source: "iana",
          compressible: true,
          extensions: ["dwd"]
        },
        "application/atsc-dynamic-event-message": {
          source: "iana"
        },
        "application/atsc-held+xml": {
          source: "iana",
          compressible: true,
          extensions: ["held"]
        },
        "application/atsc-rdt+json": {
          source: "iana",
          compressible: true
        },
        "application/atsc-rsat+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rsat"]
        },
        "application/atxml": {
          source: "iana"
        },
        "application/auth-policy+xml": {
          source: "iana",
          compressible: true
        },
        "application/bacnet-xdd+zip": {
          source: "iana",
          compressible: false
        },
        "application/batch-smtp": {
          source: "iana"
        },
        "application/bdoc": {
          compressible: false,
          extensions: ["bdoc"]
        },
        "application/beep+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/calendar+json": {
          source: "iana",
          compressible: true
        },
        "application/calendar+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xcs"]
        },
        "application/call-completion": {
          source: "iana"
        },
        "application/cals-1840": {
          source: "iana"
        },
        "application/captive+json": {
          source: "iana",
          compressible: true
        },
        "application/cbor": {
          source: "iana"
        },
        "application/cbor-seq": {
          source: "iana"
        },
        "application/cccex": {
          source: "iana"
        },
        "application/ccmp+xml": {
          source: "iana",
          compressible: true
        },
        "application/ccxml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ccxml"]
        },
        "application/cdfx+xml": {
          source: "iana",
          compressible: true,
          extensions: ["cdfx"]
        },
        "application/cdmi-capability": {
          source: "iana",
          extensions: ["cdmia"]
        },
        "application/cdmi-container": {
          source: "iana",
          extensions: ["cdmic"]
        },
        "application/cdmi-domain": {
          source: "iana",
          extensions: ["cdmid"]
        },
        "application/cdmi-object": {
          source: "iana",
          extensions: ["cdmio"]
        },
        "application/cdmi-queue": {
          source: "iana",
          extensions: ["cdmiq"]
        },
        "application/cdni": {
          source: "iana"
        },
        "application/cea": {
          source: "iana"
        },
        "application/cea-2018+xml": {
          source: "iana",
          compressible: true
        },
        "application/cellml+xml": {
          source: "iana",
          compressible: true
        },
        "application/cfw": {
          source: "iana"
        },
        "application/city+json": {
          source: "iana",
          compressible: true
        },
        "application/clr": {
          source: "iana"
        },
        "application/clue+xml": {
          source: "iana",
          compressible: true
        },
        "application/clue_info+xml": {
          source: "iana",
          compressible: true
        },
        "application/cms": {
          source: "iana"
        },
        "application/cnrp+xml": {
          source: "iana",
          compressible: true
        },
        "application/coap-group+json": {
          source: "iana",
          compressible: true
        },
        "application/coap-payload": {
          source: "iana"
        },
        "application/commonground": {
          source: "iana"
        },
        "application/conference-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/cose": {
          source: "iana"
        },
        "application/cose-key": {
          source: "iana"
        },
        "application/cose-key-set": {
          source: "iana"
        },
        "application/cpl+xml": {
          source: "iana",
          compressible: true,
          extensions: ["cpl"]
        },
        "application/csrattrs": {
          source: "iana"
        },
        "application/csta+xml": {
          source: "iana",
          compressible: true
        },
        "application/cstadata+xml": {
          source: "iana",
          compressible: true
        },
        "application/csvm+json": {
          source: "iana",
          compressible: true
        },
        "application/cu-seeme": {
          source: "apache",
          extensions: ["cu"]
        },
        "application/cwt": {
          source: "iana"
        },
        "application/cybercash": {
          source: "iana"
        },
        "application/dart": {
          compressible: true
        },
        "application/dash+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mpd"]
        },
        "application/dash-patch+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mpp"]
        },
        "application/dashdelta": {
          source: "iana"
        },
        "application/davmount+xml": {
          source: "iana",
          compressible: true,
          extensions: ["davmount"]
        },
        "application/dca-rft": {
          source: "iana"
        },
        "application/dcd": {
          source: "iana"
        },
        "application/dec-dx": {
          source: "iana"
        },
        "application/dialog-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/dicom": {
          source: "iana"
        },
        "application/dicom+json": {
          source: "iana",
          compressible: true
        },
        "application/dicom+xml": {
          source: "iana",
          compressible: true
        },
        "application/dii": {
          source: "iana"
        },
        "application/dit": {
          source: "iana"
        },
        "application/dns": {
          source: "iana"
        },
        "application/dns+json": {
          source: "iana",
          compressible: true
        },
        "application/dns-message": {
          source: "iana"
        },
        "application/docbook+xml": {
          source: "apache",
          compressible: true,
          extensions: ["dbk"]
        },
        "application/dots+cbor": {
          source: "iana"
        },
        "application/dskpp+xml": {
          source: "iana",
          compressible: true
        },
        "application/dssc+der": {
          source: "iana",
          extensions: ["dssc"]
        },
        "application/dssc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xdssc"]
        },
        "application/dvcs": {
          source: "iana"
        },
        "application/ecmascript": {
          source: "iana",
          compressible: true,
          extensions: ["es", "ecma"]
        },
        "application/edi-consent": {
          source: "iana"
        },
        "application/edi-x12": {
          source: "iana",
          compressible: false
        },
        "application/edifact": {
          source: "iana",
          compressible: false
        },
        "application/efi": {
          source: "iana"
        },
        "application/elm+json": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/elm+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.cap+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/emergencycalldata.comment+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.control+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.deviceinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.ecall.msd": {
          source: "iana"
        },
        "application/emergencycalldata.providerinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.serviceinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.subscriberinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.veds+xml": {
          source: "iana",
          compressible: true
        },
        "application/emma+xml": {
          source: "iana",
          compressible: true,
          extensions: ["emma"]
        },
        "application/emotionml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["emotionml"]
        },
        "application/encaprtp": {
          source: "iana"
        },
        "application/epp+xml": {
          source: "iana",
          compressible: true
        },
        "application/epub+zip": {
          source: "iana",
          compressible: false,
          extensions: ["epub"]
        },
        "application/eshop": {
          source: "iana"
        },
        "application/exi": {
          source: "iana",
          extensions: ["exi"]
        },
        "application/expect-ct-report+json": {
          source: "iana",
          compressible: true
        },
        "application/express": {
          source: "iana",
          extensions: ["exp"]
        },
        "application/fastinfoset": {
          source: "iana"
        },
        "application/fastsoap": {
          source: "iana"
        },
        "application/fdt+xml": {
          source: "iana",
          compressible: true,
          extensions: ["fdt"]
        },
        "application/fhir+json": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/fhir+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/fido.trusted-apps+json": {
          compressible: true
        },
        "application/fits": {
          source: "iana"
        },
        "application/flexfec": {
          source: "iana"
        },
        "application/font-sfnt": {
          source: "iana"
        },
        "application/font-tdpfr": {
          source: "iana",
          extensions: ["pfr"]
        },
        "application/font-woff": {
          source: "iana",
          compressible: false
        },
        "application/framework-attributes+xml": {
          source: "iana",
          compressible: true
        },
        "application/geo+json": {
          source: "iana",
          compressible: true,
          extensions: ["geojson"]
        },
        "application/geo+json-seq": {
          source: "iana"
        },
        "application/geopackage+sqlite3": {
          source: "iana"
        },
        "application/geoxacml+xml": {
          source: "iana",
          compressible: true
        },
        "application/gltf-buffer": {
          source: "iana"
        },
        "application/gml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["gml"]
        },
        "application/gpx+xml": {
          source: "apache",
          compressible: true,
          extensions: ["gpx"]
        },
        "application/gxf": {
          source: "apache",
          extensions: ["gxf"]
        },
        "application/gzip": {
          source: "iana",
          compressible: false,
          extensions: ["gz"]
        },
        "application/h224": {
          source: "iana"
        },
        "application/held+xml": {
          source: "iana",
          compressible: true
        },
        "application/hjson": {
          extensions: ["hjson"]
        },
        "application/http": {
          source: "iana"
        },
        "application/hyperstudio": {
          source: "iana",
          extensions: ["stk"]
        },
        "application/ibe-key-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/ibe-pkg-reply+xml": {
          source: "iana",
          compressible: true
        },
        "application/ibe-pp-data": {
          source: "iana"
        },
        "application/iges": {
          source: "iana"
        },
        "application/im-iscomposing+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/index": {
          source: "iana"
        },
        "application/index.cmd": {
          source: "iana"
        },
        "application/index.obj": {
          source: "iana"
        },
        "application/index.response": {
          source: "iana"
        },
        "application/index.vnd": {
          source: "iana"
        },
        "application/inkml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ink", "inkml"]
        },
        "application/iotp": {
          source: "iana"
        },
        "application/ipfix": {
          source: "iana",
          extensions: ["ipfix"]
        },
        "application/ipp": {
          source: "iana"
        },
        "application/isup": {
          source: "iana"
        },
        "application/its+xml": {
          source: "iana",
          compressible: true,
          extensions: ["its"]
        },
        "application/java-archive": {
          source: "apache",
          compressible: false,
          extensions: ["jar", "war", "ear"]
        },
        "application/java-serialized-object": {
          source: "apache",
          compressible: false,
          extensions: ["ser"]
        },
        "application/java-vm": {
          source: "apache",
          compressible: false,
          extensions: ["class"]
        },
        "application/javascript": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["js", "mjs"]
        },
        "application/jf2feed+json": {
          source: "iana",
          compressible: true
        },
        "application/jose": {
          source: "iana"
        },
        "application/jose+json": {
          source: "iana",
          compressible: true
        },
        "application/jrd+json": {
          source: "iana",
          compressible: true
        },
        "application/jscalendar+json": {
          source: "iana",
          compressible: true
        },
        "application/json": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["json", "map"]
        },
        "application/json-patch+json": {
          source: "iana",
          compressible: true
        },
        "application/json-seq": {
          source: "iana"
        },
        "application/json5": {
          extensions: ["json5"]
        },
        "application/jsonml+json": {
          source: "apache",
          compressible: true,
          extensions: ["jsonml"]
        },
        "application/jwk+json": {
          source: "iana",
          compressible: true
        },
        "application/jwk-set+json": {
          source: "iana",
          compressible: true
        },
        "application/jwt": {
          source: "iana"
        },
        "application/kpml-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/kpml-response+xml": {
          source: "iana",
          compressible: true
        },
        "application/ld+json": {
          source: "iana",
          compressible: true,
          extensions: ["jsonld"]
        },
        "application/lgr+xml": {
          source: "iana",
          compressible: true,
          extensions: ["lgr"]
        },
        "application/link-format": {
          source: "iana"
        },
        "application/load-control+xml": {
          source: "iana",
          compressible: true
        },
        "application/lost+xml": {
          source: "iana",
          compressible: true,
          extensions: ["lostxml"]
        },
        "application/lostsync+xml": {
          source: "iana",
          compressible: true
        },
        "application/lpf+zip": {
          source: "iana",
          compressible: false
        },
        "application/lxf": {
          source: "iana"
        },
        "application/mac-binhex40": {
          source: "iana",
          extensions: ["hqx"]
        },
        "application/mac-compactpro": {
          source: "apache",
          extensions: ["cpt"]
        },
        "application/macwriteii": {
          source: "iana"
        },
        "application/mads+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mads"]
        },
        "application/manifest+json": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["webmanifest"]
        },
        "application/marc": {
          source: "iana",
          extensions: ["mrc"]
        },
        "application/marcxml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mrcx"]
        },
        "application/mathematica": {
          source: "iana",
          extensions: ["ma", "nb", "mb"]
        },
        "application/mathml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mathml"]
        },
        "application/mathml-content+xml": {
          source: "iana",
          compressible: true
        },
        "application/mathml-presentation+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-associated-procedure-description+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-deregister+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-envelope+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-msk+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-msk-response+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-protection-description+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-reception-report+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-register+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-register-response+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-schedule+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-user-service-description+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbox": {
          source: "iana",
          extensions: ["mbox"]
        },
        "application/media-policy-dataset+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mpf"]
        },
        "application/media_control+xml": {
          source: "iana",
          compressible: true
        },
        "application/mediaservercontrol+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mscml"]
        },
        "application/merge-patch+json": {
          source: "iana",
          compressible: true
        },
        "application/metalink+xml": {
          source: "apache",
          compressible: true,
          extensions: ["metalink"]
        },
        "application/metalink4+xml": {
          source: "iana",
          compressible: true,
          extensions: ["meta4"]
        },
        "application/mets+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mets"]
        },
        "application/mf4": {
          source: "iana"
        },
        "application/mikey": {
          source: "iana"
        },
        "application/mipc": {
          source: "iana"
        },
        "application/missing-blocks+cbor-seq": {
          source: "iana"
        },
        "application/mmt-aei+xml": {
          source: "iana",
          compressible: true,
          extensions: ["maei"]
        },
        "application/mmt-usd+xml": {
          source: "iana",
          compressible: true,
          extensions: ["musd"]
        },
        "application/mods+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mods"]
        },
        "application/moss-keys": {
          source: "iana"
        },
        "application/moss-signature": {
          source: "iana"
        },
        "application/mosskey-data": {
          source: "iana"
        },
        "application/mosskey-request": {
          source: "iana"
        },
        "application/mp21": {
          source: "iana",
          extensions: ["m21", "mp21"]
        },
        "application/mp4": {
          source: "iana",
          extensions: ["mp4s", "m4p"]
        },
        "application/mpeg4-generic": {
          source: "iana"
        },
        "application/mpeg4-iod": {
          source: "iana"
        },
        "application/mpeg4-iod-xmt": {
          source: "iana"
        },
        "application/mrb-consumer+xml": {
          source: "iana",
          compressible: true
        },
        "application/mrb-publish+xml": {
          source: "iana",
          compressible: true
        },
        "application/msc-ivr+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/msc-mixer+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/msword": {
          source: "iana",
          compressible: false,
          extensions: ["doc", "dot"]
        },
        "application/mud+json": {
          source: "iana",
          compressible: true
        },
        "application/multipart-core": {
          source: "iana"
        },
        "application/mxf": {
          source: "iana",
          extensions: ["mxf"]
        },
        "application/n-quads": {
          source: "iana",
          extensions: ["nq"]
        },
        "application/n-triples": {
          source: "iana",
          extensions: ["nt"]
        },
        "application/nasdata": {
          source: "iana"
        },
        "application/news-checkgroups": {
          source: "iana",
          charset: "US-ASCII"
        },
        "application/news-groupinfo": {
          source: "iana",
          charset: "US-ASCII"
        },
        "application/news-transmission": {
          source: "iana"
        },
        "application/nlsml+xml": {
          source: "iana",
          compressible: true
        },
        "application/node": {
          source: "iana",
          extensions: ["cjs"]
        },
        "application/nss": {
          source: "iana"
        },
        "application/oauth-authz-req+jwt": {
          source: "iana"
        },
        "application/oblivious-dns-message": {
          source: "iana"
        },
        "application/ocsp-request": {
          source: "iana"
        },
        "application/ocsp-response": {
          source: "iana"
        },
        "application/octet-stream": {
          source: "iana",
          compressible: false,
          extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
        },
        "application/oda": {
          source: "iana",
          extensions: ["oda"]
        },
        "application/odm+xml": {
          source: "iana",
          compressible: true
        },
        "application/odx": {
          source: "iana"
        },
        "application/oebps-package+xml": {
          source: "iana",
          compressible: true,
          extensions: ["opf"]
        },
        "application/ogg": {
          source: "iana",
          compressible: false,
          extensions: ["ogx"]
        },
        "application/omdoc+xml": {
          source: "apache",
          compressible: true,
          extensions: ["omdoc"]
        },
        "application/onenote": {
          source: "apache",
          extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
        },
        "application/opc-nodeset+xml": {
          source: "iana",
          compressible: true
        },
        "application/oscore": {
          source: "iana"
        },
        "application/oxps": {
          source: "iana",
          extensions: ["oxps"]
        },
        "application/p21": {
          source: "iana"
        },
        "application/p21+zip": {
          source: "iana",
          compressible: false
        },
        "application/p2p-overlay+xml": {
          source: "iana",
          compressible: true,
          extensions: ["relo"]
        },
        "application/parityfec": {
          source: "iana"
        },
        "application/passport": {
          source: "iana"
        },
        "application/patch-ops-error+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xer"]
        },
        "application/pdf": {
          source: "iana",
          compressible: false,
          extensions: ["pdf"]
        },
        "application/pdx": {
          source: "iana"
        },
        "application/pem-certificate-chain": {
          source: "iana"
        },
        "application/pgp-encrypted": {
          source: "iana",
          compressible: false,
          extensions: ["pgp"]
        },
        "application/pgp-keys": {
          source: "iana",
          extensions: ["asc"]
        },
        "application/pgp-signature": {
          source: "iana",
          extensions: ["asc", "sig"]
        },
        "application/pics-rules": {
          source: "apache",
          extensions: ["prf"]
        },
        "application/pidf+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/pidf-diff+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/pkcs10": {
          source: "iana",
          extensions: ["p10"]
        },
        "application/pkcs12": {
          source: "iana"
        },
        "application/pkcs7-mime": {
          source: "iana",
          extensions: ["p7m", "p7c"]
        },
        "application/pkcs7-signature": {
          source: "iana",
          extensions: ["p7s"]
        },
        "application/pkcs8": {
          source: "iana",
          extensions: ["p8"]
        },
        "application/pkcs8-encrypted": {
          source: "iana"
        },
        "application/pkix-attr-cert": {
          source: "iana",
          extensions: ["ac"]
        },
        "application/pkix-cert": {
          source: "iana",
          extensions: ["cer"]
        },
        "application/pkix-crl": {
          source: "iana",
          extensions: ["crl"]
        },
        "application/pkix-pkipath": {
          source: "iana",
          extensions: ["pkipath"]
        },
        "application/pkixcmp": {
          source: "iana",
          extensions: ["pki"]
        },
        "application/pls+xml": {
          source: "iana",
          compressible: true,
          extensions: ["pls"]
        },
        "application/poc-settings+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/postscript": {
          source: "iana",
          compressible: true,
          extensions: ["ai", "eps", "ps"]
        },
        "application/ppsp-tracker+json": {
          source: "iana",
          compressible: true
        },
        "application/problem+json": {
          source: "iana",
          compressible: true
        },
        "application/problem+xml": {
          source: "iana",
          compressible: true
        },
        "application/provenance+xml": {
          source: "iana",
          compressible: true,
          extensions: ["provx"]
        },
        "application/prs.alvestrand.titrax-sheet": {
          source: "iana"
        },
        "application/prs.cww": {
          source: "iana",
          extensions: ["cww"]
        },
        "application/prs.cyn": {
          source: "iana",
          charset: "7-BIT"
        },
        "application/prs.hpub+zip": {
          source: "iana",
          compressible: false
        },
        "application/prs.nprend": {
          source: "iana"
        },
        "application/prs.plucker": {
          source: "iana"
        },
        "application/prs.rdf-xml-crypt": {
          source: "iana"
        },
        "application/prs.xsf+xml": {
          source: "iana",
          compressible: true
        },
        "application/pskc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["pskcxml"]
        },
        "application/pvd+json": {
          source: "iana",
          compressible: true
        },
        "application/qsig": {
          source: "iana"
        },
        "application/raml+yaml": {
          compressible: true,
          extensions: ["raml"]
        },
        "application/raptorfec": {
          source: "iana"
        },
        "application/rdap+json": {
          source: "iana",
          compressible: true
        },
        "application/rdf+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rdf", "owl"]
        },
        "application/reginfo+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rif"]
        },
        "application/relax-ng-compact-syntax": {
          source: "iana",
          extensions: ["rnc"]
        },
        "application/remote-printing": {
          source: "iana"
        },
        "application/reputon+json": {
          source: "iana",
          compressible: true
        },
        "application/resource-lists+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rl"]
        },
        "application/resource-lists-diff+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rld"]
        },
        "application/rfc+xml": {
          source: "iana",
          compressible: true
        },
        "application/riscos": {
          source: "iana"
        },
        "application/rlmi+xml": {
          source: "iana",
          compressible: true
        },
        "application/rls-services+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rs"]
        },
        "application/route-apd+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rapd"]
        },
        "application/route-s-tsid+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sls"]
        },
        "application/route-usd+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rusd"]
        },
        "application/rpki-ghostbusters": {
          source: "iana",
          extensions: ["gbr"]
        },
        "application/rpki-manifest": {
          source: "iana",
          extensions: ["mft"]
        },
        "application/rpki-publication": {
          source: "iana"
        },
        "application/rpki-roa": {
          source: "iana",
          extensions: ["roa"]
        },
        "application/rpki-updown": {
          source: "iana"
        },
        "application/rsd+xml": {
          source: "apache",
          compressible: true,
          extensions: ["rsd"]
        },
        "application/rss+xml": {
          source: "apache",
          compressible: true,
          extensions: ["rss"]
        },
        "application/rtf": {
          source: "iana",
          compressible: true,
          extensions: ["rtf"]
        },
        "application/rtploopback": {
          source: "iana"
        },
        "application/rtx": {
          source: "iana"
        },
        "application/samlassertion+xml": {
          source: "iana",
          compressible: true
        },
        "application/samlmetadata+xml": {
          source: "iana",
          compressible: true
        },
        "application/sarif+json": {
          source: "iana",
          compressible: true
        },
        "application/sarif-external-properties+json": {
          source: "iana",
          compressible: true
        },
        "application/sbe": {
          source: "iana"
        },
        "application/sbml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sbml"]
        },
        "application/scaip+xml": {
          source: "iana",
          compressible: true
        },
        "application/scim+json": {
          source: "iana",
          compressible: true
        },
        "application/scvp-cv-request": {
          source: "iana",
          extensions: ["scq"]
        },
        "application/scvp-cv-response": {
          source: "iana",
          extensions: ["scs"]
        },
        "application/scvp-vp-request": {
          source: "iana",
          extensions: ["spq"]
        },
        "application/scvp-vp-response": {
          source: "iana",
          extensions: ["spp"]
        },
        "application/sdp": {
          source: "iana",
          extensions: ["sdp"]
        },
        "application/secevent+jwt": {
          source: "iana"
        },
        "application/senml+cbor": {
          source: "iana"
        },
        "application/senml+json": {
          source: "iana",
          compressible: true
        },
        "application/senml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["senmlx"]
        },
        "application/senml-etch+cbor": {
          source: "iana"
        },
        "application/senml-etch+json": {
          source: "iana",
          compressible: true
        },
        "application/senml-exi": {
          source: "iana"
        },
        "application/sensml+cbor": {
          source: "iana"
        },
        "application/sensml+json": {
          source: "iana",
          compressible: true
        },
        "application/sensml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sensmlx"]
        },
        "application/sensml-exi": {
          source: "iana"
        },
        "application/sep+xml": {
          source: "iana",
          compressible: true
        },
        "application/sep-exi": {
          source: "iana"
        },
        "application/session-info": {
          source: "iana"
        },
        "application/set-payment": {
          source: "iana"
        },
        "application/set-payment-initiation": {
          source: "iana",
          extensions: ["setpay"]
        },
        "application/set-registration": {
          source: "iana"
        },
        "application/set-registration-initiation": {
          source: "iana",
          extensions: ["setreg"]
        },
        "application/sgml": {
          source: "iana"
        },
        "application/sgml-open-catalog": {
          source: "iana"
        },
        "application/shf+xml": {
          source: "iana",
          compressible: true,
          extensions: ["shf"]
        },
        "application/sieve": {
          source: "iana",
          extensions: ["siv", "sieve"]
        },
        "application/simple-filter+xml": {
          source: "iana",
          compressible: true
        },
        "application/simple-message-summary": {
          source: "iana"
        },
        "application/simplesymbolcontainer": {
          source: "iana"
        },
        "application/sipc": {
          source: "iana"
        },
        "application/slate": {
          source: "iana"
        },
        "application/smil": {
          source: "iana"
        },
        "application/smil+xml": {
          source: "iana",
          compressible: true,
          extensions: ["smi", "smil"]
        },
        "application/smpte336m": {
          source: "iana"
        },
        "application/soap+fastinfoset": {
          source: "iana"
        },
        "application/soap+xml": {
          source: "iana",
          compressible: true
        },
        "application/sparql-query": {
          source: "iana",
          extensions: ["rq"]
        },
        "application/sparql-results+xml": {
          source: "iana",
          compressible: true,
          extensions: ["srx"]
        },
        "application/spdx+json": {
          source: "iana",
          compressible: true
        },
        "application/spirits-event+xml": {
          source: "iana",
          compressible: true
        },
        "application/sql": {
          source: "iana"
        },
        "application/srgs": {
          source: "iana",
          extensions: ["gram"]
        },
        "application/srgs+xml": {
          source: "iana",
          compressible: true,
          extensions: ["grxml"]
        },
        "application/sru+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sru"]
        },
        "application/ssdl+xml": {
          source: "apache",
          compressible: true,
          extensions: ["ssdl"]
        },
        "application/ssml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ssml"]
        },
        "application/stix+json": {
          source: "iana",
          compressible: true
        },
        "application/swid+xml": {
          source: "iana",
          compressible: true,
          extensions: ["swidtag"]
        },
        "application/tamp-apex-update": {
          source: "iana"
        },
        "application/tamp-apex-update-confirm": {
          source: "iana"
        },
        "application/tamp-community-update": {
          source: "iana"
        },
        "application/tamp-community-update-confirm": {
          source: "iana"
        },
        "application/tamp-error": {
          source: "iana"
        },
        "application/tamp-sequence-adjust": {
          source: "iana"
        },
        "application/tamp-sequence-adjust-confirm": {
          source: "iana"
        },
        "application/tamp-status-query": {
          source: "iana"
        },
        "application/tamp-status-response": {
          source: "iana"
        },
        "application/tamp-update": {
          source: "iana"
        },
        "application/tamp-update-confirm": {
          source: "iana"
        },
        "application/tar": {
          compressible: true
        },
        "application/taxii+json": {
          source: "iana",
          compressible: true
        },
        "application/td+json": {
          source: "iana",
          compressible: true
        },
        "application/tei+xml": {
          source: "iana",
          compressible: true,
          extensions: ["tei", "teicorpus"]
        },
        "application/tetra_isi": {
          source: "iana"
        },
        "application/thraud+xml": {
          source: "iana",
          compressible: true,
          extensions: ["tfi"]
        },
        "application/timestamp-query": {
          source: "iana"
        },
        "application/timestamp-reply": {
          source: "iana"
        },
        "application/timestamped-data": {
          source: "iana",
          extensions: ["tsd"]
        },
        "application/tlsrpt+gzip": {
          source: "iana"
        },
        "application/tlsrpt+json": {
          source: "iana",
          compressible: true
        },
        "application/tnauthlist": {
          source: "iana"
        },
        "application/token-introspection+jwt": {
          source: "iana"
        },
        "application/toml": {
          compressible: true,
          extensions: ["toml"]
        },
        "application/trickle-ice-sdpfrag": {
          source: "iana"
        },
        "application/trig": {
          source: "iana",
          extensions: ["trig"]
        },
        "application/ttml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ttml"]
        },
        "application/tve-trigger": {
          source: "iana"
        },
        "application/tzif": {
          source: "iana"
        },
        "application/tzif-leap": {
          source: "iana"
        },
        "application/ubjson": {
          compressible: false,
          extensions: ["ubj"]
        },
        "application/ulpfec": {
          source: "iana"
        },
        "application/urc-grpsheet+xml": {
          source: "iana",
          compressible: true
        },
        "application/urc-ressheet+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rsheet"]
        },
        "application/urc-targetdesc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["td"]
        },
        "application/urc-uisocketdesc+xml": {
          source: "iana",
          compressible: true
        },
        "application/vcard+json": {
          source: "iana",
          compressible: true
        },
        "application/vcard+xml": {
          source: "iana",
          compressible: true
        },
        "application/vemmi": {
          source: "iana"
        },
        "application/vividence.scriptfile": {
          source: "apache"
        },
        "application/vnd.1000minds.decision-model+xml": {
          source: "iana",
          compressible: true,
          extensions: ["1km"]
        },
        "application/vnd.3gpp-prose+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp-prose-pc3ch+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp-v2x-local-service-information": {
          source: "iana"
        },
        "application/vnd.3gpp.5gnas": {
          source: "iana"
        },
        "application/vnd.3gpp.access-transfer-events+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.bsf+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.gmop+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.gtpc": {
          source: "iana"
        },
        "application/vnd.3gpp.interworking-data": {
          source: "iana"
        },
        "application/vnd.3gpp.lpp": {
          source: "iana"
        },
        "application/vnd.3gpp.mc-signalling-ear": {
          source: "iana"
        },
        "application/vnd.3gpp.mcdata-affiliation-command+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcdata-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcdata-payload": {
          source: "iana"
        },
        "application/vnd.3gpp.mcdata-service-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcdata-signalling": {
          source: "iana"
        },
        "application/vnd.3gpp.mcdata-ue-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcdata-user-profile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-affiliation-command+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-floor-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-location-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-service-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-signed+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-ue-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-ue-init-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-user-profile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-location-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-service-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-transmission-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-ue-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-user-profile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mid-call+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.ngap": {
          source: "iana"
        },
        "application/vnd.3gpp.pfcp": {
          source: "iana"
        },
        "application/vnd.3gpp.pic-bw-large": {
          source: "iana",
          extensions: ["plb"]
        },
        "application/vnd.3gpp.pic-bw-small": {
          source: "iana",
          extensions: ["psb"]
        },
        "application/vnd.3gpp.pic-bw-var": {
          source: "iana",
          extensions: ["pvb"]
        },
        "application/vnd.3gpp.s1ap": {
          source: "iana"
        },
        "application/vnd.3gpp.sms": {
          source: "iana"
        },
        "application/vnd.3gpp.sms+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.srvcc-ext+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.srvcc-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.state-and-event-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.ussd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp2.bcmcsinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp2.sms": {
          source: "iana"
        },
        "application/vnd.3gpp2.tcap": {
          source: "iana",
          extensions: ["tcap"]
        },
        "application/vnd.3lightssoftware.imagescal": {
          source: "iana"
        },
        "application/vnd.3m.post-it-notes": {
          source: "iana",
          extensions: ["pwn"]
        },
        "application/vnd.accpac.simply.aso": {
          source: "iana",
          extensions: ["aso"]
        },
        "application/vnd.accpac.simply.imp": {
          source: "iana",
          extensions: ["imp"]
        },
        "application/vnd.acucobol": {
          source: "iana",
          extensions: ["acu"]
        },
        "application/vnd.acucorp": {
          source: "iana",
          extensions: ["atc", "acutc"]
        },
        "application/vnd.adobe.air-application-installer-package+zip": {
          source: "apache",
          compressible: false,
          extensions: ["air"]
        },
        "application/vnd.adobe.flash.movie": {
          source: "iana"
        },
        "application/vnd.adobe.formscentral.fcdt": {
          source: "iana",
          extensions: ["fcdt"]
        },
        "application/vnd.adobe.fxp": {
          source: "iana",
          extensions: ["fxp", "fxpl"]
        },
        "application/vnd.adobe.partial-upload": {
          source: "iana"
        },
        "application/vnd.adobe.xdp+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xdp"]
        },
        "application/vnd.adobe.xfdf": {
          source: "iana",
          extensions: ["xfdf"]
        },
        "application/vnd.aether.imp": {
          source: "iana"
        },
        "application/vnd.afpc.afplinedata": {
          source: "iana"
        },
        "application/vnd.afpc.afplinedata-pagedef": {
          source: "iana"
        },
        "application/vnd.afpc.cmoca-cmresource": {
          source: "iana"
        },
        "application/vnd.afpc.foca-charset": {
          source: "iana"
        },
        "application/vnd.afpc.foca-codedfont": {
          source: "iana"
        },
        "application/vnd.afpc.foca-codepage": {
          source: "iana"
        },
        "application/vnd.afpc.modca": {
          source: "iana"
        },
        "application/vnd.afpc.modca-cmtable": {
          source: "iana"
        },
        "application/vnd.afpc.modca-formdef": {
          source: "iana"
        },
        "application/vnd.afpc.modca-mediummap": {
          source: "iana"
        },
        "application/vnd.afpc.modca-objectcontainer": {
          source: "iana"
        },
        "application/vnd.afpc.modca-overlay": {
          source: "iana"
        },
        "application/vnd.afpc.modca-pagesegment": {
          source: "iana"
        },
        "application/vnd.age": {
          source: "iana",
          extensions: ["age"]
        },
        "application/vnd.ah-barcode": {
          source: "iana"
        },
        "application/vnd.ahead.space": {
          source: "iana",
          extensions: ["ahead"]
        },
        "application/vnd.airzip.filesecure.azf": {
          source: "iana",
          extensions: ["azf"]
        },
        "application/vnd.airzip.filesecure.azs": {
          source: "iana",
          extensions: ["azs"]
        },
        "application/vnd.amadeus+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.amazon.ebook": {
          source: "apache",
          extensions: ["azw"]
        },
        "application/vnd.amazon.mobi8-ebook": {
          source: "iana"
        },
        "application/vnd.americandynamics.acc": {
          source: "iana",
          extensions: ["acc"]
        },
        "application/vnd.amiga.ami": {
          source: "iana",
          extensions: ["ami"]
        },
        "application/vnd.amundsen.maze+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.android.ota": {
          source: "iana"
        },
        "application/vnd.android.package-archive": {
          source: "apache",
          compressible: false,
          extensions: ["apk"]
        },
        "application/vnd.anki": {
          source: "iana"
        },
        "application/vnd.anser-web-certificate-issue-initiation": {
          source: "iana",
          extensions: ["cii"]
        },
        "application/vnd.anser-web-funds-transfer-initiation": {
          source: "apache",
          extensions: ["fti"]
        },
        "application/vnd.antix.game-component": {
          source: "iana",
          extensions: ["atx"]
        },
        "application/vnd.apache.arrow.file": {
          source: "iana"
        },
        "application/vnd.apache.arrow.stream": {
          source: "iana"
        },
        "application/vnd.apache.thrift.binary": {
          source: "iana"
        },
        "application/vnd.apache.thrift.compact": {
          source: "iana"
        },
        "application/vnd.apache.thrift.json": {
          source: "iana"
        },
        "application/vnd.api+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.aplextor.warrp+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.apothekende.reservation+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.apple.installer+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mpkg"]
        },
        "application/vnd.apple.keynote": {
          source: "iana",
          extensions: ["key"]
        },
        "application/vnd.apple.mpegurl": {
          source: "iana",
          extensions: ["m3u8"]
        },
        "application/vnd.apple.numbers": {
          source: "iana",
          extensions: ["numbers"]
        },
        "application/vnd.apple.pages": {
          source: "iana",
          extensions: ["pages"]
        },
        "application/vnd.apple.pkpass": {
          compressible: false,
          extensions: ["pkpass"]
        },
        "application/vnd.arastra.swi": {
          source: "iana"
        },
        "application/vnd.aristanetworks.swi": {
          source: "iana",
          extensions: ["swi"]
        },
        "application/vnd.artisan+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.artsquare": {
          source: "iana"
        },
        "application/vnd.astraea-software.iota": {
          source: "iana",
          extensions: ["iota"]
        },
        "application/vnd.audiograph": {
          source: "iana",
          extensions: ["aep"]
        },
        "application/vnd.autopackage": {
          source: "iana"
        },
        "application/vnd.avalon+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.avistar+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.balsamiq.bmml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["bmml"]
        },
        "application/vnd.balsamiq.bmpr": {
          source: "iana"
        },
        "application/vnd.banana-accounting": {
          source: "iana"
        },
        "application/vnd.bbf.usp.error": {
          source: "iana"
        },
        "application/vnd.bbf.usp.msg": {
          source: "iana"
        },
        "application/vnd.bbf.usp.msg+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.bekitzur-stech+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.bint.med-content": {
          source: "iana"
        },
        "application/vnd.biopax.rdf+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.blink-idb-value-wrapper": {
          source: "iana"
        },
        "application/vnd.blueice.multipass": {
          source: "iana",
          extensions: ["mpm"]
        },
        "application/vnd.bluetooth.ep.oob": {
          source: "iana"
        },
        "application/vnd.bluetooth.le.oob": {
          source: "iana"
        },
        "application/vnd.bmi": {
          source: "iana",
          extensions: ["bmi"]
        },
        "application/vnd.bpf": {
          source: "iana"
        },
        "application/vnd.bpf3": {
          source: "iana"
        },
        "application/vnd.businessobjects": {
          source: "iana",
          extensions: ["rep"]
        },
        "application/vnd.byu.uapi+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cab-jscript": {
          source: "iana"
        },
        "application/vnd.canon-cpdl": {
          source: "iana"
        },
        "application/vnd.canon-lips": {
          source: "iana"
        },
        "application/vnd.capasystems-pg+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cendio.thinlinc.clientconf": {
          source: "iana"
        },
        "application/vnd.century-systems.tcp_stream": {
          source: "iana"
        },
        "application/vnd.chemdraw+xml": {
          source: "iana",
          compressible: true,
          extensions: ["cdxml"]
        },
        "application/vnd.chess-pgn": {
          source: "iana"
        },
        "application/vnd.chipnuts.karaoke-mmd": {
          source: "iana",
          extensions: ["mmd"]
        },
        "application/vnd.ciedi": {
          source: "iana"
        },
        "application/vnd.cinderella": {
          source: "iana",
          extensions: ["cdy"]
        },
        "application/vnd.cirpack.isdn-ext": {
          source: "iana"
        },
        "application/vnd.citationstyles.style+xml": {
          source: "iana",
          compressible: true,
          extensions: ["csl"]
        },
        "application/vnd.claymore": {
          source: "iana",
          extensions: ["cla"]
        },
        "application/vnd.cloanto.rp9": {
          source: "iana",
          extensions: ["rp9"]
        },
        "application/vnd.clonk.c4group": {
          source: "iana",
          extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
        },
        "application/vnd.cluetrust.cartomobile-config": {
          source: "iana",
          extensions: ["c11amc"]
        },
        "application/vnd.cluetrust.cartomobile-config-pkg": {
          source: "iana",
          extensions: ["c11amz"]
        },
        "application/vnd.coffeescript": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.document": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.document-template": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.presentation": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.presentation-template": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.spreadsheet": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.spreadsheet-template": {
          source: "iana"
        },
        "application/vnd.collection+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.collection.doc+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.collection.next+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.comicbook+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.comicbook-rar": {
          source: "iana"
        },
        "application/vnd.commerce-battelle": {
          source: "iana"
        },
        "application/vnd.commonspace": {
          source: "iana",
          extensions: ["csp"]
        },
        "application/vnd.contact.cmsg": {
          source: "iana",
          extensions: ["cdbcmsg"]
        },
        "application/vnd.coreos.ignition+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cosmocaller": {
          source: "iana",
          extensions: ["cmc"]
        },
        "application/vnd.crick.clicker": {
          source: "iana",
          extensions: ["clkx"]
        },
        "application/vnd.crick.clicker.keyboard": {
          source: "iana",
          extensions: ["clkk"]
        },
        "application/vnd.crick.clicker.palette": {
          source: "iana",
          extensions: ["clkp"]
        },
        "application/vnd.crick.clicker.template": {
          source: "iana",
          extensions: ["clkt"]
        },
        "application/vnd.crick.clicker.wordbank": {
          source: "iana",
          extensions: ["clkw"]
        },
        "application/vnd.criticaltools.wbs+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wbs"]
        },
        "application/vnd.cryptii.pipe+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.crypto-shade-file": {
          source: "iana"
        },
        "application/vnd.cryptomator.encrypted": {
          source: "iana"
        },
        "application/vnd.cryptomator.vault": {
          source: "iana"
        },
        "application/vnd.ctc-posml": {
          source: "iana",
          extensions: ["pml"]
        },
        "application/vnd.ctct.ws+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cups-pdf": {
          source: "iana"
        },
        "application/vnd.cups-postscript": {
          source: "iana"
        },
        "application/vnd.cups-ppd": {
          source: "iana",
          extensions: ["ppd"]
        },
        "application/vnd.cups-raster": {
          source: "iana"
        },
        "application/vnd.cups-raw": {
          source: "iana"
        },
        "application/vnd.curl": {
          source: "iana"
        },
        "application/vnd.curl.car": {
          source: "apache",
          extensions: ["car"]
        },
        "application/vnd.curl.pcurl": {
          source: "apache",
          extensions: ["pcurl"]
        },
        "application/vnd.cyan.dean.root+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cybank": {
          source: "iana"
        },
        "application/vnd.cyclonedx+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cyclonedx+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.d2l.coursepackage1p0+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.d3m-dataset": {
          source: "iana"
        },
        "application/vnd.d3m-problem": {
          source: "iana"
        },
        "application/vnd.dart": {
          source: "iana",
          compressible: true,
          extensions: ["dart"]
        },
        "application/vnd.data-vision.rdz": {
          source: "iana",
          extensions: ["rdz"]
        },
        "application/vnd.datapackage+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dataresource+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dbf": {
          source: "iana",
          extensions: ["dbf"]
        },
        "application/vnd.debian.binary-package": {
          source: "iana"
        },
        "application/vnd.dece.data": {
          source: "iana",
          extensions: ["uvf", "uvvf", "uvd", "uvvd"]
        },
        "application/vnd.dece.ttml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["uvt", "uvvt"]
        },
        "application/vnd.dece.unspecified": {
          source: "iana",
          extensions: ["uvx", "uvvx"]
        },
        "application/vnd.dece.zip": {
          source: "iana",
          extensions: ["uvz", "uvvz"]
        },
        "application/vnd.denovo.fcselayout-link": {
          source: "iana",
          extensions: ["fe_launch"]
        },
        "application/vnd.desmume.movie": {
          source: "iana"
        },
        "application/vnd.dir-bi.plate-dl-nosuffix": {
          source: "iana"
        },
        "application/vnd.dm.delegation+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dna": {
          source: "iana",
          extensions: ["dna"]
        },
        "application/vnd.document+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dolby.mlp": {
          source: "apache",
          extensions: ["mlp"]
        },
        "application/vnd.dolby.mobile.1": {
          source: "iana"
        },
        "application/vnd.dolby.mobile.2": {
          source: "iana"
        },
        "application/vnd.doremir.scorecloud-binary-document": {
          source: "iana"
        },
        "application/vnd.dpgraph": {
          source: "iana",
          extensions: ["dpg"]
        },
        "application/vnd.dreamfactory": {
          source: "iana",
          extensions: ["dfac"]
        },
        "application/vnd.drive+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ds-keypoint": {
          source: "apache",
          extensions: ["kpxx"]
        },
        "application/vnd.dtg.local": {
          source: "iana"
        },
        "application/vnd.dtg.local.flash": {
          source: "iana"
        },
        "application/vnd.dtg.local.html": {
          source: "iana"
        },
        "application/vnd.dvb.ait": {
          source: "iana",
          extensions: ["ait"]
        },
        "application/vnd.dvb.dvbisl+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.dvbj": {
          source: "iana"
        },
        "application/vnd.dvb.esgcontainer": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcdftnotifaccess": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcesgaccess": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcesgaccess2": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcesgpdd": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcroaming": {
          source: "iana"
        },
        "application/vnd.dvb.iptv.alfec-base": {
          source: "iana"
        },
        "application/vnd.dvb.iptv.alfec-enhancement": {
          source: "iana"
        },
        "application/vnd.dvb.notif-aggregate-root+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-container+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-generic+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-ia-msglist+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-ia-registration-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-ia-registration-response+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-init+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.pfr": {
          source: "iana"
        },
        "application/vnd.dvb.service": {
          source: "iana",
          extensions: ["svc"]
        },
        "application/vnd.dxr": {
          source: "iana"
        },
        "application/vnd.dynageo": {
          source: "iana",
          extensions: ["geo"]
        },
        "application/vnd.dzr": {
          source: "iana"
        },
        "application/vnd.easykaraoke.cdgdownload": {
          source: "iana"
        },
        "application/vnd.ecdis-update": {
          source: "iana"
        },
        "application/vnd.ecip.rlp": {
          source: "iana"
        },
        "application/vnd.eclipse.ditto+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ecowin.chart": {
          source: "iana",
          extensions: ["mag"]
        },
        "application/vnd.ecowin.filerequest": {
          source: "iana"
        },
        "application/vnd.ecowin.fileupdate": {
          source: "iana"
        },
        "application/vnd.ecowin.series": {
          source: "iana"
        },
        "application/vnd.ecowin.seriesrequest": {
          source: "iana"
        },
        "application/vnd.ecowin.seriesupdate": {
          source: "iana"
        },
        "application/vnd.efi.img": {
          source: "iana"
        },
        "application/vnd.efi.iso": {
          source: "iana"
        },
        "application/vnd.emclient.accessrequest+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.enliven": {
          source: "iana",
          extensions: ["nml"]
        },
        "application/vnd.enphase.envoy": {
          source: "iana"
        },
        "application/vnd.eprints.data+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.epson.esf": {
          source: "iana",
          extensions: ["esf"]
        },
        "application/vnd.epson.msf": {
          source: "iana",
          extensions: ["msf"]
        },
        "application/vnd.epson.quickanime": {
          source: "iana",
          extensions: ["qam"]
        },
        "application/vnd.epson.salt": {
          source: "iana",
          extensions: ["slt"]
        },
        "application/vnd.epson.ssf": {
          source: "iana",
          extensions: ["ssf"]
        },
        "application/vnd.ericsson.quickcall": {
          source: "iana"
        },
        "application/vnd.espass-espass+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.eszigno3+xml": {
          source: "iana",
          compressible: true,
          extensions: ["es3", "et3"]
        },
        "application/vnd.etsi.aoc+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.asic-e+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.etsi.asic-s+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.etsi.cug+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvcommand+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvdiscovery+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvprofile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvsad-bc+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvsad-cod+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvsad-npvr+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvservice+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvsync+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvueprofile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.mcid+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.mheg5": {
          source: "iana"
        },
        "application/vnd.etsi.overload-control-policy-dataset+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.pstn+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.sci+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.simservs+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.timestamp-token": {
          source: "iana"
        },
        "application/vnd.etsi.tsl+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.tsl.der": {
          source: "iana"
        },
        "application/vnd.eu.kasparian.car+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.eudora.data": {
          source: "iana"
        },
        "application/vnd.evolv.ecig.profile": {
          source: "iana"
        },
        "application/vnd.evolv.ecig.settings": {
          source: "iana"
        },
        "application/vnd.evolv.ecig.theme": {
          source: "iana"
        },
        "application/vnd.exstream-empower+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.exstream-package": {
          source: "iana"
        },
        "application/vnd.ezpix-album": {
          source: "iana",
          extensions: ["ez2"]
        },
        "application/vnd.ezpix-package": {
          source: "iana",
          extensions: ["ez3"]
        },
        "application/vnd.f-secure.mobile": {
          source: "iana"
        },
        "application/vnd.familysearch.gedcom+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.fastcopy-disk-image": {
          source: "iana"
        },
        "application/vnd.fdf": {
          source: "iana",
          extensions: ["fdf"]
        },
        "application/vnd.fdsn.mseed": {
          source: "iana",
          extensions: ["mseed"]
        },
        "application/vnd.fdsn.seed": {
          source: "iana",
          extensions: ["seed", "dataless"]
        },
        "application/vnd.ffsns": {
          source: "iana"
        },
        "application/vnd.ficlab.flb+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.filmit.zfc": {
          source: "iana"
        },
        "application/vnd.fints": {
          source: "iana"
        },
        "application/vnd.firemonkeys.cloudcell": {
          source: "iana"
        },
        "application/vnd.flographit": {
          source: "iana",
          extensions: ["gph"]
        },
        "application/vnd.fluxtime.clip": {
          source: "iana",
          extensions: ["ftc"]
        },
        "application/vnd.font-fontforge-sfd": {
          source: "iana"
        },
        "application/vnd.framemaker": {
          source: "iana",
          extensions: ["fm", "frame", "maker", "book"]
        },
        "application/vnd.frogans.fnc": {
          source: "iana",
          extensions: ["fnc"]
        },
        "application/vnd.frogans.ltf": {
          source: "iana",
          extensions: ["ltf"]
        },
        "application/vnd.fsc.weblaunch": {
          source: "iana",
          extensions: ["fsc"]
        },
        "application/vnd.fujifilm.fb.docuworks": {
          source: "iana"
        },
        "application/vnd.fujifilm.fb.docuworks.binder": {
          source: "iana"
        },
        "application/vnd.fujifilm.fb.docuworks.container": {
          source: "iana"
        },
        "application/vnd.fujifilm.fb.jfi+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.fujitsu.oasys": {
          source: "iana",
          extensions: ["oas"]
        },
        "application/vnd.fujitsu.oasys2": {
          source: "iana",
          extensions: ["oa2"]
        },
        "application/vnd.fujitsu.oasys3": {
          source: "iana",
          extensions: ["oa3"]
        },
        "application/vnd.fujitsu.oasysgp": {
          source: "iana",
          extensions: ["fg5"]
        },
        "application/vnd.fujitsu.oasysprs": {
          source: "iana",
          extensions: ["bh2"]
        },
        "application/vnd.fujixerox.art-ex": {
          source: "iana"
        },
        "application/vnd.fujixerox.art4": {
          source: "iana"
        },
        "application/vnd.fujixerox.ddd": {
          source: "iana",
          extensions: ["ddd"]
        },
        "application/vnd.fujixerox.docuworks": {
          source: "iana",
          extensions: ["xdw"]
        },
        "application/vnd.fujixerox.docuworks.binder": {
          source: "iana",
          extensions: ["xbd"]
        },
        "application/vnd.fujixerox.docuworks.container": {
          source: "iana"
        },
        "application/vnd.fujixerox.hbpl": {
          source: "iana"
        },
        "application/vnd.fut-misnet": {
          source: "iana"
        },
        "application/vnd.futoin+cbor": {
          source: "iana"
        },
        "application/vnd.futoin+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.fuzzysheet": {
          source: "iana",
          extensions: ["fzs"]
        },
        "application/vnd.genomatix.tuxedo": {
          source: "iana",
          extensions: ["txd"]
        },
        "application/vnd.gentics.grd+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.geo+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.geocube+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.geogebra.file": {
          source: "iana",
          extensions: ["ggb"]
        },
        "application/vnd.geogebra.slides": {
          source: "iana"
        },
        "application/vnd.geogebra.tool": {
          source: "iana",
          extensions: ["ggt"]
        },
        "application/vnd.geometry-explorer": {
          source: "iana",
          extensions: ["gex", "gre"]
        },
        "application/vnd.geonext": {
          source: "iana",
          extensions: ["gxt"]
        },
        "application/vnd.geoplan": {
          source: "iana",
          extensions: ["g2w"]
        },
        "application/vnd.geospace": {
          source: "iana",
          extensions: ["g3w"]
        },
        "application/vnd.gerber": {
          source: "iana"
        },
        "application/vnd.globalplatform.card-content-mgt": {
          source: "iana"
        },
        "application/vnd.globalplatform.card-content-mgt-response": {
          source: "iana"
        },
        "application/vnd.gmx": {
          source: "iana",
          extensions: ["gmx"]
        },
        "application/vnd.google-apps.document": {
          compressible: false,
          extensions: ["gdoc"]
        },
        "application/vnd.google-apps.presentation": {
          compressible: false,
          extensions: ["gslides"]
        },
        "application/vnd.google-apps.spreadsheet": {
          compressible: false,
          extensions: ["gsheet"]
        },
        "application/vnd.google-earth.kml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["kml"]
        },
        "application/vnd.google-earth.kmz": {
          source: "iana",
          compressible: false,
          extensions: ["kmz"]
        },
        "application/vnd.gov.sk.e-form+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.gov.sk.e-form+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.gov.sk.xmldatacontainer+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.grafeq": {
          source: "iana",
          extensions: ["gqf", "gqs"]
        },
        "application/vnd.gridmp": {
          source: "iana"
        },
        "application/vnd.groove-account": {
          source: "iana",
          extensions: ["gac"]
        },
        "application/vnd.groove-help": {
          source: "iana",
          extensions: ["ghf"]
        },
        "application/vnd.groove-identity-message": {
          source: "iana",
          extensions: ["gim"]
        },
        "application/vnd.groove-injector": {
          source: "iana",
          extensions: ["grv"]
        },
        "application/vnd.groove-tool-message": {
          source: "iana",
          extensions: ["gtm"]
        },
        "application/vnd.groove-tool-template": {
          source: "iana",
          extensions: ["tpl"]
        },
        "application/vnd.groove-vcard": {
          source: "iana",
          extensions: ["vcg"]
        },
        "application/vnd.hal+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hal+xml": {
          source: "iana",
          compressible: true,
          extensions: ["hal"]
        },
        "application/vnd.handheld-entertainment+xml": {
          source: "iana",
          compressible: true,
          extensions: ["zmm"]
        },
        "application/vnd.hbci": {
          source: "iana",
          extensions: ["hbci"]
        },
        "application/vnd.hc+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hcl-bireports": {
          source: "iana"
        },
        "application/vnd.hdt": {
          source: "iana"
        },
        "application/vnd.heroku+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hhe.lesson-player": {
          source: "iana",
          extensions: ["les"]
        },
        "application/vnd.hl7cda+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.hl7v2+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.hp-hpgl": {
          source: "iana",
          extensions: ["hpgl"]
        },
        "application/vnd.hp-hpid": {
          source: "iana",
          extensions: ["hpid"]
        },
        "application/vnd.hp-hps": {
          source: "iana",
          extensions: ["hps"]
        },
        "application/vnd.hp-jlyt": {
          source: "iana",
          extensions: ["jlt"]
        },
        "application/vnd.hp-pcl": {
          source: "iana",
          extensions: ["pcl"]
        },
        "application/vnd.hp-pclxl": {
          source: "iana",
          extensions: ["pclxl"]
        },
        "application/vnd.httphone": {
          source: "iana"
        },
        "application/vnd.hydrostatix.sof-data": {
          source: "iana",
          extensions: ["sfd-hdstx"]
        },
        "application/vnd.hyper+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hyper-item+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hyperdrive+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hzn-3d-crossword": {
          source: "iana"
        },
        "application/vnd.ibm.afplinedata": {
          source: "iana"
        },
        "application/vnd.ibm.electronic-media": {
          source: "iana"
        },
        "application/vnd.ibm.minipay": {
          source: "iana",
          extensions: ["mpy"]
        },
        "application/vnd.ibm.modcap": {
          source: "iana",
          extensions: ["afp", "listafp", "list3820"]
        },
        "application/vnd.ibm.rights-management": {
          source: "iana",
          extensions: ["irm"]
        },
        "application/vnd.ibm.secure-container": {
          source: "iana",
          extensions: ["sc"]
        },
        "application/vnd.iccprofile": {
          source: "iana",
          extensions: ["icc", "icm"]
        },
        "application/vnd.ieee.1905": {
          source: "iana"
        },
        "application/vnd.igloader": {
          source: "iana",
          extensions: ["igl"]
        },
        "application/vnd.imagemeter.folder+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.imagemeter.image+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.immervision-ivp": {
          source: "iana",
          extensions: ["ivp"]
        },
        "application/vnd.immervision-ivu": {
          source: "iana",
          extensions: ["ivu"]
        },
        "application/vnd.ims.imsccv1p1": {
          source: "iana"
        },
        "application/vnd.ims.imsccv1p2": {
          source: "iana"
        },
        "application/vnd.ims.imsccv1p3": {
          source: "iana"
        },
        "application/vnd.ims.lis.v2.result+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolproxy+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolproxy.id+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolsettings+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolsettings.simple+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.informedcontrol.rms+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.informix-visionary": {
          source: "iana"
        },
        "application/vnd.infotech.project": {
          source: "iana"
        },
        "application/vnd.infotech.project+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.innopath.wamp.notification": {
          source: "iana"
        },
        "application/vnd.insors.igm": {
          source: "iana",
          extensions: ["igm"]
        },
        "application/vnd.intercon.formnet": {
          source: "iana",
          extensions: ["xpw", "xpx"]
        },
        "application/vnd.intergeo": {
          source: "iana",
          extensions: ["i2g"]
        },
        "application/vnd.intertrust.digibox": {
          source: "iana"
        },
        "application/vnd.intertrust.nncp": {
          source: "iana"
        },
        "application/vnd.intu.qbo": {
          source: "iana",
          extensions: ["qbo"]
        },
        "application/vnd.intu.qfx": {
          source: "iana",
          extensions: ["qfx"]
        },
        "application/vnd.iptc.g2.catalogitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.conceptitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.knowledgeitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.newsitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.newsmessage+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.packageitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.planningitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ipunplugged.rcprofile": {
          source: "iana",
          extensions: ["rcprofile"]
        },
        "application/vnd.irepository.package+xml": {
          source: "iana",
          compressible: true,
          extensions: ["irp"]
        },
        "application/vnd.is-xpr": {
          source: "iana",
          extensions: ["xpr"]
        },
        "application/vnd.isac.fcs": {
          source: "iana",
          extensions: ["fcs"]
        },
        "application/vnd.iso11783-10+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.jam": {
          source: "iana",
          extensions: ["jam"]
        },
        "application/vnd.japannet-directory-service": {
          source: "iana"
        },
        "application/vnd.japannet-jpnstore-wakeup": {
          source: "iana"
        },
        "application/vnd.japannet-payment-wakeup": {
          source: "iana"
        },
        "application/vnd.japannet-registration": {
          source: "iana"
        },
        "application/vnd.japannet-registration-wakeup": {
          source: "iana"
        },
        "application/vnd.japannet-setstore-wakeup": {
          source: "iana"
        },
        "application/vnd.japannet-verification": {
          source: "iana"
        },
        "application/vnd.japannet-verification-wakeup": {
          source: "iana"
        },
        "application/vnd.jcp.javame.midlet-rms": {
          source: "iana",
          extensions: ["rms"]
        },
        "application/vnd.jisp": {
          source: "iana",
          extensions: ["jisp"]
        },
        "application/vnd.joost.joda-archive": {
          source: "iana",
          extensions: ["joda"]
        },
        "application/vnd.jsk.isdn-ngn": {
          source: "iana"
        },
        "application/vnd.kahootz": {
          source: "iana",
          extensions: ["ktz", "ktr"]
        },
        "application/vnd.kde.karbon": {
          source: "iana",
          extensions: ["karbon"]
        },
        "application/vnd.kde.kchart": {
          source: "iana",
          extensions: ["chrt"]
        },
        "application/vnd.kde.kformula": {
          source: "iana",
          extensions: ["kfo"]
        },
        "application/vnd.kde.kivio": {
          source: "iana",
          extensions: ["flw"]
        },
        "application/vnd.kde.kontour": {
          source: "iana",
          extensions: ["kon"]
        },
        "application/vnd.kde.kpresenter": {
          source: "iana",
          extensions: ["kpr", "kpt"]
        },
        "application/vnd.kde.kspread": {
          source: "iana",
          extensions: ["ksp"]
        },
        "application/vnd.kde.kword": {
          source: "iana",
          extensions: ["kwd", "kwt"]
        },
        "application/vnd.kenameaapp": {
          source: "iana",
          extensions: ["htke"]
        },
        "application/vnd.kidspiration": {
          source: "iana",
          extensions: ["kia"]
        },
        "application/vnd.kinar": {
          source: "iana",
          extensions: ["kne", "knp"]
        },
        "application/vnd.koan": {
          source: "iana",
          extensions: ["skp", "skd", "skt", "skm"]
        },
        "application/vnd.kodak-descriptor": {
          source: "iana",
          extensions: ["sse"]
        },
        "application/vnd.las": {
          source: "iana"
        },
        "application/vnd.las.las+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.las.las+xml": {
          source: "iana",
          compressible: true,
          extensions: ["lasxml"]
        },
        "application/vnd.laszip": {
          source: "iana"
        },
        "application/vnd.leap+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.liberty-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.llamagraphics.life-balance.desktop": {
          source: "iana",
          extensions: ["lbd"]
        },
        "application/vnd.llamagraphics.life-balance.exchange+xml": {
          source: "iana",
          compressible: true,
          extensions: ["lbe"]
        },
        "application/vnd.logipipe.circuit+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.loom": {
          source: "iana"
        },
        "application/vnd.lotus-1-2-3": {
          source: "iana",
          extensions: ["123"]
        },
        "application/vnd.lotus-approach": {
          source: "iana",
          extensions: ["apr"]
        },
        "application/vnd.lotus-freelance": {
          source: "iana",
          extensions: ["pre"]
        },
        "application/vnd.lotus-notes": {
          source: "iana",
          extensions: ["nsf"]
        },
        "application/vnd.lotus-organizer": {
          source: "iana",
          extensions: ["org"]
        },
        "application/vnd.lotus-screencam": {
          source: "iana",
          extensions: ["scm"]
        },
        "application/vnd.lotus-wordpro": {
          source: "iana",
          extensions: ["lwp"]
        },
        "application/vnd.macports.portpkg": {
          source: "iana",
          extensions: ["portpkg"]
        },
        "application/vnd.mapbox-vector-tile": {
          source: "iana",
          extensions: ["mvt"]
        },
        "application/vnd.marlin.drm.actiontoken+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.marlin.drm.conftoken+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.marlin.drm.license+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.marlin.drm.mdcf": {
          source: "iana"
        },
        "application/vnd.mason+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.maxar.archive.3tz+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.maxmind.maxmind-db": {
          source: "iana"
        },
        "application/vnd.mcd": {
          source: "iana",
          extensions: ["mcd"]
        },
        "application/vnd.medcalcdata": {
          source: "iana",
          extensions: ["mc1"]
        },
        "application/vnd.mediastation.cdkey": {
          source: "iana",
          extensions: ["cdkey"]
        },
        "application/vnd.meridian-slingshot": {
          source: "iana"
        },
        "application/vnd.mfer": {
          source: "iana",
          extensions: ["mwf"]
        },
        "application/vnd.mfmp": {
          source: "iana",
          extensions: ["mfm"]
        },
        "application/vnd.micro+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.micrografx.flo": {
          source: "iana",
          extensions: ["flo"]
        },
        "application/vnd.micrografx.igx": {
          source: "iana",
          extensions: ["igx"]
        },
        "application/vnd.microsoft.portable-executable": {
          source: "iana"
        },
        "application/vnd.microsoft.windows.thumbnail-cache": {
          source: "iana"
        },
        "application/vnd.miele+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.mif": {
          source: "iana",
          extensions: ["mif"]
        },
        "application/vnd.minisoft-hp3000-save": {
          source: "iana"
        },
        "application/vnd.mitsubishi.misty-guard.trustweb": {
          source: "iana"
        },
        "application/vnd.mobius.daf": {
          source: "iana",
          extensions: ["daf"]
        },
        "application/vnd.mobius.dis": {
          source: "iana",
          extensions: ["dis"]
        },
        "application/vnd.mobius.mbk": {
          source: "iana",
          extensions: ["mbk"]
        },
        "application/vnd.mobius.mqy": {
          source: "iana",
          extensions: ["mqy"]
        },
        "application/vnd.mobius.msl": {
          source: "iana",
          extensions: ["msl"]
        },
        "application/vnd.mobius.plc": {
          source: "iana",
          extensions: ["plc"]
        },
        "application/vnd.mobius.txf": {
          source: "iana",
          extensions: ["txf"]
        },
        "application/vnd.mophun.application": {
          source: "iana",
          extensions: ["mpn"]
        },
        "application/vnd.mophun.certificate": {
          source: "iana",
          extensions: ["mpc"]
        },
        "application/vnd.motorola.flexsuite": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.adsi": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.fis": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.gotap": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.kmr": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.ttc": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.wem": {
          source: "iana"
        },
        "application/vnd.motorola.iprm": {
          source: "iana"
        },
        "application/vnd.mozilla.xul+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xul"]
        },
        "application/vnd.ms-3mfdocument": {
          source: "iana"
        },
        "application/vnd.ms-artgalry": {
          source: "iana",
          extensions: ["cil"]
        },
        "application/vnd.ms-asf": {
          source: "iana"
        },
        "application/vnd.ms-cab-compressed": {
          source: "iana",
          extensions: ["cab"]
        },
        "application/vnd.ms-color.iccprofile": {
          source: "apache"
        },
        "application/vnd.ms-excel": {
          source: "iana",
          compressible: false,
          extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
        },
        "application/vnd.ms-excel.addin.macroenabled.12": {
          source: "iana",
          extensions: ["xlam"]
        },
        "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
          source: "iana",
          extensions: ["xlsb"]
        },
        "application/vnd.ms-excel.sheet.macroenabled.12": {
          source: "iana",
          extensions: ["xlsm"]
        },
        "application/vnd.ms-excel.template.macroenabled.12": {
          source: "iana",
          extensions: ["xltm"]
        },
        "application/vnd.ms-fontobject": {
          source: "iana",
          compressible: true,
          extensions: ["eot"]
        },
        "application/vnd.ms-htmlhelp": {
          source: "iana",
          extensions: ["chm"]
        },
        "application/vnd.ms-ims": {
          source: "iana",
          extensions: ["ims"]
        },
        "application/vnd.ms-lrm": {
          source: "iana",
          extensions: ["lrm"]
        },
        "application/vnd.ms-office.activex+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ms-officetheme": {
          source: "iana",
          extensions: ["thmx"]
        },
        "application/vnd.ms-opentype": {
          source: "apache",
          compressible: true
        },
        "application/vnd.ms-outlook": {
          compressible: false,
          extensions: ["msg"]
        },
        "application/vnd.ms-package.obfuscated-opentype": {
          source: "apache"
        },
        "application/vnd.ms-pki.seccat": {
          source: "apache",
          extensions: ["cat"]
        },
        "application/vnd.ms-pki.stl": {
          source: "apache",
          extensions: ["stl"]
        },
        "application/vnd.ms-playready.initiator+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ms-powerpoint": {
          source: "iana",
          compressible: false,
          extensions: ["ppt", "pps", "pot"]
        },
        "application/vnd.ms-powerpoint.addin.macroenabled.12": {
          source: "iana",
          extensions: ["ppam"]
        },
        "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
          source: "iana",
          extensions: ["pptm"]
        },
        "application/vnd.ms-powerpoint.slide.macroenabled.12": {
          source: "iana",
          extensions: ["sldm"]
        },
        "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
          source: "iana",
          extensions: ["ppsm"]
        },
        "application/vnd.ms-powerpoint.template.macroenabled.12": {
          source: "iana",
          extensions: ["potm"]
        },
        "application/vnd.ms-printdevicecapabilities+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ms-printing.printticket+xml": {
          source: "apache",
          compressible: true
        },
        "application/vnd.ms-printschematicket+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ms-project": {
          source: "iana",
          extensions: ["mpp", "mpt"]
        },
        "application/vnd.ms-tnef": {
          source: "iana"
        },
        "application/vnd.ms-windows.devicepairing": {
          source: "iana"
        },
        "application/vnd.ms-windows.nwprinting.oob": {
          source: "iana"
        },
        "application/vnd.ms-windows.printerpairing": {
          source: "iana"
        },
        "application/vnd.ms-windows.wsd.oob": {
          source: "iana"
        },
        "application/vnd.ms-wmdrm.lic-chlg-req": {
          source: "iana"
        },
        "application/vnd.ms-wmdrm.lic-resp": {
          source: "iana"
        },
        "application/vnd.ms-wmdrm.meter-chlg-req": {
          source: "iana"
        },
        "application/vnd.ms-wmdrm.meter-resp": {
          source: "iana"
        },
        "application/vnd.ms-word.document.macroenabled.12": {
          source: "iana",
          extensions: ["docm"]
        },
        "application/vnd.ms-word.template.macroenabled.12": {
          source: "iana",
          extensions: ["dotm"]
        },
        "application/vnd.ms-works": {
          source: "iana",
          extensions: ["wps", "wks", "wcm", "wdb"]
        },
        "application/vnd.ms-wpl": {
          source: "iana",
          extensions: ["wpl"]
        },
        "application/vnd.ms-xpsdocument": {
          source: "iana",
          compressible: false,
          extensions: ["xps"]
        },
        "application/vnd.msa-disk-image": {
          source: "iana"
        },
        "application/vnd.mseq": {
          source: "iana",
          extensions: ["mseq"]
        },
        "application/vnd.msign": {
          source: "iana"
        },
        "application/vnd.multiad.creator": {
          source: "iana"
        },
        "application/vnd.multiad.creator.cif": {
          source: "iana"
        },
        "application/vnd.music-niff": {
          source: "iana"
        },
        "application/vnd.musician": {
          source: "iana",
          extensions: ["mus"]
        },
        "application/vnd.muvee.style": {
          source: "iana",
          extensions: ["msty"]
        },
        "application/vnd.mynfc": {
          source: "iana",
          extensions: ["taglet"]
        },
        "application/vnd.nacamar.ybrid+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ncd.control": {
          source: "iana"
        },
        "application/vnd.ncd.reference": {
          source: "iana"
        },
        "application/vnd.nearst.inv+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nebumind.line": {
          source: "iana"
        },
        "application/vnd.nervana": {
          source: "iana"
        },
        "application/vnd.netfpx": {
          source: "iana"
        },
        "application/vnd.neurolanguage.nlu": {
          source: "iana",
          extensions: ["nlu"]
        },
        "application/vnd.nimn": {
          source: "iana"
        },
        "application/vnd.nintendo.nitro.rom": {
          source: "iana"
        },
        "application/vnd.nintendo.snes.rom": {
          source: "iana"
        },
        "application/vnd.nitf": {
          source: "iana",
          extensions: ["ntf", "nitf"]
        },
        "application/vnd.noblenet-directory": {
          source: "iana",
          extensions: ["nnd"]
        },
        "application/vnd.noblenet-sealer": {
          source: "iana",
          extensions: ["nns"]
        },
        "application/vnd.noblenet-web": {
          source: "iana",
          extensions: ["nnw"]
        },
        "application/vnd.nokia.catalogs": {
          source: "iana"
        },
        "application/vnd.nokia.conml+wbxml": {
          source: "iana"
        },
        "application/vnd.nokia.conml+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.iptv.config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.isds-radio-presets": {
          source: "iana"
        },
        "application/vnd.nokia.landmark+wbxml": {
          source: "iana"
        },
        "application/vnd.nokia.landmark+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.landmarkcollection+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.n-gage.ac+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ac"]
        },
        "application/vnd.nokia.n-gage.data": {
          source: "iana",
          extensions: ["ngdat"]
        },
        "application/vnd.nokia.n-gage.symbian.install": {
          source: "iana",
          extensions: ["n-gage"]
        },
        "application/vnd.nokia.ncd": {
          source: "iana"
        },
        "application/vnd.nokia.pcd+wbxml": {
          source: "iana"
        },
        "application/vnd.nokia.pcd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.radio-preset": {
          source: "iana",
          extensions: ["rpst"]
        },
        "application/vnd.nokia.radio-presets": {
          source: "iana",
          extensions: ["rpss"]
        },
        "application/vnd.novadigm.edm": {
          source: "iana",
          extensions: ["edm"]
        },
        "application/vnd.novadigm.edx": {
          source: "iana",
          extensions: ["edx"]
        },
        "application/vnd.novadigm.ext": {
          source: "iana",
          extensions: ["ext"]
        },
        "application/vnd.ntt-local.content-share": {
          source: "iana"
        },
        "application/vnd.ntt-local.file-transfer": {
          source: "iana"
        },
        "application/vnd.ntt-local.ogw_remote-access": {
          source: "iana"
        },
        "application/vnd.ntt-local.sip-ta_remote": {
          source: "iana"
        },
        "application/vnd.ntt-local.sip-ta_tcp_stream": {
          source: "iana"
        },
        "application/vnd.oasis.opendocument.chart": {
          source: "iana",
          extensions: ["odc"]
        },
        "application/vnd.oasis.opendocument.chart-template": {
          source: "iana",
          extensions: ["otc"]
        },
        "application/vnd.oasis.opendocument.database": {
          source: "iana",
          extensions: ["odb"]
        },
        "application/vnd.oasis.opendocument.formula": {
          source: "iana",
          extensions: ["odf"]
        },
        "application/vnd.oasis.opendocument.formula-template": {
          source: "iana",
          extensions: ["odft"]
        },
        "application/vnd.oasis.opendocument.graphics": {
          source: "iana",
          compressible: false,
          extensions: ["odg"]
        },
        "application/vnd.oasis.opendocument.graphics-template": {
          source: "iana",
          extensions: ["otg"]
        },
        "application/vnd.oasis.opendocument.image": {
          source: "iana",
          extensions: ["odi"]
        },
        "application/vnd.oasis.opendocument.image-template": {
          source: "iana",
          extensions: ["oti"]
        },
        "application/vnd.oasis.opendocument.presentation": {
          source: "iana",
          compressible: false,
          extensions: ["odp"]
        },
        "application/vnd.oasis.opendocument.presentation-template": {
          source: "iana",
          extensions: ["otp"]
        },
        "application/vnd.oasis.opendocument.spreadsheet": {
          source: "iana",
          compressible: false,
          extensions: ["ods"]
        },
        "application/vnd.oasis.opendocument.spreadsheet-template": {
          source: "iana",
          extensions: ["ots"]
        },
        "application/vnd.oasis.opendocument.text": {
          source: "iana",
          compressible: false,
          extensions: ["odt"]
        },
        "application/vnd.oasis.opendocument.text-master": {
          source: "iana",
          extensions: ["odm"]
        },
        "application/vnd.oasis.opendocument.text-template": {
          source: "iana",
          extensions: ["ott"]
        },
        "application/vnd.oasis.opendocument.text-web": {
          source: "iana",
          extensions: ["oth"]
        },
        "application/vnd.obn": {
          source: "iana"
        },
        "application/vnd.ocf+cbor": {
          source: "iana"
        },
        "application/vnd.oci.image.manifest.v1+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oftn.l10n+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.contentaccessdownload+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.contentaccessstreaming+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.cspg-hexbinary": {
          source: "iana"
        },
        "application/vnd.oipf.dae.svg+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.dae.xhtml+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.mippvcontrolmessage+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.pae.gem": {
          source: "iana"
        },
        "application/vnd.oipf.spdiscovery+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.spdlist+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.ueprofile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.userprofile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.olpc-sugar": {
          source: "iana",
          extensions: ["xo"]
        },
        "application/vnd.oma-scws-config": {
          source: "iana"
        },
        "application/vnd.oma-scws-http-request": {
          source: "iana"
        },
        "application/vnd.oma-scws-http-response": {
          source: "iana"
        },
        "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.drm-trigger+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.imd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.ltkm": {
          source: "iana"
        },
        "application/vnd.oma.bcast.notification+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.provisioningtrigger": {
          source: "iana"
        },
        "application/vnd.oma.bcast.sgboot": {
          source: "iana"
        },
        "application/vnd.oma.bcast.sgdd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.sgdu": {
          source: "iana"
        },
        "application/vnd.oma.bcast.simple-symbol-container": {
          source: "iana"
        },
        "application/vnd.oma.bcast.smartcard-trigger+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.sprov+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.stkm": {
          source: "iana"
        },
        "application/vnd.oma.cab-address-book+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.cab-feature-handler+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.cab-pcc+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.cab-subs-invite+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.cab-user-prefs+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.dcd": {
          source: "iana"
        },
        "application/vnd.oma.dcdc": {
          source: "iana"
        },
        "application/vnd.oma.dd2+xml": {
          source: "iana",
          compressible: true,
          extensions: ["dd2"]
        },
        "application/vnd.oma.drm.risd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.group-usage-list+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.lwm2m+cbor": {
          source: "iana"
        },
        "application/vnd.oma.lwm2m+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.lwm2m+tlv": {
          source: "iana"
        },
        "application/vnd.oma.pal+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.detailed-progress-report+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.final-report+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.groups+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.invocation-descriptor+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.optimized-progress-report+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.push": {
          source: "iana"
        },
        "application/vnd.oma.scidm.messages+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.xcap-directory+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.omads-email+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.omads-file+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.omads-folder+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.omaloc-supl-init": {
          source: "iana"
        },
        "application/vnd.onepager": {
          source: "iana"
        },
        "application/vnd.onepagertamp": {
          source: "iana"
        },
        "application/vnd.onepagertamx": {
          source: "iana"
        },
        "application/vnd.onepagertat": {
          source: "iana"
        },
        "application/vnd.onepagertatp": {
          source: "iana"
        },
        "application/vnd.onepagertatx": {
          source: "iana"
        },
        "application/vnd.openblox.game+xml": {
          source: "iana",
          compressible: true,
          extensions: ["obgx"]
        },
        "application/vnd.openblox.game-binary": {
          source: "iana"
        },
        "application/vnd.openeye.oeb": {
          source: "iana"
        },
        "application/vnd.openofficeorg.extension": {
          source: "apache",
          extensions: ["oxt"]
        },
        "application/vnd.openstreetmap.data+xml": {
          source: "iana",
          compressible: true,
          extensions: ["osm"]
        },
        "application/vnd.opentimestamps.ots": {
          source: "iana"
        },
        "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawing+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
          source: "iana",
          compressible: false,
          extensions: ["pptx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slide": {
          source: "iana",
          extensions: ["sldx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
          source: "iana",
          extensions: ["ppsx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.template": {
          source: "iana",
          extensions: ["potx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
          source: "iana",
          compressible: false,
          extensions: ["xlsx"]
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
          source: "iana",
          extensions: ["xltx"]
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.theme+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.vmldrawing": {
          source: "iana"
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
          source: "iana",
          compressible: false,
          extensions: ["docx"]
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
          source: "iana",
          extensions: ["dotx"]
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-package.core-properties+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-package.relationships+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oracle.resource+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.orange.indata": {
          source: "iana"
        },
        "application/vnd.osa.netdeploy": {
          source: "iana"
        },
        "application/vnd.osgeo.mapguide.package": {
          source: "iana",
          extensions: ["mgp"]
        },
        "application/vnd.osgi.bundle": {
          source: "iana"
        },
        "application/vnd.osgi.dp": {
          source: "iana",
          extensions: ["dp"]
        },
        "application/vnd.osgi.subsystem": {
          source: "iana",
          extensions: ["esa"]
        },
        "application/vnd.otps.ct-kip+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oxli.countgraph": {
          source: "iana"
        },
        "application/vnd.pagerduty+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.palm": {
          source: "iana",
          extensions: ["pdb", "pqa", "oprc"]
        },
        "application/vnd.panoply": {
          source: "iana"
        },
        "application/vnd.paos.xml": {
          source: "iana"
        },
        "application/vnd.patentdive": {
          source: "iana"
        },
        "application/vnd.patientecommsdoc": {
          source: "iana"
        },
        "application/vnd.pawaafile": {
          source: "iana",
          extensions: ["paw"]
        },
        "application/vnd.pcos": {
          source: "iana"
        },
        "application/vnd.pg.format": {
          source: "iana",
          extensions: ["str"]
        },
        "application/vnd.pg.osasli": {
          source: "iana",
          extensions: ["ei6"]
        },
        "application/vnd.piaccess.application-licence": {
          source: "iana"
        },
        "application/vnd.picsel": {
          source: "iana",
          extensions: ["efif"]
        },
        "application/vnd.pmi.widget": {
          source: "iana",
          extensions: ["wg"]
        },
        "application/vnd.poc.group-advertisement+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.pocketlearn": {
          source: "iana",
          extensions: ["plf"]
        },
        "application/vnd.powerbuilder6": {
          source: "iana",
          extensions: ["pbd"]
        },
        "application/vnd.powerbuilder6-s": {
          source: "iana"
        },
        "application/vnd.powerbuilder7": {
          source: "iana"
        },
        "application/vnd.powerbuilder7-s": {
          source: "iana"
        },
        "application/vnd.powerbuilder75": {
          source: "iana"
        },
        "application/vnd.powerbuilder75-s": {
          source: "iana"
        },
        "application/vnd.preminet": {
          source: "iana"
        },
        "application/vnd.previewsystems.box": {
          source: "iana",
          extensions: ["box"]
        },
        "application/vnd.proteus.magazine": {
          source: "iana",
          extensions: ["mgz"]
        },
        "application/vnd.psfs": {
          source: "iana"
        },
        "application/vnd.publishare-delta-tree": {
          source: "iana",
          extensions: ["qps"]
        },
        "application/vnd.pvi.ptid1": {
          source: "iana",
          extensions: ["ptid"]
        },
        "application/vnd.pwg-multiplexed": {
          source: "iana"
        },
        "application/vnd.pwg-xhtml-print+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.qualcomm.brew-app-res": {
          source: "iana"
        },
        "application/vnd.quarantainenet": {
          source: "iana"
        },
        "application/vnd.quark.quarkxpress": {
          source: "iana",
          extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
        },
        "application/vnd.quobject-quoxdocument": {
          source: "iana"
        },
        "application/vnd.radisys.moml+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit-conf+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit-conn+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit-dialog+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit-stream+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-conf+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-base+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-fax-detect+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-group+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-speech+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-transform+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.rainstor.data": {
          source: "iana"
        },
        "application/vnd.rapid": {
          source: "iana"
        },
        "application/vnd.rar": {
          source: "iana",
          extensions: ["rar"]
        },
        "application/vnd.realvnc.bed": {
          source: "iana",
          extensions: ["bed"]
        },
        "application/vnd.recordare.musicxml": {
          source: "iana",
          extensions: ["mxl"]
        },
        "application/vnd.recordare.musicxml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["musicxml"]
        },
        "application/vnd.renlearn.rlprint": {
          source: "iana"
        },
        "application/vnd.resilient.logic": {
          source: "iana"
        },
        "application/vnd.restful+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.rig.cryptonote": {
          source: "iana",
          extensions: ["cryptonote"]
        },
        "application/vnd.rim.cod": {
          source: "apache",
          extensions: ["cod"]
        },
        "application/vnd.rn-realmedia": {
          source: "apache",
          extensions: ["rm"]
        },
        "application/vnd.rn-realmedia-vbr": {
          source: "apache",
          extensions: ["rmvb"]
        },
        "application/vnd.route66.link66+xml": {
          source: "iana",
          compressible: true,
          extensions: ["link66"]
        },
        "application/vnd.rs-274x": {
          source: "iana"
        },
        "application/vnd.ruckus.download": {
          source: "iana"
        },
        "application/vnd.s3sms": {
          source: "iana"
        },
        "application/vnd.sailingtracker.track": {
          source: "iana",
          extensions: ["st"]
        },
        "application/vnd.sar": {
          source: "iana"
        },
        "application/vnd.sbm.cid": {
          source: "iana"
        },
        "application/vnd.sbm.mid2": {
          source: "iana"
        },
        "application/vnd.scribus": {
          source: "iana"
        },
        "application/vnd.sealed.3df": {
          source: "iana"
        },
        "application/vnd.sealed.csf": {
          source: "iana"
        },
        "application/vnd.sealed.doc": {
          source: "iana"
        },
        "application/vnd.sealed.eml": {
          source: "iana"
        },
        "application/vnd.sealed.mht": {
          source: "iana"
        },
        "application/vnd.sealed.net": {
          source: "iana"
        },
        "application/vnd.sealed.ppt": {
          source: "iana"
        },
        "application/vnd.sealed.tiff": {
          source: "iana"
        },
        "application/vnd.sealed.xls": {
          source: "iana"
        },
        "application/vnd.sealedmedia.softseal.html": {
          source: "iana"
        },
        "application/vnd.sealedmedia.softseal.pdf": {
          source: "iana"
        },
        "application/vnd.seemail": {
          source: "iana",
          extensions: ["see"]
        },
        "application/vnd.seis+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.sema": {
          source: "iana",
          extensions: ["sema"]
        },
        "application/vnd.semd": {
          source: "iana",
          extensions: ["semd"]
        },
        "application/vnd.semf": {
          source: "iana",
          extensions: ["semf"]
        },
        "application/vnd.shade-save-file": {
          source: "iana"
        },
        "application/vnd.shana.informed.formdata": {
          source: "iana",
          extensions: ["ifm"]
        },
        "application/vnd.shana.informed.formtemplate": {
          source: "iana",
          extensions: ["itp"]
        },
        "application/vnd.shana.informed.interchange": {
          source: "iana",
          extensions: ["iif"]
        },
        "application/vnd.shana.informed.package": {
          source: "iana",
          extensions: ["ipk"]
        },
        "application/vnd.shootproof+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.shopkick+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.shp": {
          source: "iana"
        },
        "application/vnd.shx": {
          source: "iana"
        },
        "application/vnd.sigrok.session": {
          source: "iana"
        },
        "application/vnd.simtech-mindmapper": {
          source: "iana",
          extensions: ["twd", "twds"]
        },
        "application/vnd.siren+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.smaf": {
          source: "iana",
          extensions: ["mmf"]
        },
        "application/vnd.smart.notebook": {
          source: "iana"
        },
        "application/vnd.smart.teacher": {
          source: "iana",
          extensions: ["teacher"]
        },
        "application/vnd.snesdev-page-table": {
          source: "iana"
        },
        "application/vnd.software602.filler.form+xml": {
          source: "iana",
          compressible: true,
          extensions: ["fo"]
        },
        "application/vnd.software602.filler.form-xml-zip": {
          source: "iana"
        },
        "application/vnd.solent.sdkm+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sdkm", "sdkd"]
        },
        "application/vnd.spotfire.dxp": {
          source: "iana",
          extensions: ["dxp"]
        },
        "application/vnd.spotfire.sfs": {
          source: "iana",
          extensions: ["sfs"]
        },
        "application/vnd.sqlite3": {
          source: "iana"
        },
        "application/vnd.sss-cod": {
          source: "iana"
        },
        "application/vnd.sss-dtf": {
          source: "iana"
        },
        "application/vnd.sss-ntf": {
          source: "iana"
        },
        "application/vnd.stardivision.calc": {
          source: "apache",
          extensions: ["sdc"]
        },
        "application/vnd.stardivision.draw": {
          source: "apache",
          extensions: ["sda"]
        },
        "application/vnd.stardivision.impress": {
          source: "apache",
          extensions: ["sdd"]
        },
        "application/vnd.stardivision.math": {
          source: "apache",
          extensions: ["smf"]
        },
        "application/vnd.stardivision.writer": {
          source: "apache",
          extensions: ["sdw", "vor"]
        },
        "application/vnd.stardivision.writer-global": {
          source: "apache",
          extensions: ["sgl"]
        },
        "application/vnd.stepmania.package": {
          source: "iana",
          extensions: ["smzip"]
        },
        "application/vnd.stepmania.stepchart": {
          source: "iana",
          extensions: ["sm"]
        },
        "application/vnd.street-stream": {
          source: "iana"
        },
        "application/vnd.sun.wadl+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wadl"]
        },
        "application/vnd.sun.xml.calc": {
          source: "apache",
          extensions: ["sxc"]
        },
        "application/vnd.sun.xml.calc.template": {
          source: "apache",
          extensions: ["stc"]
        },
        "application/vnd.sun.xml.draw": {
          source: "apache",
          extensions: ["sxd"]
        },
        "application/vnd.sun.xml.draw.template": {
          source: "apache",
          extensions: ["std"]
        },
        "application/vnd.sun.xml.impress": {
          source: "apache",
          extensions: ["sxi"]
        },
        "application/vnd.sun.xml.impress.template": {
          source: "apache",
          extensions: ["sti"]
        },
        "application/vnd.sun.xml.math": {
          source: "apache",
          extensions: ["sxm"]
        },
        "application/vnd.sun.xml.writer": {
          source: "apache",
          extensions: ["sxw"]
        },
        "application/vnd.sun.xml.writer.global": {
          source: "apache",
          extensions: ["sxg"]
        },
        "application/vnd.sun.xml.writer.template": {
          source: "apache",
          extensions: ["stw"]
        },
        "application/vnd.sus-calendar": {
          source: "iana",
          extensions: ["sus", "susp"]
        },
        "application/vnd.svd": {
          source: "iana",
          extensions: ["svd"]
        },
        "application/vnd.swiftview-ics": {
          source: "iana"
        },
        "application/vnd.sycle+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.syft+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.symbian.install": {
          source: "apache",
          extensions: ["sis", "sisx"]
        },
        "application/vnd.syncml+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["xsm"]
        },
        "application/vnd.syncml.dm+wbxml": {
          source: "iana",
          charset: "UTF-8",
          extensions: ["bdm"]
        },
        "application/vnd.syncml.dm+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["xdm"]
        },
        "application/vnd.syncml.dm.notification": {
          source: "iana"
        },
        "application/vnd.syncml.dmddf+wbxml": {
          source: "iana"
        },
        "application/vnd.syncml.dmddf+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["ddf"]
        },
        "application/vnd.syncml.dmtnds+wbxml": {
          source: "iana"
        },
        "application/vnd.syncml.dmtnds+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.syncml.ds.notification": {
          source: "iana"
        },
        "application/vnd.tableschema+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.tao.intent-module-archive": {
          source: "iana",
          extensions: ["tao"]
        },
        "application/vnd.tcpdump.pcap": {
          source: "iana",
          extensions: ["pcap", "cap", "dmp"]
        },
        "application/vnd.think-cell.ppttc+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.tmd.mediaflex.api+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.tml": {
          source: "iana"
        },
        "application/vnd.tmobile-livetv": {
          source: "iana",
          extensions: ["tmo"]
        },
        "application/vnd.tri.onesource": {
          source: "iana"
        },
        "application/vnd.trid.tpt": {
          source: "iana",
          extensions: ["tpt"]
        },
        "application/vnd.triscape.mxs": {
          source: "iana",
          extensions: ["mxs"]
        },
        "application/vnd.trueapp": {
          source: "iana",
          extensions: ["tra"]
        },
        "application/vnd.truedoc": {
          source: "iana"
        },
        "application/vnd.ubisoft.webplayer": {
          source: "iana"
        },
        "application/vnd.ufdl": {
          source: "iana",
          extensions: ["ufd", "ufdl"]
        },
        "application/vnd.uiq.theme": {
          source: "iana",
          extensions: ["utz"]
        },
        "application/vnd.umajin": {
          source: "iana",
          extensions: ["umj"]
        },
        "application/vnd.unity": {
          source: "iana",
          extensions: ["unityweb"]
        },
        "application/vnd.uoml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["uoml"]
        },
        "application/vnd.uplanet.alert": {
          source: "iana"
        },
        "application/vnd.uplanet.alert-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.bearer-choice": {
          source: "iana"
        },
        "application/vnd.uplanet.bearer-choice-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.cacheop": {
          source: "iana"
        },
        "application/vnd.uplanet.cacheop-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.channel": {
          source: "iana"
        },
        "application/vnd.uplanet.channel-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.list": {
          source: "iana"
        },
        "application/vnd.uplanet.list-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.listcmd": {
          source: "iana"
        },
        "application/vnd.uplanet.listcmd-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.signal": {
          source: "iana"
        },
        "application/vnd.uri-map": {
          source: "iana"
        },
        "application/vnd.valve.source.material": {
          source: "iana"
        },
        "application/vnd.vcx": {
          source: "iana",
          extensions: ["vcx"]
        },
        "application/vnd.vd-study": {
          source: "iana"
        },
        "application/vnd.vectorworks": {
          source: "iana"
        },
        "application/vnd.vel+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.verimatrix.vcas": {
          source: "iana"
        },
        "application/vnd.veritone.aion+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.veryant.thin": {
          source: "iana"
        },
        "application/vnd.ves.encrypted": {
          source: "iana"
        },
        "application/vnd.vidsoft.vidconference": {
          source: "iana"
        },
        "application/vnd.visio": {
          source: "iana",
          extensions: ["vsd", "vst", "vss", "vsw"]
        },
        "application/vnd.visionary": {
          source: "iana",
          extensions: ["vis"]
        },
        "application/vnd.vividence.scriptfile": {
          source: "iana"
        },
        "application/vnd.vsf": {
          source: "iana",
          extensions: ["vsf"]
        },
        "application/vnd.wap.sic": {
          source: "iana"
        },
        "application/vnd.wap.slc": {
          source: "iana"
        },
        "application/vnd.wap.wbxml": {
          source: "iana",
          charset: "UTF-8",
          extensions: ["wbxml"]
        },
        "application/vnd.wap.wmlc": {
          source: "iana",
          extensions: ["wmlc"]
        },
        "application/vnd.wap.wmlscriptc": {
          source: "iana",
          extensions: ["wmlsc"]
        },
        "application/vnd.webturbo": {
          source: "iana",
          extensions: ["wtb"]
        },
        "application/vnd.wfa.dpp": {
          source: "iana"
        },
        "application/vnd.wfa.p2p": {
          source: "iana"
        },
        "application/vnd.wfa.wsc": {
          source: "iana"
        },
        "application/vnd.windows.devicepairing": {
          source: "iana"
        },
        "application/vnd.wmc": {
          source: "iana"
        },
        "application/vnd.wmf.bootstrap": {
          source: "iana"
        },
        "application/vnd.wolfram.mathematica": {
          source: "iana"
        },
        "application/vnd.wolfram.mathematica.package": {
          source: "iana"
        },
        "application/vnd.wolfram.player": {
          source: "iana",
          extensions: ["nbp"]
        },
        "application/vnd.wordperfect": {
          source: "iana",
          extensions: ["wpd"]
        },
        "application/vnd.wqd": {
          source: "iana",
          extensions: ["wqd"]
        },
        "application/vnd.wrq-hp3000-labelled": {
          source: "iana"
        },
        "application/vnd.wt.stf": {
          source: "iana",
          extensions: ["stf"]
        },
        "application/vnd.wv.csp+wbxml": {
          source: "iana"
        },
        "application/vnd.wv.csp+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.wv.ssp+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.xacml+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.xara": {
          source: "iana",
          extensions: ["xar"]
        },
        "application/vnd.xfdl": {
          source: "iana",
          extensions: ["xfdl"]
        },
        "application/vnd.xfdl.webform": {
          source: "iana"
        },
        "application/vnd.xmi+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.xmpie.cpkg": {
          source: "iana"
        },
        "application/vnd.xmpie.dpkg": {
          source: "iana"
        },
        "application/vnd.xmpie.plan": {
          source: "iana"
        },
        "application/vnd.xmpie.ppkg": {
          source: "iana"
        },
        "application/vnd.xmpie.xlim": {
          source: "iana"
        },
        "application/vnd.yamaha.hv-dic": {
          source: "iana",
          extensions: ["hvd"]
        },
        "application/vnd.yamaha.hv-script": {
          source: "iana",
          extensions: ["hvs"]
        },
        "application/vnd.yamaha.hv-voice": {
          source: "iana",
          extensions: ["hvp"]
        },
        "application/vnd.yamaha.openscoreformat": {
          source: "iana",
          extensions: ["osf"]
        },
        "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
          source: "iana",
          compressible: true,
          extensions: ["osfpvg"]
        },
        "application/vnd.yamaha.remote-setup": {
          source: "iana"
        },
        "application/vnd.yamaha.smaf-audio": {
          source: "iana",
          extensions: ["saf"]
        },
        "application/vnd.yamaha.smaf-phrase": {
          source: "iana",
          extensions: ["spf"]
        },
        "application/vnd.yamaha.through-ngn": {
          source: "iana"
        },
        "application/vnd.yamaha.tunnel-udpencap": {
          source: "iana"
        },
        "application/vnd.yaoweme": {
          source: "iana"
        },
        "application/vnd.yellowriver-custom-menu": {
          source: "iana",
          extensions: ["cmp"]
        },
        "application/vnd.youtube.yt": {
          source: "iana"
        },
        "application/vnd.zul": {
          source: "iana",
          extensions: ["zir", "zirz"]
        },
        "application/vnd.zzazz.deck+xml": {
          source: "iana",
          compressible: true,
          extensions: ["zaz"]
        },
        "application/voicexml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["vxml"]
        },
        "application/voucher-cms+json": {
          source: "iana",
          compressible: true
        },
        "application/vq-rtcpxr": {
          source: "iana"
        },
        "application/wasm": {
          source: "iana",
          compressible: true,
          extensions: ["wasm"]
        },
        "application/watcherinfo+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wif"]
        },
        "application/webpush-options+json": {
          source: "iana",
          compressible: true
        },
        "application/whoispp-query": {
          source: "iana"
        },
        "application/whoispp-response": {
          source: "iana"
        },
        "application/widget": {
          source: "iana",
          extensions: ["wgt"]
        },
        "application/winhlp": {
          source: "apache",
          extensions: ["hlp"]
        },
        "application/wita": {
          source: "iana"
        },
        "application/wordperfect5.1": {
          source: "iana"
        },
        "application/wsdl+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wsdl"]
        },
        "application/wspolicy+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wspolicy"]
        },
        "application/x-7z-compressed": {
          source: "apache",
          compressible: false,
          extensions: ["7z"]
        },
        "application/x-abiword": {
          source: "apache",
          extensions: ["abw"]
        },
        "application/x-ace-compressed": {
          source: "apache",
          extensions: ["ace"]
        },
        "application/x-amf": {
          source: "apache"
        },
        "application/x-apple-diskimage": {
          source: "apache",
          extensions: ["dmg"]
        },
        "application/x-arj": {
          compressible: false,
          extensions: ["arj"]
        },
        "application/x-authorware-bin": {
          source: "apache",
          extensions: ["aab", "x32", "u32", "vox"]
        },
        "application/x-authorware-map": {
          source: "apache",
          extensions: ["aam"]
        },
        "application/x-authorware-seg": {
          source: "apache",
          extensions: ["aas"]
        },
        "application/x-bcpio": {
          source: "apache",
          extensions: ["bcpio"]
        },
        "application/x-bdoc": {
          compressible: false,
          extensions: ["bdoc"]
        },
        "application/x-bittorrent": {
          source: "apache",
          extensions: ["torrent"]
        },
        "application/x-blorb": {
          source: "apache",
          extensions: ["blb", "blorb"]
        },
        "application/x-bzip": {
          source: "apache",
          compressible: false,
          extensions: ["bz"]
        },
        "application/x-bzip2": {
          source: "apache",
          compressible: false,
          extensions: ["bz2", "boz"]
        },
        "application/x-cbr": {
          source: "apache",
          extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
        },
        "application/x-cdlink": {
          source: "apache",
          extensions: ["vcd"]
        },
        "application/x-cfs-compressed": {
          source: "apache",
          extensions: ["cfs"]
        },
        "application/x-chat": {
          source: "apache",
          extensions: ["chat"]
        },
        "application/x-chess-pgn": {
          source: "apache",
          extensions: ["pgn"]
        },
        "application/x-chrome-extension": {
          extensions: ["crx"]
        },
        "application/x-cocoa": {
          source: "nginx",
          extensions: ["cco"]
        },
        "application/x-compress": {
          source: "apache"
        },
        "application/x-conference": {
          source: "apache",
          extensions: ["nsc"]
        },
        "application/x-cpio": {
          source: "apache",
          extensions: ["cpio"]
        },
        "application/x-csh": {
          source: "apache",
          extensions: ["csh"]
        },
        "application/x-deb": {
          compressible: false
        },
        "application/x-debian-package": {
          source: "apache",
          extensions: ["deb", "udeb"]
        },
        "application/x-dgc-compressed": {
          source: "apache",
          extensions: ["dgc"]
        },
        "application/x-director": {
          source: "apache",
          extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
        },
        "application/x-doom": {
          source: "apache",
          extensions: ["wad"]
        },
        "application/x-dtbncx+xml": {
          source: "apache",
          compressible: true,
          extensions: ["ncx"]
        },
        "application/x-dtbook+xml": {
          source: "apache",
          compressible: true,
          extensions: ["dtb"]
        },
        "application/x-dtbresource+xml": {
          source: "apache",
          compressible: true,
          extensions: ["res"]
        },
        "application/x-dvi": {
          source: "apache",
          compressible: false,
          extensions: ["dvi"]
        },
        "application/x-envoy": {
          source: "apache",
          extensions: ["evy"]
        },
        "application/x-eva": {
          source: "apache",
          extensions: ["eva"]
        },
        "application/x-font-bdf": {
          source: "apache",
          extensions: ["bdf"]
        },
        "application/x-font-dos": {
          source: "apache"
        },
        "application/x-font-framemaker": {
          source: "apache"
        },
        "application/x-font-ghostscript": {
          source: "apache",
          extensions: ["gsf"]
        },
        "application/x-font-libgrx": {
          source: "apache"
        },
        "application/x-font-linux-psf": {
          source: "apache",
          extensions: ["psf"]
        },
        "application/x-font-pcf": {
          source: "apache",
          extensions: ["pcf"]
        },
        "application/x-font-snf": {
          source: "apache",
          extensions: ["snf"]
        },
        "application/x-font-speedo": {
          source: "apache"
        },
        "application/x-font-sunos-news": {
          source: "apache"
        },
        "application/x-font-type1": {
          source: "apache",
          extensions: ["pfa", "pfb", "pfm", "afm"]
        },
        "application/x-font-vfont": {
          source: "apache"
        },
        "application/x-freearc": {
          source: "apache",
          extensions: ["arc"]
        },
        "application/x-futuresplash": {
          source: "apache",
          extensions: ["spl"]
        },
        "application/x-gca-compressed": {
          source: "apache",
          extensions: ["gca"]
        },
        "application/x-glulx": {
          source: "apache",
          extensions: ["ulx"]
        },
        "application/x-gnumeric": {
          source: "apache",
          extensions: ["gnumeric"]
        },
        "application/x-gramps-xml": {
          source: "apache",
          extensions: ["gramps"]
        },
        "application/x-gtar": {
          source: "apache",
          extensions: ["gtar"]
        },
        "application/x-gzip": {
          source: "apache"
        },
        "application/x-hdf": {
          source: "apache",
          extensions: ["hdf"]
        },
        "application/x-httpd-php": {
          compressible: true,
          extensions: ["php"]
        },
        "application/x-install-instructions": {
          source: "apache",
          extensions: ["install"]
        },
        "application/x-iso9660-image": {
          source: "apache",
          extensions: ["iso"]
        },
        "application/x-iwork-keynote-sffkey": {
          extensions: ["key"]
        },
        "application/x-iwork-numbers-sffnumbers": {
          extensions: ["numbers"]
        },
        "application/x-iwork-pages-sffpages": {
          extensions: ["pages"]
        },
        "application/x-java-archive-diff": {
          source: "nginx",
          extensions: ["jardiff"]
        },
        "application/x-java-jnlp-file": {
          source: "apache",
          compressible: false,
          extensions: ["jnlp"]
        },
        "application/x-javascript": {
          compressible: true
        },
        "application/x-keepass2": {
          extensions: ["kdbx"]
        },
        "application/x-latex": {
          source: "apache",
          compressible: false,
          extensions: ["latex"]
        },
        "application/x-lua-bytecode": {
          extensions: ["luac"]
        },
        "application/x-lzh-compressed": {
          source: "apache",
          extensions: ["lzh", "lha"]
        },
        "application/x-makeself": {
          source: "nginx",
          extensions: ["run"]
        },
        "application/x-mie": {
          source: "apache",
          extensions: ["mie"]
        },
        "application/x-mobipocket-ebook": {
          source: "apache",
          extensions: ["prc", "mobi"]
        },
        "application/x-mpegurl": {
          compressible: false
        },
        "application/x-ms-application": {
          source: "apache",
          extensions: ["application"]
        },
        "application/x-ms-shortcut": {
          source: "apache",
          extensions: ["lnk"]
        },
        "application/x-ms-wmd": {
          source: "apache",
          extensions: ["wmd"]
        },
        "application/x-ms-wmz": {
          source: "apache",
          extensions: ["wmz"]
        },
        "application/x-ms-xbap": {
          source: "apache",
          extensions: ["xbap"]
        },
        "application/x-msaccess": {
          source: "apache",
          extensions: ["mdb"]
        },
        "application/x-msbinder": {
          source: "apache",
          extensions: ["obd"]
        },
        "application/x-mscardfile": {
          source: "apache",
          extensions: ["crd"]
        },
        "application/x-msclip": {
          source: "apache",
          extensions: ["clp"]
        },
        "application/x-msdos-program": {
          extensions: ["exe"]
        },
        "application/x-msdownload": {
          source: "apache",
          extensions: ["exe", "dll", "com", "bat", "msi"]
        },
        "application/x-msmediaview": {
          source: "apache",
          extensions: ["mvb", "m13", "m14"]
        },
        "application/x-msmetafile": {
          source: "apache",
          extensions: ["wmf", "wmz", "emf", "emz"]
        },
        "application/x-msmoney": {
          source: "apache",
          extensions: ["mny"]
        },
        "application/x-mspublisher": {
          source: "apache",
          extensions: ["pub"]
        },
        "application/x-msschedule": {
          source: "apache",
          extensions: ["scd"]
        },
        "application/x-msterminal": {
          source: "apache",
          extensions: ["trm"]
        },
        "application/x-mswrite": {
          source: "apache",
          extensions: ["wri"]
        },
        "application/x-netcdf": {
          source: "apache",
          extensions: ["nc", "cdf"]
        },
        "application/x-ns-proxy-autoconfig": {
          compressible: true,
          extensions: ["pac"]
        },
        "application/x-nzb": {
          source: "apache",
          extensions: ["nzb"]
        },
        "application/x-perl": {
          source: "nginx",
          extensions: ["pl", "pm"]
        },
        "application/x-pilot": {
          source: "nginx",
          extensions: ["prc", "pdb"]
        },
        "application/x-pkcs12": {
          source: "apache",
          compressible: false,
          extensions: ["p12", "pfx"]
        },
        "application/x-pkcs7-certificates": {
          source: "apache",
          extensions: ["p7b", "spc"]
        },
        "application/x-pkcs7-certreqresp": {
          source: "apache",
          extensions: ["p7r"]
        },
        "application/x-pki-message": {
          source: "iana"
        },
        "application/x-rar-compressed": {
          source: "apache",
          compressible: false,
          extensions: ["rar"]
        },
        "application/x-redhat-package-manager": {
          source: "nginx",
          extensions: ["rpm"]
        },
        "application/x-research-info-systems": {
          source: "apache",
          extensions: ["ris"]
        },
        "application/x-sea": {
          source: "nginx",
          extensions: ["sea"]
        },
        "application/x-sh": {
          source: "apache",
          compressible: true,
          extensions: ["sh"]
        },
        "application/x-shar": {
          source: "apache",
          extensions: ["shar"]
        },
        "application/x-shockwave-flash": {
          source: "apache",
          compressible: false,
          extensions: ["swf"]
        },
        "application/x-silverlight-app": {
          source: "apache",
          extensions: ["xap"]
        },
        "application/x-sql": {
          source: "apache",
          extensions: ["sql"]
        },
        "application/x-stuffit": {
          source: "apache",
          compressible: false,
          extensions: ["sit"]
        },
        "application/x-stuffitx": {
          source: "apache",
          extensions: ["sitx"]
        },
        "application/x-subrip": {
          source: "apache",
          extensions: ["srt"]
        },
        "application/x-sv4cpio": {
          source: "apache",
          extensions: ["sv4cpio"]
        },
        "application/x-sv4crc": {
          source: "apache",
          extensions: ["sv4crc"]
        },
        "application/x-t3vm-image": {
          source: "apache",
          extensions: ["t3"]
        },
        "application/x-tads": {
          source: "apache",
          extensions: ["gam"]
        },
        "application/x-tar": {
          source: "apache",
          compressible: true,
          extensions: ["tar"]
        },
        "application/x-tcl": {
          source: "apache",
          extensions: ["tcl", "tk"]
        },
        "application/x-tex": {
          source: "apache",
          extensions: ["tex"]
        },
        "application/x-tex-tfm": {
          source: "apache",
          extensions: ["tfm"]
        },
        "application/x-texinfo": {
          source: "apache",
          extensions: ["texinfo", "texi"]
        },
        "application/x-tgif": {
          source: "apache",
          extensions: ["obj"]
        },
        "application/x-ustar": {
          source: "apache",
          extensions: ["ustar"]
        },
        "application/x-virtualbox-hdd": {
          compressible: true,
          extensions: ["hdd"]
        },
        "application/x-virtualbox-ova": {
          compressible: true,
          extensions: ["ova"]
        },
        "application/x-virtualbox-ovf": {
          compressible: true,
          extensions: ["ovf"]
        },
        "application/x-virtualbox-vbox": {
          compressible: true,
          extensions: ["vbox"]
        },
        "application/x-virtualbox-vbox-extpack": {
          compressible: false,
          extensions: ["vbox-extpack"]
        },
        "application/x-virtualbox-vdi": {
          compressible: true,
          extensions: ["vdi"]
        },
        "application/x-virtualbox-vhd": {
          compressible: true,
          extensions: ["vhd"]
        },
        "application/x-virtualbox-vmdk": {
          compressible: true,
          extensions: ["vmdk"]
        },
        "application/x-wais-source": {
          source: "apache",
          extensions: ["src"]
        },
        "application/x-web-app-manifest+json": {
          compressible: true,
          extensions: ["webapp"]
        },
        "application/x-www-form-urlencoded": {
          source: "iana",
          compressible: true
        },
        "application/x-x509-ca-cert": {
          source: "iana",
          extensions: ["der", "crt", "pem"]
        },
        "application/x-x509-ca-ra-cert": {
          source: "iana"
        },
        "application/x-x509-next-ca-cert": {
          source: "iana"
        },
        "application/x-xfig": {
          source: "apache",
          extensions: ["fig"]
        },
        "application/x-xliff+xml": {
          source: "apache",
          compressible: true,
          extensions: ["xlf"]
        },
        "application/x-xpinstall": {
          source: "apache",
          compressible: false,
          extensions: ["xpi"]
        },
        "application/x-xz": {
          source: "apache",
          extensions: ["xz"]
        },
        "application/x-zmachine": {
          source: "apache",
          extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
        },
        "application/x400-bp": {
          source: "iana"
        },
        "application/xacml+xml": {
          source: "iana",
          compressible: true
        },
        "application/xaml+xml": {
          source: "apache",
          compressible: true,
          extensions: ["xaml"]
        },
        "application/xcap-att+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xav"]
        },
        "application/xcap-caps+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xca"]
        },
        "application/xcap-diff+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xdf"]
        },
        "application/xcap-el+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xel"]
        },
        "application/xcap-error+xml": {
          source: "iana",
          compressible: true
        },
        "application/xcap-ns+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xns"]
        },
        "application/xcon-conference-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/xcon-conference-info-diff+xml": {
          source: "iana",
          compressible: true
        },
        "application/xenc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xenc"]
        },
        "application/xhtml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xhtml", "xht"]
        },
        "application/xhtml-voice+xml": {
          source: "apache",
          compressible: true
        },
        "application/xliff+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xlf"]
        },
        "application/xml": {
          source: "iana",
          compressible: true,
          extensions: ["xml", "xsl", "xsd", "rng"]
        },
        "application/xml-dtd": {
          source: "iana",
          compressible: true,
          extensions: ["dtd"]
        },
        "application/xml-external-parsed-entity": {
          source: "iana"
        },
        "application/xml-patch+xml": {
          source: "iana",
          compressible: true
        },
        "application/xmpp+xml": {
          source: "iana",
          compressible: true
        },
        "application/xop+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xop"]
        },
        "application/xproc+xml": {
          source: "apache",
          compressible: true,
          extensions: ["xpl"]
        },
        "application/xslt+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xsl", "xslt"]
        },
        "application/xspf+xml": {
          source: "apache",
          compressible: true,
          extensions: ["xspf"]
        },
        "application/xv+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mxml", "xhvml", "xvml", "xvm"]
        },
        "application/yang": {
          source: "iana",
          extensions: ["yang"]
        },
        "application/yang-data+json": {
          source: "iana",
          compressible: true
        },
        "application/yang-data+xml": {
          source: "iana",
          compressible: true
        },
        "application/yang-patch+json": {
          source: "iana",
          compressible: true
        },
        "application/yang-patch+xml": {
          source: "iana",
          compressible: true
        },
        "application/yin+xml": {
          source: "iana",
          compressible: true,
          extensions: ["yin"]
        },
        "application/zip": {
          source: "iana",
          compressible: false,
          extensions: ["zip"]
        },
        "application/zlib": {
          source: "iana"
        },
        "application/zstd": {
          source: "iana"
        },
        "audio/1d-interleaved-parityfec": {
          source: "iana"
        },
        "audio/32kadpcm": {
          source: "iana"
        },
        "audio/3gpp": {
          source: "iana",
          compressible: false,
          extensions: ["3gpp"]
        },
        "audio/3gpp2": {
          source: "iana"
        },
        "audio/aac": {
          source: "iana"
        },
        "audio/ac3": {
          source: "iana"
        },
        "audio/adpcm": {
          source: "apache",
          extensions: ["adp"]
        },
        "audio/amr": {
          source: "iana",
          extensions: ["amr"]
        },
        "audio/amr-wb": {
          source: "iana"
        },
        "audio/amr-wb+": {
          source: "iana"
        },
        "audio/aptx": {
          source: "iana"
        },
        "audio/asc": {
          source: "iana"
        },
        "audio/atrac-advanced-lossless": {
          source: "iana"
        },
        "audio/atrac-x": {
          source: "iana"
        },
        "audio/atrac3": {
          source: "iana"
        },
        "audio/basic": {
          source: "iana",
          compressible: false,
          extensions: ["au", "snd"]
        },
        "audio/bv16": {
          source: "iana"
        },
        "audio/bv32": {
          source: "iana"
        },
        "audio/clearmode": {
          source: "iana"
        },
        "audio/cn": {
          source: "iana"
        },
        "audio/dat12": {
          source: "iana"
        },
        "audio/dls": {
          source: "iana"
        },
        "audio/dsr-es201108": {
          source: "iana"
        },
        "audio/dsr-es202050": {
          source: "iana"
        },
        "audio/dsr-es202211": {
          source: "iana"
        },
        "audio/dsr-es202212": {
          source: "iana"
        },
        "audio/dv": {
          source: "iana"
        },
        "audio/dvi4": {
          source: "iana"
        },
        "audio/eac3": {
          source: "iana"
        },
        "audio/encaprtp": {
          source: "iana"
        },
        "audio/evrc": {
          source: "iana"
        },
        "audio/evrc-qcp": {
          source: "iana"
        },
        "audio/evrc0": {
          source: "iana"
        },
        "audio/evrc1": {
          source: "iana"
        },
        "audio/evrcb": {
          source: "iana"
        },
        "audio/evrcb0": {
          source: "iana"
        },
        "audio/evrcb1": {
          source: "iana"
        },
        "audio/evrcnw": {
          source: "iana"
        },
        "audio/evrcnw0": {
          source: "iana"
        },
        "audio/evrcnw1": {
          source: "iana"
        },
        "audio/evrcwb": {
          source: "iana"
        },
        "audio/evrcwb0": {
          source: "iana"
        },
        "audio/evrcwb1": {
          source: "iana"
        },
        "audio/evs": {
          source: "iana"
        },
        "audio/flexfec": {
          source: "iana"
        },
        "audio/fwdred": {
          source: "iana"
        },
        "audio/g711-0": {
          source: "iana"
        },
        "audio/g719": {
          source: "iana"
        },
        "audio/g722": {
          source: "iana"
        },
        "audio/g7221": {
          source: "iana"
        },
        "audio/g723": {
          source: "iana"
        },
        "audio/g726-16": {
          source: "iana"
        },
        "audio/g726-24": {
          source: "iana"
        },
        "audio/g726-32": {
          source: "iana"
        },
        "audio/g726-40": {
          source: "iana"
        },
        "audio/g728": {
          source: "iana"
        },
        "audio/g729": {
          source: "iana"
        },
        "audio/g7291": {
          source: "iana"
        },
        "audio/g729d": {
          source: "iana"
        },
        "audio/g729e": {
          source: "iana"
        },
        "audio/gsm": {
          source: "iana"
        },
        "audio/gsm-efr": {
          source: "iana"
        },
        "audio/gsm-hr-08": {
          source: "iana"
        },
        "audio/ilbc": {
          source: "iana"
        },
        "audio/ip-mr_v2.5": {
          source: "iana"
        },
        "audio/isac": {
          source: "apache"
        },
        "audio/l16": {
          source: "iana"
        },
        "audio/l20": {
          source: "iana"
        },
        "audio/l24": {
          source: "iana",
          compressible: false
        },
        "audio/l8": {
          source: "iana"
        },
        "audio/lpc": {
          source: "iana"
        },
        "audio/melp": {
          source: "iana"
        },
        "audio/melp1200": {
          source: "iana"
        },
        "audio/melp2400": {
          source: "iana"
        },
        "audio/melp600": {
          source: "iana"
        },
        "audio/mhas": {
          source: "iana"
        },
        "audio/midi": {
          source: "apache",
          extensions: ["mid", "midi", "kar", "rmi"]
        },
        "audio/mobile-xmf": {
          source: "iana",
          extensions: ["mxmf"]
        },
        "audio/mp3": {
          compressible: false,
          extensions: ["mp3"]
        },
        "audio/mp4": {
          source: "iana",
          compressible: false,
          extensions: ["m4a", "mp4a"]
        },
        "audio/mp4a-latm": {
          source: "iana"
        },
        "audio/mpa": {
          source: "iana"
        },
        "audio/mpa-robust": {
          source: "iana"
        },
        "audio/mpeg": {
          source: "iana",
          compressible: false,
          extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
        },
        "audio/mpeg4-generic": {
          source: "iana"
        },
        "audio/musepack": {
          source: "apache"
        },
        "audio/ogg": {
          source: "iana",
          compressible: false,
          extensions: ["oga", "ogg", "spx", "opus"]
        },
        "audio/opus": {
          source: "iana"
        },
        "audio/parityfec": {
          source: "iana"
        },
        "audio/pcma": {
          source: "iana"
        },
        "audio/pcma-wb": {
          source: "iana"
        },
        "audio/pcmu": {
          source: "iana"
        },
        "audio/pcmu-wb": {
          source: "iana"
        },
        "audio/prs.sid": {
          source: "iana"
        },
        "audio/qcelp": {
          source: "iana"
        },
        "audio/raptorfec": {
          source: "iana"
        },
        "audio/red": {
          source: "iana"
        },
        "audio/rtp-enc-aescm128": {
          source: "iana"
        },
        "audio/rtp-midi": {
          source: "iana"
        },
        "audio/rtploopback": {
          source: "iana"
        },
        "audio/rtx": {
          source: "iana"
        },
        "audio/s3m": {
          source: "apache",
          extensions: ["s3m"]
        },
        "audio/scip": {
          source: "iana"
        },
        "audio/silk": {
          source: "apache",
          extensions: ["sil"]
        },
        "audio/smv": {
          source: "iana"
        },
        "audio/smv-qcp": {
          source: "iana"
        },
        "audio/smv0": {
          source: "iana"
        },
        "audio/sofa": {
          source: "iana"
        },
        "audio/sp-midi": {
          source: "iana"
        },
        "audio/speex": {
          source: "iana"
        },
        "audio/t140c": {
          source: "iana"
        },
        "audio/t38": {
          source: "iana"
        },
        "audio/telephone-event": {
          source: "iana"
        },
        "audio/tetra_acelp": {
          source: "iana"
        },
        "audio/tetra_acelp_bb": {
          source: "iana"
        },
        "audio/tone": {
          source: "iana"
        },
        "audio/tsvcis": {
          source: "iana"
        },
        "audio/uemclip": {
          source: "iana"
        },
        "audio/ulpfec": {
          source: "iana"
        },
        "audio/usac": {
          source: "iana"
        },
        "audio/vdvi": {
          source: "iana"
        },
        "audio/vmr-wb": {
          source: "iana"
        },
        "audio/vnd.3gpp.iufp": {
          source: "iana"
        },
        "audio/vnd.4sb": {
          source: "iana"
        },
        "audio/vnd.audiokoz": {
          source: "iana"
        },
        "audio/vnd.celp": {
          source: "iana"
        },
        "audio/vnd.cisco.nse": {
          source: "iana"
        },
        "audio/vnd.cmles.radio-events": {
          source: "iana"
        },
        "audio/vnd.cns.anp1": {
          source: "iana"
        },
        "audio/vnd.cns.inf1": {
          source: "iana"
        },
        "audio/vnd.dece.audio": {
          source: "iana",
          extensions: ["uva", "uvva"]
        },
        "audio/vnd.digital-winds": {
          source: "iana",
          extensions: ["eol"]
        },
        "audio/vnd.dlna.adts": {
          source: "iana"
        },
        "audio/vnd.dolby.heaac.1": {
          source: "iana"
        },
        "audio/vnd.dolby.heaac.2": {
          source: "iana"
        },
        "audio/vnd.dolby.mlp": {
          source: "iana"
        },
        "audio/vnd.dolby.mps": {
          source: "iana"
        },
        "audio/vnd.dolby.pl2": {
          source: "iana"
        },
        "audio/vnd.dolby.pl2x": {
          source: "iana"
        },
        "audio/vnd.dolby.pl2z": {
          source: "iana"
        },
        "audio/vnd.dolby.pulse.1": {
          source: "iana"
        },
        "audio/vnd.dra": {
          source: "iana",
          extensions: ["dra"]
        },
        "audio/vnd.dts": {
          source: "iana",
          extensions: ["dts"]
        },
        "audio/vnd.dts.hd": {
          source: "iana",
          extensions: ["dtshd"]
        },
        "audio/vnd.dts.uhd": {
          source: "iana"
        },
        "audio/vnd.dvb.file": {
          source: "iana"
        },
        "audio/vnd.everad.plj": {
          source: "iana"
        },
        "audio/vnd.hns.audio": {
          source: "iana"
        },
        "audio/vnd.lucent.voice": {
          source: "iana",
          extensions: ["lvp"]
        },
        "audio/vnd.ms-playready.media.pya": {
          source: "iana",
          extensions: ["pya"]
        },
        "audio/vnd.nokia.mobile-xmf": {
          source: "iana"
        },
        "audio/vnd.nortel.vbk": {
          source: "iana"
        },
        "audio/vnd.nuera.ecelp4800": {
          source: "iana",
          extensions: ["ecelp4800"]
        },
        "audio/vnd.nuera.ecelp7470": {
          source: "iana",
          extensions: ["ecelp7470"]
        },
        "audio/vnd.nuera.ecelp9600": {
          source: "iana",
          extensions: ["ecelp9600"]
        },
        "audio/vnd.octel.sbc": {
          source: "iana"
        },
        "audio/vnd.presonus.multitrack": {
          source: "iana"
        },
        "audio/vnd.qcelp": {
          source: "iana"
        },
        "audio/vnd.rhetorex.32kadpcm": {
          source: "iana"
        },
        "audio/vnd.rip": {
          source: "iana",
          extensions: ["rip"]
        },
        "audio/vnd.rn-realaudio": {
          compressible: false
        },
        "audio/vnd.sealedmedia.softseal.mpeg": {
          source: "iana"
        },
        "audio/vnd.vmx.cvsd": {
          source: "iana"
        },
        "audio/vnd.wave": {
          compressible: false
        },
        "audio/vorbis": {
          source: "iana",
          compressible: false
        },
        "audio/vorbis-config": {
          source: "iana"
        },
        "audio/wav": {
          compressible: false,
          extensions: ["wav"]
        },
        "audio/wave": {
          compressible: false,
          extensions: ["wav"]
        },
        "audio/webm": {
          source: "apache",
          compressible: false,
          extensions: ["weba"]
        },
        "audio/x-aac": {
          source: "apache",
          compressible: false,
          extensions: ["aac"]
        },
        "audio/x-aiff": {
          source: "apache",
          extensions: ["aif", "aiff", "aifc"]
        },
        "audio/x-caf": {
          source: "apache",
          compressible: false,
          extensions: ["caf"]
        },
        "audio/x-flac": {
          source: "apache",
          extensions: ["flac"]
        },
        "audio/x-m4a": {
          source: "nginx",
          extensions: ["m4a"]
        },
        "audio/x-matroska": {
          source: "apache",
          extensions: ["mka"]
        },
        "audio/x-mpegurl": {
          source: "apache",
          extensions: ["m3u"]
        },
        "audio/x-ms-wax": {
          source: "apache",
          extensions: ["wax"]
        },
        "audio/x-ms-wma": {
          source: "apache",
          extensions: ["wma"]
        },
        "audio/x-pn-realaudio": {
          source: "apache",
          extensions: ["ram", "ra"]
        },
        "audio/x-pn-realaudio-plugin": {
          source: "apache",
          extensions: ["rmp"]
        },
        "audio/x-realaudio": {
          source: "nginx",
          extensions: ["ra"]
        },
        "audio/x-tta": {
          source: "apache"
        },
        "audio/x-wav": {
          source: "apache",
          extensions: ["wav"]
        },
        "audio/xm": {
          source: "apache",
          extensions: ["xm"]
        },
        "chemical/x-cdx": {
          source: "apache",
          extensions: ["cdx"]
        },
        "chemical/x-cif": {
          source: "apache",
          extensions: ["cif"]
        },
        "chemical/x-cmdf": {
          source: "apache",
          extensions: ["cmdf"]
        },
        "chemical/x-cml": {
          source: "apache",
          extensions: ["cml"]
        },
        "chemical/x-csml": {
          source: "apache",
          extensions: ["csml"]
        },
        "chemical/x-pdb": {
          source: "apache"
        },
        "chemical/x-xyz": {
          source: "apache",
          extensions: ["xyz"]
        },
        "font/collection": {
          source: "iana",
          extensions: ["ttc"]
        },
        "font/otf": {
          source: "iana",
          compressible: true,
          extensions: ["otf"]
        },
        "font/sfnt": {
          source: "iana"
        },
        "font/ttf": {
          source: "iana",
          compressible: true,
          extensions: ["ttf"]
        },
        "font/woff": {
          source: "iana",
          extensions: ["woff"]
        },
        "font/woff2": {
          source: "iana",
          extensions: ["woff2"]
        },
        "image/aces": {
          source: "iana",
          extensions: ["exr"]
        },
        "image/apng": {
          compressible: false,
          extensions: ["apng"]
        },
        "image/avci": {
          source: "iana",
          extensions: ["avci"]
        },
        "image/avcs": {
          source: "iana",
          extensions: ["avcs"]
        },
        "image/avif": {
          source: "iana",
          compressible: false,
          extensions: ["avif"]
        },
        "image/bmp": {
          source: "iana",
          compressible: true,
          extensions: ["bmp"]
        },
        "image/cgm": {
          source: "iana",
          extensions: ["cgm"]
        },
        "image/dicom-rle": {
          source: "iana",
          extensions: ["drle"]
        },
        "image/emf": {
          source: "iana",
          extensions: ["emf"]
        },
        "image/fits": {
          source: "iana",
          extensions: ["fits"]
        },
        "image/g3fax": {
          source: "iana",
          extensions: ["g3"]
        },
        "image/gif": {
          source: "iana",
          compressible: false,
          extensions: ["gif"]
        },
        "image/heic": {
          source: "iana",
          extensions: ["heic"]
        },
        "image/heic-sequence": {
          source: "iana",
          extensions: ["heics"]
        },
        "image/heif": {
          source: "iana",
          extensions: ["heif"]
        },
        "image/heif-sequence": {
          source: "iana",
          extensions: ["heifs"]
        },
        "image/hej2k": {
          source: "iana",
          extensions: ["hej2"]
        },
        "image/hsj2": {
          source: "iana",
          extensions: ["hsj2"]
        },
        "image/ief": {
          source: "iana",
          extensions: ["ief"]
        },
        "image/jls": {
          source: "iana",
          extensions: ["jls"]
        },
        "image/jp2": {
          source: "iana",
          compressible: false,
          extensions: ["jp2", "jpg2"]
        },
        "image/jpeg": {
          source: "iana",
          compressible: false,
          extensions: ["jpeg", "jpg", "jpe"]
        },
        "image/jph": {
          source: "iana",
          extensions: ["jph"]
        },
        "image/jphc": {
          source: "iana",
          extensions: ["jhc"]
        },
        "image/jpm": {
          source: "iana",
          compressible: false,
          extensions: ["jpm"]
        },
        "image/jpx": {
          source: "iana",
          compressible: false,
          extensions: ["jpx", "jpf"]
        },
        "image/jxr": {
          source: "iana",
          extensions: ["jxr"]
        },
        "image/jxra": {
          source: "iana",
          extensions: ["jxra"]
        },
        "image/jxrs": {
          source: "iana",
          extensions: ["jxrs"]
        },
        "image/jxs": {
          source: "iana",
          extensions: ["jxs"]
        },
        "image/jxsc": {
          source: "iana",
          extensions: ["jxsc"]
        },
        "image/jxsi": {
          source: "iana",
          extensions: ["jxsi"]
        },
        "image/jxss": {
          source: "iana",
          extensions: ["jxss"]
        },
        "image/ktx": {
          source: "iana",
          extensions: ["ktx"]
        },
        "image/ktx2": {
          source: "iana",
          extensions: ["ktx2"]
        },
        "image/naplps": {
          source: "iana"
        },
        "image/pjpeg": {
          compressible: false
        },
        "image/png": {
          source: "iana",
          compressible: false,
          extensions: ["png"]
        },
        "image/prs.btif": {
          source: "iana",
          extensions: ["btif"]
        },
        "image/prs.pti": {
          source: "iana",
          extensions: ["pti"]
        },
        "image/pwg-raster": {
          source: "iana"
        },
        "image/sgi": {
          source: "apache",
          extensions: ["sgi"]
        },
        "image/svg+xml": {
          source: "iana",
          compressible: true,
          extensions: ["svg", "svgz"]
        },
        "image/t38": {
          source: "iana",
          extensions: ["t38"]
        },
        "image/tiff": {
          source: "iana",
          compressible: false,
          extensions: ["tif", "tiff"]
        },
        "image/tiff-fx": {
          source: "iana",
          extensions: ["tfx"]
        },
        "image/vnd.adobe.photoshop": {
          source: "iana",
          compressible: true,
          extensions: ["psd"]
        },
        "image/vnd.airzip.accelerator.azv": {
          source: "iana",
          extensions: ["azv"]
        },
        "image/vnd.cns.inf2": {
          source: "iana"
        },
        "image/vnd.dece.graphic": {
          source: "iana",
          extensions: ["uvi", "uvvi", "uvg", "uvvg"]
        },
        "image/vnd.djvu": {
          source: "iana",
          extensions: ["djvu", "djv"]
        },
        "image/vnd.dvb.subtitle": {
          source: "iana",
          extensions: ["sub"]
        },
        "image/vnd.dwg": {
          source: "iana",
          extensions: ["dwg"]
        },
        "image/vnd.dxf": {
          source: "iana",
          extensions: ["dxf"]
        },
        "image/vnd.fastbidsheet": {
          source: "iana",
          extensions: ["fbs"]
        },
        "image/vnd.fpx": {
          source: "iana",
          extensions: ["fpx"]
        },
        "image/vnd.fst": {
          source: "iana",
          extensions: ["fst"]
        },
        "image/vnd.fujixerox.edmics-mmr": {
          source: "iana",
          extensions: ["mmr"]
        },
        "image/vnd.fujixerox.edmics-rlc": {
          source: "iana",
          extensions: ["rlc"]
        },
        "image/vnd.globalgraphics.pgb": {
          source: "iana"
        },
        "image/vnd.microsoft.icon": {
          source: "iana",
          compressible: true,
          extensions: ["ico"]
        },
        "image/vnd.mix": {
          source: "iana"
        },
        "image/vnd.mozilla.apng": {
          source: "iana"
        },
        "image/vnd.ms-dds": {
          compressible: true,
          extensions: ["dds"]
        },
        "image/vnd.ms-modi": {
          source: "iana",
          extensions: ["mdi"]
        },
        "image/vnd.ms-photo": {
          source: "apache",
          extensions: ["wdp"]
        },
        "image/vnd.net-fpx": {
          source: "iana",
          extensions: ["npx"]
        },
        "image/vnd.pco.b16": {
          source: "iana",
          extensions: ["b16"]
        },
        "image/vnd.radiance": {
          source: "iana"
        },
        "image/vnd.sealed.png": {
          source: "iana"
        },
        "image/vnd.sealedmedia.softseal.gif": {
          source: "iana"
        },
        "image/vnd.sealedmedia.softseal.jpg": {
          source: "iana"
        },
        "image/vnd.svf": {
          source: "iana"
        },
        "image/vnd.tencent.tap": {
          source: "iana",
          extensions: ["tap"]
        },
        "image/vnd.valve.source.texture": {
          source: "iana",
          extensions: ["vtf"]
        },
        "image/vnd.wap.wbmp": {
          source: "iana",
          extensions: ["wbmp"]
        },
        "image/vnd.xiff": {
          source: "iana",
          extensions: ["xif"]
        },
        "image/vnd.zbrush.pcx": {
          source: "iana",
          extensions: ["pcx"]
        },
        "image/webp": {
          source: "apache",
          extensions: ["webp"]
        },
        "image/wmf": {
          source: "iana",
          extensions: ["wmf"]
        },
        "image/x-3ds": {
          source: "apache",
          extensions: ["3ds"]
        },
        "image/x-cmu-raster": {
          source: "apache",
          extensions: ["ras"]
        },
        "image/x-cmx": {
          source: "apache",
          extensions: ["cmx"]
        },
        "image/x-freehand": {
          source: "apache",
          extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
        },
        "image/x-icon": {
          source: "apache",
          compressible: true,
          extensions: ["ico"]
        },
        "image/x-jng": {
          source: "nginx",
          extensions: ["jng"]
        },
        "image/x-mrsid-image": {
          source: "apache",
          extensions: ["sid"]
        },
        "image/x-ms-bmp": {
          source: "nginx",
          compressible: true,
          extensions: ["bmp"]
        },
        "image/x-pcx": {
          source: "apache",
          extensions: ["pcx"]
        },
        "image/x-pict": {
          source: "apache",
          extensions: ["pic", "pct"]
        },
        "image/x-portable-anymap": {
          source: "apache",
          extensions: ["pnm"]
        },
        "image/x-portable-bitmap": {
          source: "apache",
          extensions: ["pbm"]
        },
        "image/x-portable-graymap": {
          source: "apache",
          extensions: ["pgm"]
        },
        "image/x-portable-pixmap": {
          source: "apache",
          extensions: ["ppm"]
        },
        "image/x-rgb": {
          source: "apache",
          extensions: ["rgb"]
        },
        "image/x-tga": {
          source: "apache",
          extensions: ["tga"]
        },
        "image/x-xbitmap": {
          source: "apache",
          extensions: ["xbm"]
        },
        "image/x-xcf": {
          compressible: false
        },
        "image/x-xpixmap": {
          source: "apache",
          extensions: ["xpm"]
        },
        "image/x-xwindowdump": {
          source: "apache",
          extensions: ["xwd"]
        },
        "message/cpim": {
          source: "iana"
        },
        "message/delivery-status": {
          source: "iana"
        },
        "message/disposition-notification": {
          source: "iana",
          extensions: [
            "disposition-notification"
          ]
        },
        "message/external-body": {
          source: "iana"
        },
        "message/feedback-report": {
          source: "iana"
        },
        "message/global": {
          source: "iana",
          extensions: ["u8msg"]
        },
        "message/global-delivery-status": {
          source: "iana",
          extensions: ["u8dsn"]
        },
        "message/global-disposition-notification": {
          source: "iana",
          extensions: ["u8mdn"]
        },
        "message/global-headers": {
          source: "iana",
          extensions: ["u8hdr"]
        },
        "message/http": {
          source: "iana",
          compressible: false
        },
        "message/imdn+xml": {
          source: "iana",
          compressible: true
        },
        "message/news": {
          source: "iana"
        },
        "message/partial": {
          source: "iana",
          compressible: false
        },
        "message/rfc822": {
          source: "iana",
          compressible: true,
          extensions: ["eml", "mime"]
        },
        "message/s-http": {
          source: "iana"
        },
        "message/sip": {
          source: "iana"
        },
        "message/sipfrag": {
          source: "iana"
        },
        "message/tracking-status": {
          source: "iana"
        },
        "message/vnd.si.simp": {
          source: "iana"
        },
        "message/vnd.wfa.wsc": {
          source: "iana",
          extensions: ["wsc"]
        },
        "model/3mf": {
          source: "iana",
          extensions: ["3mf"]
        },
        "model/e57": {
          source: "iana"
        },
        "model/gltf+json": {
          source: "iana",
          compressible: true,
          extensions: ["gltf"]
        },
        "model/gltf-binary": {
          source: "iana",
          compressible: true,
          extensions: ["glb"]
        },
        "model/iges": {
          source: "iana",
          compressible: false,
          extensions: ["igs", "iges"]
        },
        "model/mesh": {
          source: "iana",
          compressible: false,
          extensions: ["msh", "mesh", "silo"]
        },
        "model/mtl": {
          source: "iana",
          extensions: ["mtl"]
        },
        "model/obj": {
          source: "iana",
          extensions: ["obj"]
        },
        "model/step": {
          source: "iana"
        },
        "model/step+xml": {
          source: "iana",
          compressible: true,
          extensions: ["stpx"]
        },
        "model/step+zip": {
          source: "iana",
          compressible: false,
          extensions: ["stpz"]
        },
        "model/step-xml+zip": {
          source: "iana",
          compressible: false,
          extensions: ["stpxz"]
        },
        "model/stl": {
          source: "iana",
          extensions: ["stl"]
        },
        "model/vnd.collada+xml": {
          source: "iana",
          compressible: true,
          extensions: ["dae"]
        },
        "model/vnd.dwf": {
          source: "iana",
          extensions: ["dwf"]
        },
        "model/vnd.flatland.3dml": {
          source: "iana"
        },
        "model/vnd.gdl": {
          source: "iana",
          extensions: ["gdl"]
        },
        "model/vnd.gs-gdl": {
          source: "apache"
        },
        "model/vnd.gs.gdl": {
          source: "iana"
        },
        "model/vnd.gtw": {
          source: "iana",
          extensions: ["gtw"]
        },
        "model/vnd.moml+xml": {
          source: "iana",
          compressible: true
        },
        "model/vnd.mts": {
          source: "iana",
          extensions: ["mts"]
        },
        "model/vnd.opengex": {
          source: "iana",
          extensions: ["ogex"]
        },
        "model/vnd.parasolid.transmit.binary": {
          source: "iana",
          extensions: ["x_b"]
        },
        "model/vnd.parasolid.transmit.text": {
          source: "iana",
          extensions: ["x_t"]
        },
        "model/vnd.pytha.pyox": {
          source: "iana"
        },
        "model/vnd.rosette.annotated-data-model": {
          source: "iana"
        },
        "model/vnd.sap.vds": {
          source: "iana",
          extensions: ["vds"]
        },
        "model/vnd.usdz+zip": {
          source: "iana",
          compressible: false,
          extensions: ["usdz"]
        },
        "model/vnd.valve.source.compiled-map": {
          source: "iana",
          extensions: ["bsp"]
        },
        "model/vnd.vtu": {
          source: "iana",
          extensions: ["vtu"]
        },
        "model/vrml": {
          source: "iana",
          compressible: false,
          extensions: ["wrl", "vrml"]
        },
        "model/x3d+binary": {
          source: "apache",
          compressible: false,
          extensions: ["x3db", "x3dbz"]
        },
        "model/x3d+fastinfoset": {
          source: "iana",
          extensions: ["x3db"]
        },
        "model/x3d+vrml": {
          source: "apache",
          compressible: false,
          extensions: ["x3dv", "x3dvz"]
        },
        "model/x3d+xml": {
          source: "iana",
          compressible: true,
          extensions: ["x3d", "x3dz"]
        },
        "model/x3d-vrml": {
          source: "iana",
          extensions: ["x3dv"]
        },
        "multipart/alternative": {
          source: "iana",
          compressible: false
        },
        "multipart/appledouble": {
          source: "iana"
        },
        "multipart/byteranges": {
          source: "iana"
        },
        "multipart/digest": {
          source: "iana"
        },
        "multipart/encrypted": {
          source: "iana",
          compressible: false
        },
        "multipart/form-data": {
          source: "iana",
          compressible: false
        },
        "multipart/header-set": {
          source: "iana"
        },
        "multipart/mixed": {
          source: "iana"
        },
        "multipart/multilingual": {
          source: "iana"
        },
        "multipart/parallel": {
          source: "iana"
        },
        "multipart/related": {
          source: "iana",
          compressible: false
        },
        "multipart/report": {
          source: "iana"
        },
        "multipart/signed": {
          source: "iana",
          compressible: false
        },
        "multipart/vnd.bint.med-plus": {
          source: "iana"
        },
        "multipart/voice-message": {
          source: "iana"
        },
        "multipart/x-mixed-replace": {
          source: "iana"
        },
        "text/1d-interleaved-parityfec": {
          source: "iana"
        },
        "text/cache-manifest": {
          source: "iana",
          compressible: true,
          extensions: ["appcache", "manifest"]
        },
        "text/calendar": {
          source: "iana",
          extensions: ["ics", "ifb"]
        },
        "text/calender": {
          compressible: true
        },
        "text/cmd": {
          compressible: true
        },
        "text/coffeescript": {
          extensions: ["coffee", "litcoffee"]
        },
        "text/cql": {
          source: "iana"
        },
        "text/cql-expression": {
          source: "iana"
        },
        "text/cql-identifier": {
          source: "iana"
        },
        "text/css": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["css"]
        },
        "text/csv": {
          source: "iana",
          compressible: true,
          extensions: ["csv"]
        },
        "text/csv-schema": {
          source: "iana"
        },
        "text/directory": {
          source: "iana"
        },
        "text/dns": {
          source: "iana"
        },
        "text/ecmascript": {
          source: "iana"
        },
        "text/encaprtp": {
          source: "iana"
        },
        "text/enriched": {
          source: "iana"
        },
        "text/fhirpath": {
          source: "iana"
        },
        "text/flexfec": {
          source: "iana"
        },
        "text/fwdred": {
          source: "iana"
        },
        "text/gff3": {
          source: "iana"
        },
        "text/grammar-ref-list": {
          source: "iana"
        },
        "text/html": {
          source: "iana",
          compressible: true,
          extensions: ["html", "htm", "shtml"]
        },
        "text/jade": {
          extensions: ["jade"]
        },
        "text/javascript": {
          source: "iana",
          compressible: true
        },
        "text/jcr-cnd": {
          source: "iana"
        },
        "text/jsx": {
          compressible: true,
          extensions: ["jsx"]
        },
        "text/less": {
          compressible: true,
          extensions: ["less"]
        },
        "text/markdown": {
          source: "iana",
          compressible: true,
          extensions: ["markdown", "md"]
        },
        "text/mathml": {
          source: "nginx",
          extensions: ["mml"]
        },
        "text/mdx": {
          compressible: true,
          extensions: ["mdx"]
        },
        "text/mizar": {
          source: "iana"
        },
        "text/n3": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["n3"]
        },
        "text/parameters": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/parityfec": {
          source: "iana"
        },
        "text/plain": {
          source: "iana",
          compressible: true,
          extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
        },
        "text/provenance-notation": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/prs.fallenstein.rst": {
          source: "iana"
        },
        "text/prs.lines.tag": {
          source: "iana",
          extensions: ["dsc"]
        },
        "text/prs.prop.logic": {
          source: "iana"
        },
        "text/raptorfec": {
          source: "iana"
        },
        "text/red": {
          source: "iana"
        },
        "text/rfc822-headers": {
          source: "iana"
        },
        "text/richtext": {
          source: "iana",
          compressible: true,
          extensions: ["rtx"]
        },
        "text/rtf": {
          source: "iana",
          compressible: true,
          extensions: ["rtf"]
        },
        "text/rtp-enc-aescm128": {
          source: "iana"
        },
        "text/rtploopback": {
          source: "iana"
        },
        "text/rtx": {
          source: "iana"
        },
        "text/sgml": {
          source: "iana",
          extensions: ["sgml", "sgm"]
        },
        "text/shaclc": {
          source: "iana"
        },
        "text/shex": {
          source: "iana",
          extensions: ["shex"]
        },
        "text/slim": {
          extensions: ["slim", "slm"]
        },
        "text/spdx": {
          source: "iana",
          extensions: ["spdx"]
        },
        "text/strings": {
          source: "iana"
        },
        "text/stylus": {
          extensions: ["stylus", "styl"]
        },
        "text/t140": {
          source: "iana"
        },
        "text/tab-separated-values": {
          source: "iana",
          compressible: true,
          extensions: ["tsv"]
        },
        "text/troff": {
          source: "iana",
          extensions: ["t", "tr", "roff", "man", "me", "ms"]
        },
        "text/turtle": {
          source: "iana",
          charset: "UTF-8",
          extensions: ["ttl"]
        },
        "text/ulpfec": {
          source: "iana"
        },
        "text/uri-list": {
          source: "iana",
          compressible: true,
          extensions: ["uri", "uris", "urls"]
        },
        "text/vcard": {
          source: "iana",
          compressible: true,
          extensions: ["vcard"]
        },
        "text/vnd.a": {
          source: "iana"
        },
        "text/vnd.abc": {
          source: "iana"
        },
        "text/vnd.ascii-art": {
          source: "iana"
        },
        "text/vnd.curl": {
          source: "iana",
          extensions: ["curl"]
        },
        "text/vnd.curl.dcurl": {
          source: "apache",
          extensions: ["dcurl"]
        },
        "text/vnd.curl.mcurl": {
          source: "apache",
          extensions: ["mcurl"]
        },
        "text/vnd.curl.scurl": {
          source: "apache",
          extensions: ["scurl"]
        },
        "text/vnd.debian.copyright": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/vnd.dmclientscript": {
          source: "iana"
        },
        "text/vnd.dvb.subtitle": {
          source: "iana",
          extensions: ["sub"]
        },
        "text/vnd.esmertec.theme-descriptor": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/vnd.familysearch.gedcom": {
          source: "iana",
          extensions: ["ged"]
        },
        "text/vnd.ficlab.flt": {
          source: "iana"
        },
        "text/vnd.fly": {
          source: "iana",
          extensions: ["fly"]
        },
        "text/vnd.fmi.flexstor": {
          source: "iana",
          extensions: ["flx"]
        },
        "text/vnd.gml": {
          source: "iana"
        },
        "text/vnd.graphviz": {
          source: "iana",
          extensions: ["gv"]
        },
        "text/vnd.hans": {
          source: "iana"
        },
        "text/vnd.hgl": {
          source: "iana"
        },
        "text/vnd.in3d.3dml": {
          source: "iana",
          extensions: ["3dml"]
        },
        "text/vnd.in3d.spot": {
          source: "iana",
          extensions: ["spot"]
        },
        "text/vnd.iptc.newsml": {
          source: "iana"
        },
        "text/vnd.iptc.nitf": {
          source: "iana"
        },
        "text/vnd.latex-z": {
          source: "iana"
        },
        "text/vnd.motorola.reflex": {
          source: "iana"
        },
        "text/vnd.ms-mediapackage": {
          source: "iana"
        },
        "text/vnd.net2phone.commcenter.command": {
          source: "iana"
        },
        "text/vnd.radisys.msml-basic-layout": {
          source: "iana"
        },
        "text/vnd.senx.warpscript": {
          source: "iana"
        },
        "text/vnd.si.uricatalogue": {
          source: "iana"
        },
        "text/vnd.sosi": {
          source: "iana"
        },
        "text/vnd.sun.j2me.app-descriptor": {
          source: "iana",
          charset: "UTF-8",
          extensions: ["jad"]
        },
        "text/vnd.trolltech.linguist": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/vnd.wap.si": {
          source: "iana"
        },
        "text/vnd.wap.sl": {
          source: "iana"
        },
        "text/vnd.wap.wml": {
          source: "iana",
          extensions: ["wml"]
        },
        "text/vnd.wap.wmlscript": {
          source: "iana",
          extensions: ["wmls"]
        },
        "text/vtt": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["vtt"]
        },
        "text/x-asm": {
          source: "apache",
          extensions: ["s", "asm"]
        },
        "text/x-c": {
          source: "apache",
          extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
        },
        "text/x-component": {
          source: "nginx",
          extensions: ["htc"]
        },
        "text/x-fortran": {
          source: "apache",
          extensions: ["f", "for", "f77", "f90"]
        },
        "text/x-gwt-rpc": {
          compressible: true
        },
        "text/x-handlebars-template": {
          extensions: ["hbs"]
        },
        "text/x-java-source": {
          source: "apache",
          extensions: ["java"]
        },
        "text/x-jquery-tmpl": {
          compressible: true
        },
        "text/x-lua": {
          extensions: ["lua"]
        },
        "text/x-markdown": {
          compressible: true,
          extensions: ["mkd"]
        },
        "text/x-nfo": {
          source: "apache",
          extensions: ["nfo"]
        },
        "text/x-opml": {
          source: "apache",
          extensions: ["opml"]
        },
        "text/x-org": {
          compressible: true,
          extensions: ["org"]
        },
        "text/x-pascal": {
          source: "apache",
          extensions: ["p", "pas"]
        },
        "text/x-processing": {
          compressible: true,
          extensions: ["pde"]
        },
        "text/x-sass": {
          extensions: ["sass"]
        },
        "text/x-scss": {
          extensions: ["scss"]
        },
        "text/x-setext": {
          source: "apache",
          extensions: ["etx"]
        },
        "text/x-sfv": {
          source: "apache",
          extensions: ["sfv"]
        },
        "text/x-suse-ymp": {
          compressible: true,
          extensions: ["ymp"]
        },
        "text/x-uuencode": {
          source: "apache",
          extensions: ["uu"]
        },
        "text/x-vcalendar": {
          source: "apache",
          extensions: ["vcs"]
        },
        "text/x-vcard": {
          source: "apache",
          extensions: ["vcf"]
        },
        "text/xml": {
          source: "iana",
          compressible: true,
          extensions: ["xml"]
        },
        "text/xml-external-parsed-entity": {
          source: "iana"
        },
        "text/yaml": {
          compressible: true,
          extensions: ["yaml", "yml"]
        },
        "video/1d-interleaved-parityfec": {
          source: "iana"
        },
        "video/3gpp": {
          source: "iana",
          extensions: ["3gp", "3gpp"]
        },
        "video/3gpp-tt": {
          source: "iana"
        },
        "video/3gpp2": {
          source: "iana",
          extensions: ["3g2"]
        },
        "video/av1": {
          source: "iana"
        },
        "video/bmpeg": {
          source: "iana"
        },
        "video/bt656": {
          source: "iana"
        },
        "video/celb": {
          source: "iana"
        },
        "video/dv": {
          source: "iana"
        },
        "video/encaprtp": {
          source: "iana"
        },
        "video/ffv1": {
          source: "iana"
        },
        "video/flexfec": {
          source: "iana"
        },
        "video/h261": {
          source: "iana",
          extensions: ["h261"]
        },
        "video/h263": {
          source: "iana",
          extensions: ["h263"]
        },
        "video/h263-1998": {
          source: "iana"
        },
        "video/h263-2000": {
          source: "iana"
        },
        "video/h264": {
          source: "iana",
          extensions: ["h264"]
        },
        "video/h264-rcdo": {
          source: "iana"
        },
        "video/h264-svc": {
          source: "iana"
        },
        "video/h265": {
          source: "iana"
        },
        "video/iso.segment": {
          source: "iana",
          extensions: ["m4s"]
        },
        "video/jpeg": {
          source: "iana",
          extensions: ["jpgv"]
        },
        "video/jpeg2000": {
          source: "iana"
        },
        "video/jpm": {
          source: "apache",
          extensions: ["jpm", "jpgm"]
        },
        "video/jxsv": {
          source: "iana"
        },
        "video/mj2": {
          source: "iana",
          extensions: ["mj2", "mjp2"]
        },
        "video/mp1s": {
          source: "iana"
        },
        "video/mp2p": {
          source: "iana"
        },
        "video/mp2t": {
          source: "iana",
          extensions: ["ts"]
        },
        "video/mp4": {
          source: "iana",
          compressible: false,
          extensions: ["mp4", "mp4v", "mpg4"]
        },
        "video/mp4v-es": {
          source: "iana"
        },
        "video/mpeg": {
          source: "iana",
          compressible: false,
          extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
        },
        "video/mpeg4-generic": {
          source: "iana"
        },
        "video/mpv": {
          source: "iana"
        },
        "video/nv": {
          source: "iana"
        },
        "video/ogg": {
          source: "iana",
          compressible: false,
          extensions: ["ogv"]
        },
        "video/parityfec": {
          source: "iana"
        },
        "video/pointer": {
          source: "iana"
        },
        "video/quicktime": {
          source: "iana",
          compressible: false,
          extensions: ["qt", "mov"]
        },
        "video/raptorfec": {
          source: "iana"
        },
        "video/raw": {
          source: "iana"
        },
        "video/rtp-enc-aescm128": {
          source: "iana"
        },
        "video/rtploopback": {
          source: "iana"
        },
        "video/rtx": {
          source: "iana"
        },
        "video/scip": {
          source: "iana"
        },
        "video/smpte291": {
          source: "iana"
        },
        "video/smpte292m": {
          source: "iana"
        },
        "video/ulpfec": {
          source: "iana"
        },
        "video/vc1": {
          source: "iana"
        },
        "video/vc2": {
          source: "iana"
        },
        "video/vnd.cctv": {
          source: "iana"
        },
        "video/vnd.dece.hd": {
          source: "iana",
          extensions: ["uvh", "uvvh"]
        },
        "video/vnd.dece.mobile": {
          source: "iana",
          extensions: ["uvm", "uvvm"]
        },
        "video/vnd.dece.mp4": {
          source: "iana"
        },
        "video/vnd.dece.pd": {
          source: "iana",
          extensions: ["uvp", "uvvp"]
        },
        "video/vnd.dece.sd": {
          source: "iana",
          extensions: ["uvs", "uvvs"]
        },
        "video/vnd.dece.video": {
          source: "iana",
          extensions: ["uvv", "uvvv"]
        },
        "video/vnd.directv.mpeg": {
          source: "iana"
        },
        "video/vnd.directv.mpeg-tts": {
          source: "iana"
        },
        "video/vnd.dlna.mpeg-tts": {
          source: "iana"
        },
        "video/vnd.dvb.file": {
          source: "iana",
          extensions: ["dvb"]
        },
        "video/vnd.fvt": {
          source: "iana",
          extensions: ["fvt"]
        },
        "video/vnd.hns.video": {
          source: "iana"
        },
        "video/vnd.iptvforum.1dparityfec-1010": {
          source: "iana"
        },
        "video/vnd.iptvforum.1dparityfec-2005": {
          source: "iana"
        },
        "video/vnd.iptvforum.2dparityfec-1010": {
          source: "iana"
        },
        "video/vnd.iptvforum.2dparityfec-2005": {
          source: "iana"
        },
        "video/vnd.iptvforum.ttsavc": {
          source: "iana"
        },
        "video/vnd.iptvforum.ttsmpeg2": {
          source: "iana"
        },
        "video/vnd.motorola.video": {
          source: "iana"
        },
        "video/vnd.motorola.videop": {
          source: "iana"
        },
        "video/vnd.mpegurl": {
          source: "iana",
          extensions: ["mxu", "m4u"]
        },
        "video/vnd.ms-playready.media.pyv": {
          source: "iana",
          extensions: ["pyv"]
        },
        "video/vnd.nokia.interleaved-multimedia": {
          source: "iana"
        },
        "video/vnd.nokia.mp4vr": {
          source: "iana"
        },
        "video/vnd.nokia.videovoip": {
          source: "iana"
        },
        "video/vnd.objectvideo": {
          source: "iana"
        },
        "video/vnd.radgamettools.bink": {
          source: "iana"
        },
        "video/vnd.radgamettools.smacker": {
          source: "iana"
        },
        "video/vnd.sealed.mpeg1": {
          source: "iana"
        },
        "video/vnd.sealed.mpeg4": {
          source: "iana"
        },
        "video/vnd.sealed.swf": {
          source: "iana"
        },
        "video/vnd.sealedmedia.softseal.mov": {
          source: "iana"
        },
        "video/vnd.uvvu.mp4": {
          source: "iana",
          extensions: ["uvu", "uvvu"]
        },
        "video/vnd.vivo": {
          source: "iana",
          extensions: ["viv"]
        },
        "video/vnd.youtube.yt": {
          source: "iana"
        },
        "video/vp8": {
          source: "iana"
        },
        "video/vp9": {
          source: "iana"
        },
        "video/webm": {
          source: "apache",
          compressible: false,
          extensions: ["webm"]
        },
        "video/x-f4v": {
          source: "apache",
          extensions: ["f4v"]
        },
        "video/x-fli": {
          source: "apache",
          extensions: ["fli"]
        },
        "video/x-flv": {
          source: "apache",
          compressible: false,
          extensions: ["flv"]
        },
        "video/x-m4v": {
          source: "apache",
          extensions: ["m4v"]
        },
        "video/x-matroska": {
          source: "apache",
          compressible: false,
          extensions: ["mkv", "mk3d", "mks"]
        },
        "video/x-mng": {
          source: "apache",
          extensions: ["mng"]
        },
        "video/x-ms-asf": {
          source: "apache",
          extensions: ["asf", "asx"]
        },
        "video/x-ms-vob": {
          source: "apache",
          extensions: ["vob"]
        },
        "video/x-ms-wm": {
          source: "apache",
          extensions: ["wm"]
        },
        "video/x-ms-wmv": {
          source: "apache",
          compressible: false,
          extensions: ["wmv"]
        },
        "video/x-ms-wmx": {
          source: "apache",
          extensions: ["wmx"]
        },
        "video/x-ms-wvx": {
          source: "apache",
          extensions: ["wvx"]
        },
        "video/x-msvideo": {
          source: "apache",
          extensions: ["avi"]
        },
        "video/x-sgi-movie": {
          source: "apache",
          extensions: ["movie"]
        },
        "video/x-smv": {
          source: "apache",
          extensions: ["smv"]
        },
        "x-conference/x-cooltalk": {
          source: "apache",
          extensions: ["ice"]
        },
        "x-shader/x-fragment": {
          compressible: true
        },
        "x-shader/x-vertex": {
          compressible: true
        }
      };
    }
  });

  // node_modules/mime-db/index.js
  var require_mime_db = __commonJS({
    "node_modules/mime-db/index.js"(exports, module) {
      init_mithril_shim();
      module.exports = require_db();
    }
  });

  // node_modules/path/index.js
  var require_path = __commonJS({
    "node_modules/path/index.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      function assertPath(path3) {
        if (typeof path3 !== "string") {
          throw new TypeError("Path must be a string. Received " + JSON.stringify(path3));
        }
      }
      function normalizeStringPosix(path3, allowAboveRoot) {
        var res = "";
        var lastSegmentLength = 0;
        var lastSlash = -1;
        var dots = 0;
        var code;
        for (var i = 0; i <= path3.length; ++i) {
          if (i < path3.length)
            code = path3.charCodeAt(i);
          else if (code === 47)
            break;
          else
            code = 47;
          if (code === 47) {
            if (lastSlash === i - 1 || dots === 1) {
            } else if (lastSlash !== i - 1 && dots === 2) {
              if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                if (res.length > 2) {
                  var lastSlashIndex = res.lastIndexOf("/");
                  if (lastSlashIndex !== res.length - 1) {
                    if (lastSlashIndex === -1) {
                      res = "";
                      lastSegmentLength = 0;
                    } else {
                      res = res.slice(0, lastSlashIndex);
                      lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                    }
                    lastSlash = i;
                    dots = 0;
                    continue;
                  }
                } else if (res.length === 2 || res.length === 1) {
                  res = "";
                  lastSegmentLength = 0;
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              }
              if (allowAboveRoot) {
                if (res.length > 0)
                  res += "/..";
                else
                  res = "..";
                lastSegmentLength = 2;
              }
            } else {
              if (res.length > 0)
                res += "/" + path3.slice(lastSlash + 1, i);
              else
                res = path3.slice(lastSlash + 1, i);
              lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
          } else if (code === 46 && dots !== -1) {
            ++dots;
          } else {
            dots = -1;
          }
        }
        return res;
      }
      function _format(sep, pathObject) {
        var dir = pathObject.dir || pathObject.root;
        var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
        if (!dir) {
          return base;
        }
        if (dir === pathObject.root) {
          return dir + base;
        }
        return dir + sep + base;
      }
      var posix = {
        resolve: function resolve() {
          var resolvedPath = "";
          var resolvedAbsolute = false;
          var cwd;
          for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path3;
            if (i >= 0)
              path3 = arguments[i];
            else {
              if (cwd === void 0)
                cwd = process.cwd();
              path3 = cwd;
            }
            assertPath(path3);
            if (path3.length === 0) {
              continue;
            }
            resolvedPath = path3 + "/" + resolvedPath;
            resolvedAbsolute = path3.charCodeAt(0) === 47;
          }
          resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
          if (resolvedAbsolute) {
            if (resolvedPath.length > 0)
              return "/" + resolvedPath;
            else
              return "/";
          } else if (resolvedPath.length > 0) {
            return resolvedPath;
          } else {
            return ".";
          }
        },
        normalize: function normalize(path3) {
          assertPath(path3);
          if (path3.length === 0)
            return ".";
          var isAbsolute = path3.charCodeAt(0) === 47;
          var trailingSeparator = path3.charCodeAt(path3.length - 1) === 47;
          path3 = normalizeStringPosix(path3, !isAbsolute);
          if (path3.length === 0 && !isAbsolute)
            path3 = ".";
          if (path3.length > 0 && trailingSeparator)
            path3 += "/";
          if (isAbsolute)
            return "/" + path3;
          return path3;
        },
        isAbsolute: function isAbsolute(path3) {
          assertPath(path3);
          return path3.length > 0 && path3.charCodeAt(0) === 47;
        },
        join: function join() {
          if (arguments.length === 0)
            return ".";
          var joined;
          for (var i = 0; i < arguments.length; ++i) {
            var arg = arguments[i];
            assertPath(arg);
            if (arg.length > 0) {
              if (joined === void 0)
                joined = arg;
              else
                joined += "/" + arg;
            }
          }
          if (joined === void 0)
            return ".";
          return posix.normalize(joined);
        },
        relative: function relative(from, to) {
          assertPath(from);
          assertPath(to);
          if (from === to)
            return "";
          from = posix.resolve(from);
          to = posix.resolve(to);
          if (from === to)
            return "";
          var fromStart = 1;
          for (; fromStart < from.length; ++fromStart) {
            if (from.charCodeAt(fromStart) !== 47)
              break;
          }
          var fromEnd = from.length;
          var fromLen = fromEnd - fromStart;
          var toStart = 1;
          for (; toStart < to.length; ++toStart) {
            if (to.charCodeAt(toStart) !== 47)
              break;
          }
          var toEnd = to.length;
          var toLen = toEnd - toStart;
          var length = fromLen < toLen ? fromLen : toLen;
          var lastCommonSep = -1;
          var i = 0;
          for (; i <= length; ++i) {
            if (i === length) {
              if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                  return to.slice(toStart + i + 1);
                } else if (i === 0) {
                  return to.slice(toStart + i);
                }
              } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                  lastCommonSep = i;
                } else if (i === 0) {
                  lastCommonSep = 0;
                }
              }
              break;
            }
            var fromCode = from.charCodeAt(fromStart + i);
            var toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode)
              break;
            else if (fromCode === 47)
              lastCommonSep = i;
          }
          var out = "";
          for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === 47) {
              if (out.length === 0)
                out += "..";
              else
                out += "/..";
            }
          }
          if (out.length > 0)
            return out + to.slice(toStart + lastCommonSep);
          else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === 47)
              ++toStart;
            return to.slice(toStart);
          }
        },
        _makeLong: function _makeLong(path3) {
          return path3;
        },
        dirname: function dirname(path3) {
          assertPath(path3);
          if (path3.length === 0)
            return ".";
          var code = path3.charCodeAt(0);
          var hasRoot = code === 47;
          var end = -1;
          var matchedSlash = true;
          for (var i = path3.length - 1; i >= 1; --i) {
            code = path3.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                end = i;
                break;
              }
            } else {
              matchedSlash = false;
            }
          }
          if (end === -1)
            return hasRoot ? "/" : ".";
          if (hasRoot && end === 1)
            return "//";
          return path3.slice(0, end);
        },
        basename: function basename(path3, ext) {
          if (ext !== void 0 && typeof ext !== "string")
            throw new TypeError('"ext" argument must be a string');
          assertPath(path3);
          var start = 0;
          var end = -1;
          var matchedSlash = true;
          var i;
          if (ext !== void 0 && ext.length > 0 && ext.length <= path3.length) {
            if (ext.length === path3.length && ext === path3)
              return "";
            var extIdx = ext.length - 1;
            var firstNonSlashEnd = -1;
            for (i = path3.length - 1; i >= 0; --i) {
              var code = path3.charCodeAt(i);
              if (code === 47) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  matchedSlash = false;
                  firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      end = i;
                    }
                  } else {
                    extIdx = -1;
                    end = firstNonSlashEnd;
                  }
                }
              }
            }
            if (start === end)
              end = firstNonSlashEnd;
            else if (end === -1)
              end = path3.length;
            return path3.slice(start, end);
          } else {
            for (i = path3.length - 1; i >= 0; --i) {
              if (path3.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
            }
            if (end === -1)
              return "";
            return path3.slice(start, end);
          }
        },
        extname: function extname(path3) {
          assertPath(path3);
          var startDot = -1;
          var startPart = 0;
          var end = -1;
          var matchedSlash = true;
          var preDotState = 0;
          for (var i = path3.length - 1; i >= 0; --i) {
            var code = path3.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === 46) {
              if (startDot === -1)
                startDot = i;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
          }
          return path3.slice(startDot, end);
        },
        format: function format(pathObject) {
          if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
          }
          return _format("/", pathObject);
        },
        parse: function parse(path3) {
          assertPath(path3);
          var ret = { root: "", dir: "", base: "", ext: "", name: "" };
          if (path3.length === 0)
            return ret;
          var code = path3.charCodeAt(0);
          var isAbsolute = code === 47;
          var start;
          if (isAbsolute) {
            ret.root = "/";
            start = 1;
          } else {
            start = 0;
          }
          var startDot = -1;
          var startPart = 0;
          var end = -1;
          var matchedSlash = true;
          var i = path3.length - 1;
          var preDotState = 0;
          for (; i >= start; --i) {
            code = path3.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === 46) {
              if (startDot === -1)
                startDot = i;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
              if (startPart === 0 && isAbsolute)
                ret.base = ret.name = path3.slice(1, end);
              else
                ret.base = ret.name = path3.slice(startPart, end);
            }
          } else {
            if (startPart === 0 && isAbsolute) {
              ret.name = path3.slice(1, startDot);
              ret.base = path3.slice(1, end);
            } else {
              ret.name = path3.slice(startPart, startDot);
              ret.base = path3.slice(startPart, end);
            }
            ret.ext = path3.slice(startDot, end);
          }
          if (startPart > 0)
            ret.dir = path3.slice(0, startPart - 1);
          else if (isAbsolute)
            ret.dir = "/";
          return ret;
        },
        sep: "/",
        delimiter: ":",
        win32: null,
        posix: null
      };
      posix.posix = posix;
      module.exports = posix;
    }
  });

  // node_modules/mime-types/index.js
  var require_mime_types = __commonJS({
    "node_modules/mime-types/index.js"(exports) {
      "use strict";
      init_mithril_shim();
      var db = require_mime_db();
      var extname = require_path().extname;
      var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
      var TEXT_TYPE_REGEXP = /^text\//i;
      exports.charset = charset;
      exports.charsets = { lookup: charset };
      exports.contentType = contentType;
      exports.extension = extension;
      exports.extensions = /* @__PURE__ */ Object.create(null);
      exports.lookup = lookup2;
      exports.types = /* @__PURE__ */ Object.create(null);
      populateMaps(exports.extensions, exports.types);
      function charset(type) {
        if (!type || typeof type !== "string") {
          return false;
        }
        var match = EXTRACT_TYPE_REGEXP.exec(type);
        var mime = match && db[match[1].toLowerCase()];
        if (mime && mime.charset) {
          return mime.charset;
        }
        if (match && TEXT_TYPE_REGEXP.test(match[1])) {
          return "UTF-8";
        }
        return false;
      }
      function contentType(str) {
        if (!str || typeof str !== "string") {
          return false;
        }
        var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
        if (!mime) {
          return false;
        }
        if (mime.indexOf("charset") === -1) {
          var charset2 = exports.charset(mime);
          if (charset2)
            mime += "; charset=" + charset2.toLowerCase();
        }
        return mime;
      }
      function extension(type) {
        if (!type || typeof type !== "string") {
          return false;
        }
        var match = EXTRACT_TYPE_REGEXP.exec(type);
        var exts = match && exports.extensions[match[1].toLowerCase()];
        if (!exts || !exts.length) {
          return false;
        }
        return exts[0];
      }
      function lookup2(path3) {
        if (!path3 || typeof path3 !== "string") {
          return false;
        }
        var extension2 = extname("x." + path3).toLowerCase().substr(1);
        if (!extension2) {
          return false;
        }
        return exports.types[extension2] || false;
      }
      function populateMaps(extensions, types) {
        var preference = ["nginx", "apache", void 0, "iana"];
        Object.keys(db).forEach(function forEachMimeType(type) {
          var mime = db[type];
          var exts = mime.extensions;
          if (!exts || !exts.length) {
            return;
          }
          extensions[type] = exts;
          for (var i = 0; i < exts.length; i++) {
            var extension2 = exts[i];
            if (types[extension2]) {
              var from = preference.indexOf(db[types[extension2]].source);
              var to = preference.indexOf(mime.source);
              if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
                continue;
              }
            }
            types[extension2] = type;
          }
        });
      }
    }
  });

  // node_modules/events/events.js
  var require_events = __commonJS({
    "node_modules/events/events.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      var R = typeof Reflect === "object" ? Reflect : null;
      var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R && typeof R.ownKeys === "function") {
        ReflectOwnKeys = R.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn)
          console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
        return value !== value;
      };
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      module.exports = EventEmitter;
      module.exports.once = once;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._eventsCount = 0;
      EventEmitter.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }
      Object.defineProperty(EventEmitter, "defaultMaxListeners", {
        enumerable: true,
        get: function() {
          return defaultMaxListeners;
        },
        set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter.init = function() {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
        }
        this._maxListeners = n;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter.prototype.emit = function emit(type) {
        var args = [];
        for (var i = 1; i < arguments.length; i++)
          args.push(arguments[i]);
        var doError = type === "error";
        var events = this._events;
        if (events !== void 0)
          doError = doError && events.error === void 0;
        else if (!doError)
          return false;
        if (doError) {
          var er;
          if (args.length > 0)
            er = args[0];
          if (er instanceof Error) {
            throw er;
          }
          var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
          err.context = er;
          throw err;
        }
        var handler = events[type];
        if (handler === void 0)
          return false;
        if (typeof handler === "function") {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            ReflectApply(listeners[i], this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m3;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === void 0) {
          events = target._events = /* @__PURE__ */ Object.create(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener !== void 0) {
            target.emit(
              "newListener",
              type,
              listener.listener ? listener.listener : listener
            );
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === void 0) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
          m3 = _getMaxListeners(target);
          if (m3 > 0 && existing.length > m3 && !existing.warned) {
            existing.warned = true;
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
          }
        }
        return target;
      }
      EventEmitter.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0)
            return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter.prototype.once = function once2(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === void 0)
          return this;
        list = events[type];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener !== void 0)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (events === void 0)
          return this;
        if (events.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === "removeListener")
              continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners !== void 0) {
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === void 0)
          return [];
        var evlistener = events[type];
        if (evlistener === void 0)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== void 0) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener !== void 0) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n) {
        var copy = new Array(n);
        for (var i = 0; i < n; ++i)
          copy[i] = arr[i];
        return copy;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++)
          list[index] = list[index + 1];
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      function once(emitter, name) {
        return new Promise(function(resolve, reject) {
          function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
          }
          function resolver() {
            if (typeof emitter.removeListener === "function") {
              emitter.removeListener("error", errorListener);
            }
            resolve([].slice.call(arguments));
          }
          ;
          eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
          if (name !== "error") {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
          }
        });
      }
      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === "function") {
          eventTargetAgnosticAddListener(emitter, "error", handler, flags);
        }
      }
      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if (typeof emitter.on === "function") {
          if (flags.once) {
            emitter.once(name, listener);
          } else {
            emitter.on(name, listener);
          }
        } else if (typeof emitter.addEventListener === "function") {
          emitter.addEventListener(name, function wrapListener(arg) {
            if (flags.once) {
              emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
          });
        } else {
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
        }
      }
    }
  });

  // node_modules/sharedb/lib/emitter.js
  var require_emitter = __commonJS({
    "node_modules/sharedb/lib/emitter.js"(exports) {
      init_mithril_shim();
      var EventEmitter = require_events().EventEmitter;
      exports.EventEmitter = EventEmitter;
      exports.mixin = mixin;
      function mixin(Constructor) {
        for (var key in EventEmitter.prototype) {
          Constructor.prototype[key] = EventEmitter.prototype[key];
        }
      }
    }
  });

  // node_modules/sharedb/lib/logger/logger.js
  var require_logger = __commonJS({
    "node_modules/sharedb/lib/logger/logger.js"(exports, module) {
      init_mithril_shim();
      var SUPPORTED_METHODS = [
        "info",
        "warn",
        "error"
      ];
      function Logger() {
        var defaultMethods = {};
        SUPPORTED_METHODS.forEach(function(method) {
          defaultMethods[method] = console[method].bind(console);
        });
        this.setMethods(defaultMethods);
      }
      module.exports = Logger;
      Logger.prototype.setMethods = function(overrides) {
        overrides = overrides || {};
        var logger = this;
        SUPPORTED_METHODS.forEach(function(method) {
          if (typeof overrides[method] === "function") {
            logger[method] = overrides[method];
          }
        });
      };
    }
  });

  // node_modules/sharedb/lib/logger/index.js
  var require_logger2 = __commonJS({
    "node_modules/sharedb/lib/logger/index.js"(exports, module) {
      init_mithril_shim();
      var Logger = require_logger();
      var logger = new Logger();
      module.exports = logger;
    }
  });

  // node_modules/sharedb/lib/error.js
  var require_error = __commonJS({
    "node_modules/sharedb/lib/error.js"(exports, module) {
      init_mithril_shim();
      function ShareDBError(code, message) {
        this.code = code;
        this.message = message || "";
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, ShareDBError);
        } else {
          this.stack = new Error().stack;
        }
      }
      ShareDBError.prototype = Object.create(Error.prototype);
      ShareDBError.prototype.constructor = ShareDBError;
      ShareDBError.prototype.name = "ShareDBError";
      ShareDBError.CODES = {
        ERR_APPLY_OP_VERSION_DOES_NOT_MATCH_SNAPSHOT: "ERR_APPLY_OP_VERSION_DOES_NOT_MATCH_SNAPSHOT",
        ERR_APPLY_SNAPSHOT_NOT_PROVIDED: "ERR_APPLY_SNAPSHOT_NOT_PROVIDED",
        ERR_FIXUP_IS_ONLY_VALID_ON_APPLY: "ERR_FIXUP_IS_ONLY_VALID_ON_APPLY",
        ERR_CANNOT_FIXUP_DELETION: "ERR_CANNOT_FIXUP_DELETION",
        ERR_CLIENT_ID_BADLY_FORMED: "ERR_CLIENT_ID_BADLY_FORMED",
        ERR_CANNOT_PING_OFFLINE: "ERR_CANNOT_PING_OFFLINE",
        ERR_CONNECTION_SEQ_INTEGER_OVERFLOW: "ERR_CONNECTION_SEQ_INTEGER_OVERFLOW",
        ERR_CONNECTION_STATE_TRANSITION_INVALID: "ERR_CONNECTION_STATE_TRANSITION_INVALID",
        ERR_DATABASE_ADAPTER_NOT_FOUND: "ERR_DATABASE_ADAPTER_NOT_FOUND",
        ERR_DATABASE_DOES_NOT_SUPPORT_SUBSCRIBE: "ERR_DATABASE_DOES_NOT_SUPPORT_SUBSCRIBE",
        ERR_DATABASE_METHOD_NOT_IMPLEMENTED: "ERR_DATABASE_METHOD_NOT_IMPLEMENTED",
        ERR_DEFAULT_TYPE_MISMATCH: "ERR_DEFAULT_TYPE_MISMATCH",
        ERR_DOC_MISSING_VERSION: "ERR_DOC_MISSING_VERSION",
        ERR_DOC_ALREADY_CREATED: "ERR_DOC_ALREADY_CREATED",
        ERR_DOC_DOES_NOT_EXIST: "ERR_DOC_DOES_NOT_EXIST",
        ERR_DOC_TYPE_NOT_RECOGNIZED: "ERR_DOC_TYPE_NOT_RECOGNIZED",
        ERR_DOC_WAS_DELETED: "ERR_DOC_WAS_DELETED",
        ERR_INFLIGHT_OP_MISSING: "ERR_INFLIGHT_OP_MISSING",
        ERR_INGESTED_SNAPSHOT_HAS_NO_VERSION: "ERR_INGESTED_SNAPSHOT_HAS_NO_VERSION",
        ERR_MAX_SUBMIT_RETRIES_EXCEEDED: "ERR_MAX_SUBMIT_RETRIES_EXCEEDED",
        ERR_MESSAGE_BADLY_FORMED: "ERR_MESSAGE_BADLY_FORMED",
        ERR_MILESTONE_ARGUMENT_INVALID: "ERR_MILESTONE_ARGUMENT_INVALID",
        ERR_OP_ALREADY_SUBMITTED: "ERR_OP_ALREADY_SUBMITTED",
        ERR_OP_NOT_ALLOWED_IN_PROJECTION: "ERR_OP_NOT_ALLOWED_IN_PROJECTION",
        ERR_OP_SUBMIT_REJECTED: "ERR_OP_SUBMIT_REJECTED",
        ERR_PENDING_OP_REMOVED_BY_OP_SUBMIT_REJECTED: "ERR_PENDING_OP_REMOVED_BY_OP_SUBMIT_REJECTED",
        ERR_HARD_ROLLBACK_FETCH_FAILED: "ERR_HARD_ROLLBACK_FETCH_FAILED",
        ERR_OP_VERSION_MISMATCH_AFTER_TRANSFORM: "ERR_OP_VERSION_MISMATCH_AFTER_TRANSFORM",
        ERR_OP_VERSION_MISMATCH_DURING_TRANSFORM: "ERR_OP_VERSION_MISMATCH_DURING_TRANSFORM",
        ERR_OP_VERSION_NEWER_THAN_CURRENT_SNAPSHOT: "ERR_OP_VERSION_NEWER_THAN_CURRENT_SNAPSHOT",
        ERR_OT_LEGACY_JSON0_OP_CANNOT_BE_NORMALIZED: "ERR_OT_LEGACY_JSON0_OP_CANNOT_BE_NORMALIZED",
        ERR_OT_OP_BADLY_FORMED: "ERR_OT_OP_BADLY_FORMED",
        ERR_OT_OP_NOT_APPLIED: "ERR_OT_OP_NOT_APPLIED",
        ERR_OT_OP_NOT_PROVIDED: "ERR_OT_OP_NOT_PROVIDED",
        ERR_PRESENCE_TRANSFORM_FAILED: "ERR_PRESENCE_TRANSFORM_FAILED",
        ERR_PROTOCOL_VERSION_NOT_SUPPORTED: "ERR_PROTOCOL_VERSION_NOT_SUPPORTED",
        ERR_QUERY_CHANNEL_MISSING: "ERR_QUERY_CHANNEL_MISSING",
        ERR_QUERY_EMITTER_LISTENER_NOT_ASSIGNED: "ERR_QUERY_EMITTER_LISTENER_NOT_ASSIGNED",
        ERR_SNAPSHOT_READ_SILENT_REJECTION: "ERR_SNAPSHOT_READ_SILENT_REJECTION",
        ERR_SNAPSHOT_READS_REJECTED: "ERR_SNAPSHOT_READS_REJECTED",
        ERR_SUBMIT_TRANSFORM_OPS_NOT_FOUND: "ERR_SUBMIT_TRANSFORM_OPS_NOT_FOUND",
        ERR_TYPE_CANNOT_BE_PROJECTED: "ERR_TYPE_CANNOT_BE_PROJECTED",
        ERR_TYPE_DOES_NOT_SUPPORT_COMPOSE: "ERR_TYPE_DOES_NOT_SUPPORT_COMPOSE",
        ERR_TYPE_DOES_NOT_SUPPORT_PRESENCE: "ERR_TYPE_DOES_NOT_SUPPORT_PRESENCE",
        ERR_UNKNOWN_ERROR: "ERR_UNKNOWN_ERROR"
      };
      module.exports = ShareDBError;
    }
  });

  // node_modules/ot-json0/lib/bootstrapTransform.js
  var require_bootstrapTransform = __commonJS({
    "node_modules/ot-json0/lib/bootstrapTransform.js"(exports, module) {
      init_mithril_shim();
      module.exports = bootstrapTransform;
      function bootstrapTransform(type, transformComponent, checkValidOp, append) {
        var transformComponentX = function(left, right, destLeft, destRight) {
          transformComponent(destLeft, left, right, "left");
          transformComponent(destRight, right, left, "right");
        };
        var transformX = type.transformX = function(leftOp, rightOp) {
          checkValidOp(leftOp);
          checkValidOp(rightOp);
          var newRightOp = [];
          for (var i = 0; i < rightOp.length; i++) {
            var rightComponent = rightOp[i];
            var newLeftOp = [];
            var k = 0;
            while (k < leftOp.length) {
              var nextC = [];
              transformComponentX(leftOp[k], rightComponent, newLeftOp, nextC);
              k++;
              if (nextC.length === 1) {
                rightComponent = nextC[0];
              } else if (nextC.length === 0) {
                for (var j = k; j < leftOp.length; j++) {
                  append(newLeftOp, leftOp[j]);
                }
                rightComponent = null;
                break;
              } else {
                var pair = transformX(leftOp.slice(k), nextC);
                for (var l = 0; l < pair[0].length; l++) {
                  append(newLeftOp, pair[0][l]);
                }
                for (var r = 0; r < pair[1].length; r++) {
                  append(newRightOp, pair[1][r]);
                }
                rightComponent = null;
                break;
              }
            }
            if (rightComponent != null) {
              append(newRightOp, rightComponent);
            }
            leftOp = newLeftOp;
          }
          return [leftOp, newRightOp];
        };
        type.transform = function(op, otherOp, type2) {
          if (!(type2 === "left" || type2 === "right"))
            throw new Error("type must be 'left' or 'right'");
          if (otherOp.length === 0)
            return op;
          if (op.length === 1 && otherOp.length === 1)
            return transformComponent([], op[0], otherOp[0], type2);
          if (type2 === "left")
            return transformX(op, otherOp)[0];
          else
            return transformX(otherOp, op)[1];
        };
      }
    }
  });

  // node_modules/ot-json0/lib/text0.js
  var require_text0 = __commonJS({
    "node_modules/ot-json0/lib/text0.js"(exports, module) {
      init_mithril_shim();
      var text = module.exports = {
        name: "text0",
        uri: "http://sharejs.org/types/textv0",
        create: function(initial) {
          if (initial != null && typeof initial !== "string") {
            throw new Error("Initial data must be a string");
          }
          return initial || "";
        }
      };
      var strInject = function(s1, pos, s2) {
        return s1.slice(0, pos) + s2 + s1.slice(pos);
      };
      var checkValidComponent = function(c) {
        if (typeof c.p !== "number")
          throw new Error("component missing position field");
        if (typeof c.i === "string" === (typeof c.d === "string"))
          throw new Error("component needs an i or d field");
        if (c.p < 0)
          throw new Error("position cannot be negative");
      };
      var checkValidOp = function(op) {
        for (var i = 0; i < op.length; i++) {
          checkValidComponent(op[i]);
        }
      };
      text.apply = function(snapshot, op) {
        var deleted;
        checkValidOp(op);
        for (var i = 0; i < op.length; i++) {
          var component = op[i];
          if (component.i != null) {
            snapshot = strInject(snapshot, component.p, component.i);
          } else {
            deleted = snapshot.slice(component.p, component.p + component.d.length);
            if (component.d !== deleted)
              throw new Error("Delete component '" + component.d + "' does not match deleted text '" + deleted + "'");
            snapshot = snapshot.slice(0, component.p) + snapshot.slice(component.p + component.d.length);
          }
        }
        return snapshot;
      };
      var append = text._append = function(newOp, c) {
        if (c.i === "" || c.d === "")
          return;
        if (newOp.length === 0) {
          newOp.push(c);
        } else {
          var last = newOp[newOp.length - 1];
          if (last.i != null && c.i != null && last.p <= c.p && c.p <= last.p + last.i.length) {
            newOp[newOp.length - 1] = { i: strInject(last.i, c.p - last.p, c.i), p: last.p };
          } else if (last.d != null && c.d != null && c.p <= last.p && last.p <= c.p + c.d.length) {
            newOp[newOp.length - 1] = { d: strInject(c.d, last.p - c.p, last.d), p: c.p };
          } else {
            newOp.push(c);
          }
        }
      };
      text.compose = function(op1, op2) {
        checkValidOp(op1);
        checkValidOp(op2);
        var newOp = op1.slice();
        for (var i = 0; i < op2.length; i++) {
          append(newOp, op2[i]);
        }
        return newOp;
      };
      text.normalize = function(op) {
        var newOp = [];
        if (op.i != null || op.p != null)
          op = [op];
        for (var i = 0; i < op.length; i++) {
          var c = op[i];
          if (c.p == null)
            c.p = 0;
          append(newOp, c);
        }
        return newOp;
      };
      var transformPosition = function(pos, c, insertAfter) {
        if (c.i != null) {
          if (c.p < pos || c.p === pos && insertAfter) {
            return pos + c.i.length;
          } else {
            return pos;
          }
        } else {
          if (pos <= c.p) {
            return pos;
          } else if (pos <= c.p + c.d.length) {
            return c.p;
          } else {
            return pos - c.d.length;
          }
        }
      };
      text.transformCursor = function(position, op, side) {
        var insertAfter = side === "right";
        for (var i = 0; i < op.length; i++) {
          position = transformPosition(position, op[i], insertAfter);
        }
        return position;
      };
      var transformComponent = text._tc = function(dest, c, otherC, side) {
        checkValidComponent(c);
        checkValidComponent(otherC);
        if (c.i != null) {
          append(dest, { i: c.i, p: transformPosition(c.p, otherC, side === "right") });
        } else {
          if (otherC.i != null) {
            var s = c.d;
            if (c.p < otherC.p) {
              append(dest, { d: s.slice(0, otherC.p - c.p), p: c.p });
              s = s.slice(otherC.p - c.p);
            }
            if (s !== "")
              append(dest, { d: s, p: c.p + otherC.i.length });
          } else {
            if (c.p >= otherC.p + otherC.d.length)
              append(dest, { d: c.d, p: c.p - otherC.d.length });
            else if (c.p + c.d.length <= otherC.p)
              append(dest, c);
            else {
              var newC = { d: "", p: c.p };
              if (c.p < otherC.p)
                newC.d = c.d.slice(0, otherC.p - c.p);
              if (c.p + c.d.length > otherC.p + otherC.d.length)
                newC.d += c.d.slice(otherC.p + otherC.d.length - c.p);
              var intersectStart = Math.max(c.p, otherC.p);
              var intersectEnd = Math.min(c.p + c.d.length, otherC.p + otherC.d.length);
              var cIntersect = c.d.slice(intersectStart - c.p, intersectEnd - c.p);
              var otherIntersect = otherC.d.slice(intersectStart - otherC.p, intersectEnd - otherC.p);
              if (cIntersect !== otherIntersect)
                throw new Error("Delete ops delete different text in the same region of the document");
              if (newC.d !== "") {
                newC.p = transformPosition(newC.p, otherC);
                append(dest, newC);
              }
            }
          }
        }
        return dest;
      };
      var invertComponent = function(c) {
        return c.i != null ? { d: c.i, p: c.p } : { i: c.d, p: c.p };
      };
      text.invert = function(op) {
        op = op.slice().reverse();
        for (var i = 0; i < op.length; i++) {
          op[i] = invertComponent(op[i]);
        }
        return op;
      };
      require_bootstrapTransform()(text, transformComponent, checkValidOp, append);
    }
  });

  // node_modules/ot-json0/lib/json0.js
  var require_json0 = __commonJS({
    "node_modules/ot-json0/lib/json0.js"(exports, module) {
      init_mithril_shim();
      var isArray = function(obj) {
        return Object.prototype.toString.call(obj) == "[object Array]";
      };
      var isObject = function(obj) {
        return !!obj && obj.constructor === Object;
      };
      var clone = function(o) {
        return JSON.parse(JSON.stringify(o));
      };
      var json = {
        name: "json0",
        uri: "http://sharejs.org/types/JSONv0"
      };
      var subtypes = {};
      json.registerSubtype = function(subtype) {
        subtypes[subtype.name] = subtype;
      };
      json.create = function(data) {
        return data === void 0 ? null : clone(data);
      };
      json.invertComponent = function(c) {
        var c_ = { p: c.p };
        if (c.t && subtypes[c.t]) {
          c_.t = c.t;
          c_.o = subtypes[c.t].invert(c.o);
        }
        if (c.si !== void 0)
          c_.sd = c.si;
        if (c.sd !== void 0)
          c_.si = c.sd;
        if (c.oi !== void 0)
          c_.od = c.oi;
        if (c.od !== void 0)
          c_.oi = c.od;
        if (c.li !== void 0)
          c_.ld = c.li;
        if (c.ld !== void 0)
          c_.li = c.ld;
        if (c.na !== void 0)
          c_.na = -c.na;
        if (c.lm !== void 0) {
          c_.lm = c.p[c.p.length - 1];
          c_.p = c.p.slice(0, c.p.length - 1).concat([c.lm]);
        }
        return c_;
      };
      json.invert = function(op) {
        var op_ = op.slice().reverse();
        var iop = [];
        for (var i = 0; i < op_.length; i++) {
          iop.push(json.invertComponent(op_[i]));
        }
        return iop;
      };
      json.checkValidOp = function(op) {
        for (var i = 0; i < op.length; i++) {
          if (!isArray(op[i].p))
            throw new Error("Missing path");
        }
      };
      json.checkList = function(elem) {
        if (!isArray(elem))
          throw new Error("Referenced element not a list");
      };
      json.checkObj = function(elem) {
        if (!isObject(elem)) {
          throw new Error("Referenced element not an object (it was " + JSON.stringify(elem) + ")");
        }
      };
      function convertFromText(c) {
        c.t = "text0";
        var o = { p: c.p.pop() };
        if (c.si != null)
          o.i = c.si;
        if (c.sd != null)
          o.d = c.sd;
        c.o = [o];
      }
      function convertToText(c) {
        c.p.push(c.o[0].p);
        if (c.o[0].i != null)
          c.si = c.o[0].i;
        if (c.o[0].d != null)
          c.sd = c.o[0].d;
        delete c.t;
        delete c.o;
      }
      json.apply = function(snapshot, op) {
        json.checkValidOp(op);
        op = clone(op);
        var container = {
          data: snapshot
        };
        for (var i = 0; i < op.length; i++) {
          var c = op[i];
          if (c.si != null || c.sd != null)
            convertFromText(c);
          var parent = null;
          var parentKey = null;
          var elem = container;
          var key = "data";
          for (var j = 0; j < c.p.length; j++) {
            var p = c.p[j];
            parent = elem;
            parentKey = key;
            elem = elem[key];
            key = p;
            if (parent == null)
              throw new Error("Path invalid");
          }
          if (c.t && c.o !== void 0 && subtypes[c.t]) {
            elem[key] = subtypes[c.t].apply(elem[key], c.o);
          } else if (c.na !== void 0) {
            if (typeof elem[key] != "number")
              throw new Error("Referenced element not a number");
            elem[key] += c.na;
          } else if (c.li !== void 0 && c.ld !== void 0) {
            json.checkList(elem);
            elem[key] = c.li;
          } else if (c.li !== void 0) {
            json.checkList(elem);
            elem.splice(key, 0, c.li);
          } else if (c.ld !== void 0) {
            json.checkList(elem);
            elem.splice(key, 1);
          } else if (c.lm !== void 0) {
            json.checkList(elem);
            if (c.lm != key) {
              var e = elem[key];
              elem.splice(key, 1);
              elem.splice(c.lm, 0, e);
            }
          } else if (c.oi !== void 0) {
            json.checkObj(elem);
            elem[key] = c.oi;
          } else if (c.od !== void 0) {
            json.checkObj(elem);
            delete elem[key];
          } else {
            throw new Error("invalid / missing instruction in op");
          }
        }
        return container.data;
      };
      json.shatter = function(op) {
        var results = [];
        for (var i = 0; i < op.length; i++) {
          results.push([op[i]]);
        }
        return results;
      };
      json.incrementalApply = function(snapshot, op, _yield) {
        for (var i = 0; i < op.length; i++) {
          var smallOp = [op[i]];
          snapshot = json.apply(snapshot, smallOp);
          _yield(smallOp, snapshot);
        }
        return snapshot;
      };
      var pathMatches = json.pathMatches = function(p1, p2, ignoreLast) {
        if (p1.length != p2.length)
          return false;
        for (var i = 0; i < p1.length; i++) {
          if (p1[i] !== p2[i] && (!ignoreLast || i !== p1.length - 1))
            return false;
        }
        return true;
      };
      json.append = function(dest, c) {
        c = clone(c);
        if (dest.length === 0) {
          dest.push(c);
          return;
        }
        var last = dest[dest.length - 1];
        if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {
          convertFromText(c);
          convertFromText(last);
        }
        if (pathMatches(c.p, last.p)) {
          if (c.t && last.t && c.t === last.t && subtypes[c.t]) {
            last.o = subtypes[c.t].compose(last.o, c.o);
            if (c.si != null || c.sd != null) {
              var p = c.p;
              for (var i = 0; i < last.o.length - 1; i++) {
                c.o = [last.o.pop()];
                c.p = p.slice();
                convertToText(c);
                dest.push(c);
              }
              convertToText(last);
            }
          } else if (last.na != null && c.na != null) {
            dest[dest.length - 1] = { p: last.p, na: last.na + c.na };
          } else if (last.li !== void 0 && c.li === void 0 && c.ld === last.li) {
            if (last.ld !== void 0) {
              delete last.li;
            } else {
              dest.pop();
            }
          } else if (last.od !== void 0 && last.oi === void 0 && c.oi !== void 0 && c.od === void 0) {
            last.oi = c.oi;
          } else if (last.oi !== void 0 && c.od !== void 0) {
            if (c.oi !== void 0) {
              last.oi = c.oi;
            } else if (last.od !== void 0) {
              delete last.oi;
            } else {
              dest.pop();
            }
          } else if (c.lm !== void 0 && c.p[c.p.length - 1] === c.lm) {
          } else {
            dest.push(c);
          }
        } else {
          if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {
            convertToText(c);
            convertToText(last);
          }
          dest.push(c);
        }
      };
      json.compose = function(op1, op2) {
        json.checkValidOp(op1);
        json.checkValidOp(op2);
        var newOp = clone(op1);
        for (var i = 0; i < op2.length; i++) {
          json.append(newOp, op2[i]);
        }
        return newOp;
      };
      json.normalize = function(op) {
        var newOp = [];
        op = isArray(op) ? op : [op];
        for (var i = 0; i < op.length; i++) {
          var c = op[i];
          if (c.p == null)
            c.p = [];
          json.append(newOp, c);
        }
        return newOp;
      };
      json.commonLengthForOps = function(a, b) {
        var alen = a.p.length;
        var blen = b.p.length;
        if (a.na != null || a.t)
          alen++;
        if (b.na != null || b.t)
          blen++;
        if (alen === 0)
          return -1;
        if (blen === 0)
          return null;
        alen--;
        blen--;
        for (var i = 0; i < alen; i++) {
          var p = a.p[i];
          if (i >= blen || p !== b.p[i])
            return null;
        }
        return alen;
      };
      json.canOpAffectPath = function(op, path3) {
        return json.commonLengthForOps({ p: path3 }, op) != null;
      };
      json.transformComponent = function(dest, c, otherC, type) {
        c = clone(c);
        var common = json.commonLengthForOps(otherC, c);
        var common2 = json.commonLengthForOps(c, otherC);
        var cplength = c.p.length;
        var otherCplength = otherC.p.length;
        if (c.na != null || c.t)
          cplength++;
        if (otherC.na != null || otherC.t)
          otherCplength++;
        if (common2 != null && otherCplength > cplength && c.p[common2] == otherC.p[common2]) {
          if (c.ld !== void 0) {
            var oc = clone(otherC);
            oc.p = oc.p.slice(cplength);
            c.ld = json.apply(clone(c.ld), [oc]);
          } else if (c.od !== void 0) {
            var oc = clone(otherC);
            oc.p = oc.p.slice(cplength);
            c.od = json.apply(clone(c.od), [oc]);
          }
        }
        if (common != null) {
          var commonOperand = cplength == otherCplength;
          var oc = otherC;
          if ((c.si != null || c.sd != null) && (otherC.si != null || otherC.sd != null)) {
            convertFromText(c);
            oc = clone(otherC);
            convertFromText(oc);
          }
          if (oc.t && subtypes[oc.t]) {
            if (c.t && c.t === oc.t) {
              var res = subtypes[c.t].transform(c.o, oc.o, type);
              if (c.si != null || c.sd != null) {
                var p = c.p;
                for (var i = 0; i < res.length; i++) {
                  c.o = [res[i]];
                  c.p = p.slice();
                  convertToText(c);
                  json.append(dest, c);
                }
              } else if (!isArray(res) || res.length > 0) {
                c.o = res;
                json.append(dest, c);
              }
              return dest;
            }
          } else if (otherC.na !== void 0) {
          } else if (otherC.li !== void 0 && otherC.ld !== void 0) {
            if (otherC.p[common] === c.p[common]) {
              if (!commonOperand) {
                return dest;
              } else if (c.ld !== void 0) {
                if (c.li !== void 0 && type === "left") {
                  c.ld = clone(otherC.li);
                } else {
                  return dest;
                }
              }
            }
          } else if (otherC.li !== void 0) {
            if (c.li !== void 0 && c.ld === void 0 && commonOperand && c.p[common] === otherC.p[common]) {
              if (type === "right")
                c.p[common]++;
            } else if (otherC.p[common] <= c.p[common]) {
              c.p[common]++;
            }
            if (c.lm !== void 0) {
              if (commonOperand) {
                if (otherC.p[common] <= c.lm)
                  c.lm++;
              }
            }
          } else if (otherC.ld !== void 0) {
            if (c.lm !== void 0) {
              if (commonOperand) {
                if (otherC.p[common] === c.p[common]) {
                  return dest;
                }
                var p = otherC.p[common];
                var from = c.p[common];
                var to = c.lm;
                if (p < to || p === to && from < to)
                  c.lm--;
              }
            }
            if (otherC.p[common] < c.p[common]) {
              c.p[common]--;
            } else if (otherC.p[common] === c.p[common]) {
              if (otherCplength < cplength) {
                return dest;
              } else if (c.ld !== void 0) {
                if (c.li !== void 0) {
                  delete c.ld;
                } else {
                  return dest;
                }
              }
            }
          } else if (otherC.lm !== void 0) {
            if (c.lm !== void 0 && cplength === otherCplength) {
              var from = c.p[common];
              var to = c.lm;
              var otherFrom = otherC.p[common];
              var otherTo = otherC.lm;
              if (otherFrom !== otherTo) {
                if (from === otherFrom) {
                  if (type === "left") {
                    c.p[common] = otherTo;
                    if (from === to)
                      c.lm = otherTo;
                  } else {
                    return dest;
                  }
                } else {
                  if (from > otherFrom)
                    c.p[common]--;
                  if (from > otherTo)
                    c.p[common]++;
                  else if (from === otherTo) {
                    if (otherFrom > otherTo) {
                      c.p[common]++;
                      if (from === to)
                        c.lm++;
                    }
                  }
                  if (to > otherFrom) {
                    c.lm--;
                  } else if (to === otherFrom) {
                    if (to > from)
                      c.lm--;
                  }
                  if (to > otherTo) {
                    c.lm++;
                  } else if (to === otherTo) {
                    if (otherTo > otherFrom && to > from || otherTo < otherFrom && to < from) {
                      if (type === "right")
                        c.lm++;
                    } else {
                      if (to > from)
                        c.lm++;
                      else if (to === otherFrom)
                        c.lm--;
                    }
                  }
                }
              }
            } else if (c.li !== void 0 && c.ld === void 0 && commonOperand) {
              var from = otherC.p[common];
              var to = otherC.lm;
              p = c.p[common];
              if (p > from)
                c.p[common]--;
              if (p > to)
                c.p[common]++;
            } else {
              var from = otherC.p[common];
              var to = otherC.lm;
              p = c.p[common];
              if (p === from) {
                c.p[common] = to;
              } else {
                if (p > from)
                  c.p[common]--;
                if (p > to)
                  c.p[common]++;
                else if (p === to && from > to)
                  c.p[common]++;
              }
            }
          } else if (otherC.oi !== void 0 && otherC.od !== void 0) {
            if (c.p[common] === otherC.p[common]) {
              if (c.oi !== void 0 && commonOperand) {
                if (type === "right") {
                  return dest;
                } else {
                  c.od = otherC.oi;
                }
              } else {
                return dest;
              }
            }
          } else if (otherC.oi !== void 0) {
            if (c.oi !== void 0 && c.p[common] === otherC.p[common]) {
              if (type === "left") {
                json.append(dest, { p: c.p, od: otherC.oi });
              } else {
                return dest;
              }
            }
          } else if (otherC.od !== void 0) {
            if (c.p[common] == otherC.p[common]) {
              if (!commonOperand)
                return dest;
              if (c.oi !== void 0) {
                delete c.od;
              } else {
                return dest;
              }
            }
          }
        }
        json.append(dest, c);
        return dest;
      };
      require_bootstrapTransform()(json, json.transformComponent, json.checkValidOp, json.append);
      var text = require_text0();
      json.registerSubtype(text);
      module.exports = json;
    }
  });

  // node_modules/ot-json0/lib/index.js
  var require_lib = __commonJS({
    "node_modules/ot-json0/lib/index.js"(exports, module) {
      init_mithril_shim();
      module.exports = {
        type: require_json0()
      };
    }
  });

  // node_modules/sharedb/lib/types.js
  var require_types = __commonJS({
    "node_modules/sharedb/lib/types.js"(exports) {
      init_mithril_shim();
      exports.defaultType = require_lib().type;
      exports.map = {};
      exports.register = function(type) {
        if (type.name)
          exports.map[type.name] = type;
        if (type.uri)
          exports.map[type.uri] = type;
      };
      exports.register(exports.defaultType);
    }
  });

  // node_modules/sharedb/lib/util.js
  var require_util = __commonJS({
    "node_modules/sharedb/lib/util.js"(exports) {
      init_mithril_shim();
      exports.doNothing = doNothing;
      function doNothing() {
      }
      exports.hasKeys = function(object) {
        for (var key in object)
          return true;
        return false;
      };
      exports.isInteger = Number.isInteger || function(value) {
        return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
      };
      exports.isValidVersion = function(version) {
        if (version === null)
          return true;
        return exports.isInteger(version) && version >= 0;
      };
      exports.isValidTimestamp = function(timestamp) {
        return exports.isValidVersion(timestamp);
      };
      exports.MAX_SAFE_INTEGER = 9007199254740991;
      exports.dig = function() {
        var obj = arguments[0];
        for (var i = 1; i < arguments.length; i++) {
          var key = arguments[i];
          obj = obj[key] || (i === arguments.length - 1 ? void 0 : {});
        }
        return obj;
      };
      exports.digOrCreate = function() {
        var obj = arguments[0];
        var createCallback = arguments[arguments.length - 1];
        for (var i = 1; i < arguments.length - 1; i++) {
          var key = arguments[i];
          obj = obj[key] || (obj[key] = i === arguments.length - 2 ? createCallback() : {});
        }
        return obj;
      };
      exports.digAndRemove = function() {
        var obj = arguments[0];
        var objects = [obj];
        for (var i = 1; i < arguments.length - 1; i++) {
          var key = arguments[i];
          if (!obj.hasOwnProperty(key))
            break;
          obj = obj[key];
          objects.push(obj);
        }
        ;
        for (var i = objects.length - 1; i >= 0; i--) {
          var parent = objects[i];
          var key = arguments[i + 1];
          var child = parent[key];
          if (i === objects.length - 1 || !exports.hasKeys(child))
            delete parent[key];
        }
      };
      exports.supportsPresence = function(type) {
        return type && typeof type.transformPresence === "function";
      };
      exports.callEach = function(callbacks, error) {
        var called = false;
        callbacks.forEach(function(callback) {
          if (callback) {
            callback(error);
            called = true;
          }
        });
        return called;
      };
      exports.truthy = function(arg) {
        return !!arg;
      };
      exports.nextTick = function(callback) {
        if (typeof process !== "undefined" && process.nextTick) {
          return process.nextTick.apply(null, arguments);
        }
        var args = [];
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
        setTimeout(function() {
          callback.apply(null, args);
        });
      };
      exports.clone = function(obj) {
        return obj === void 0 ? void 0 : JSON.parse(JSON.stringify(obj));
      };
    }
  });

  // node_modules/fast-deep-equal/index.js
  var require_fast_deep_equal = __commonJS({
    "node_modules/fast-deep-equal/index.js"(exports, module) {
      "use strict";
      init_mithril_shim();
      module.exports = function equal(a, b) {
        if (a === b)
          return true;
        if (a && b && typeof a == "object" && typeof b == "object") {
          if (a.constructor !== b.constructor)
            return false;
          var length, i, keys;
          if (Array.isArray(a)) {
            length = a.length;
            if (length != b.length)
              return false;
            for (i = length; i-- !== 0; )
              if (!equal(a[i], b[i]))
                return false;
            return true;
          }
          if (a.constructor === RegExp)
            return a.source === b.source && a.flags === b.flags;
          if (a.valueOf !== Object.prototype.valueOf)
            return a.valueOf() === b.valueOf();
          if (a.toString !== Object.prototype.toString)
            return a.toString() === b.toString();
          keys = Object.keys(a);
          length = keys.length;
          if (length !== Object.keys(b).length)
            return false;
          for (i = length; i-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
              return false;
          for (i = length; i-- !== 0; ) {
            var key = keys[i];
            if (!equal(a[key], b[key]))
              return false;
          }
          return true;
        }
        return a !== a && b !== b;
      };
    }
  });

  // node_modules/sharedb/lib/message-actions.js
  var require_message_actions = __commonJS({
    "node_modules/sharedb/lib/message-actions.js"(exports) {
      init_mithril_shim();
      exports.ACTIONS = {
        initLegacy: "init",
        handshake: "hs",
        queryFetch: "qf",
        querySubscribe: "qs",
        queryUnsubscribe: "qu",
        queryUpdate: "q",
        bulkFetch: "bf",
        bulkSubscribe: "bs",
        bulkUnsubscribe: "bu",
        fetch: "f",
        fixup: "fixup",
        subscribe: "s",
        unsubscribe: "u",
        op: "op",
        snapshotFetch: "nf",
        snapshotFetchByTimestamp: "nt",
        pingPong: "pp",
        presence: "p",
        presenceSubscribe: "ps",
        presenceUnsubscribe: "pu",
        presenceRequest: "pr"
      };
    }
  });

  // node_modules/sharedb/lib/client/doc.js
  var require_doc = __commonJS({
    "node_modules/sharedb/lib/client/doc.js"(exports, module) {
      init_mithril_shim();
      var emitter = require_emitter();
      var logger = require_logger2();
      var ShareDBError = require_error();
      var types = require_types();
      var util = require_util();
      var clone = util.clone;
      var deepEqual = require_fast_deep_equal();
      var ACTIONS = require_message_actions().ACTIONS;
      var ERROR_CODE = ShareDBError.CODES;
      module.exports = Doc;
      function Doc(connection2, collection, id) {
        emitter.EventEmitter.call(this);
        this.connection = connection2;
        this.collection = collection;
        this.id = id;
        this.version = null;
        this.type = null;
        this.data = void 0;
        this.inflightFetch = [];
        this.inflightSubscribe = null;
        this.pendingFetch = [];
        this.pendingSubscribe = [];
        this.subscribed = false;
        this.wantSubscribe = false;
        this._wantsDestroy = false;
        this.inflightOp = null;
        this.pendingOps = [];
        this.type = null;
        this.applyStack = null;
        this.preventCompose = false;
        this.submitSource = false;
        this.paused = false;
        this._dataStateVersion = 0;
      }
      emitter.mixin(Doc);
      Doc.prototype.destroy = function(callback) {
        this._wantsDestroy = true;
        var doc2 = this;
        doc2.whenNothingPending(function() {
          if (doc2.wantSubscribe) {
            doc2.unsubscribe(function(err) {
              if (err) {
                if (callback)
                  return callback(err);
                return doc2.emit("error", err);
              }
              doc2.connection._destroyDoc(doc2);
              if (callback)
                callback();
            });
          } else {
            doc2.connection._destroyDoc(doc2);
            if (callback)
              callback();
          }
        });
      };
      Doc.prototype._setType = function(newType) {
        if (typeof newType === "string") {
          newType = types.map[newType];
        }
        if (newType) {
          this.type = newType;
        } else if (newType === null) {
          this.type = newType;
          this._setData(void 0);
        } else {
          var err = new ShareDBError(ERROR_CODE.ERR_DOC_TYPE_NOT_RECOGNIZED, "Missing type " + newType);
          return this.emit("error", err);
        }
      };
      Doc.prototype._setData = function(data) {
        this.data = data;
        this._dataStateVersion++;
      };
      Doc.prototype.ingestSnapshot = function(snapshot, callback) {
        if (!snapshot)
          return callback && callback();
        if (typeof snapshot.v !== "number") {
          var err = new ShareDBError(
            ERROR_CODE.ERR_INGESTED_SNAPSHOT_HAS_NO_VERSION,
            "Missing version in ingested snapshot. " + this.collection + "." + this.id
          );
          if (callback)
            return callback(err);
          return this.emit("error", err);
        }
        if (this.type || this.hasWritePending()) {
          if (this.version == null) {
            if (this.hasWritePending()) {
              return callback && this.once("no write pending", callback);
            }
            var err = new ShareDBError(
              ERROR_CODE.ERR_DOC_MISSING_VERSION,
              "Cannot ingest snapshot in doc with null version. " + this.collection + "." + this.id
            );
            if (callback)
              return callback(err);
            return this.emit("error", err);
          }
          if (snapshot.v > this.version)
            return this.fetch(callback);
          return callback && callback();
        }
        if (this.version > snapshot.v)
          return callback && callback();
        this.version = snapshot.v;
        var type = snapshot.type === void 0 ? types.defaultType : snapshot.type;
        this._setType(type);
        this._setData(
          this.type && this.type.deserialize ? this.type.deserialize(snapshot.data) : snapshot.data
        );
        this.emit("load");
        callback && callback();
      };
      Doc.prototype.whenNothingPending = function(callback) {
        var doc2 = this;
        util.nextTick(function() {
          if (doc2.hasPending()) {
            doc2.once("nothing pending", callback);
            return;
          }
          callback();
        });
      };
      Doc.prototype.hasPending = function() {
        return !!(this.inflightOp || this.pendingOps.length || this.inflightFetch.length || this.inflightSubscribe || this.pendingFetch.length || this.pendingSubscribe.length);
      };
      Doc.prototype.hasWritePending = function() {
        return !!(this.inflightOp || this.pendingOps.length);
      };
      Doc.prototype._emitNothingPending = function() {
        if (this.hasWritePending())
          return;
        this.emit("no write pending");
        if (this.hasPending())
          return;
        this.emit("nothing pending");
      };
      Doc.prototype._emitResponseError = function(err, callback) {
        if (err && err.code === ERROR_CODE.ERR_SNAPSHOT_READ_SILENT_REJECTION) {
          this.wantSubscribe = false;
          if (callback) {
            callback();
          }
          this._emitNothingPending();
          return;
        }
        if (callback) {
          callback(err);
          this._emitNothingPending();
          return;
        }
        this._emitNothingPending();
        this.emit("error", err);
      };
      Doc.prototype._handleFetch = function(error, snapshot) {
        var callbacks = this.pendingFetch;
        this.pendingFetch = [];
        var callback = this.inflightFetch.shift();
        if (callback)
          callbacks.push(callback);
        if (callbacks.length) {
          callback = function(error2) {
            util.callEach(callbacks, error2);
          };
        }
        if (error)
          return this._emitResponseError(error, callback);
        this.ingestSnapshot(snapshot, callback);
        this._emitNothingPending();
      };
      Doc.prototype._handleSubscribe = function(error, snapshot) {
        var request = this.inflightSubscribe;
        this.inflightSubscribe = null;
        var callbacks = this.pendingFetch;
        this.pendingFetch = [];
        if (request.callback)
          callbacks.push(request.callback);
        var callback;
        if (callbacks.length) {
          callback = function(error2) {
            util.callEach(callbacks, error2);
          };
        }
        if (error)
          return this._emitResponseError(error, callback);
        this.subscribed = request.wantSubscribe;
        if (this.subscribed)
          this.ingestSnapshot(snapshot, callback);
        else if (callback)
          callback();
        this._emitNothingPending();
        this._flushSubscribe();
      };
      Doc.prototype._handleOp = function(err, message) {
        if (err) {
          if (this.inflightOp) {
            return this._rollback(err);
          }
          return this.emit("error", err);
        }
        if (this.inflightOp && message.src === this.inflightOp.src && message.seq === this.inflightOp.seq) {
          this._opAcknowledged(message);
          return;
        }
        if (this.version == null || message.v > this.version) {
          this.fetch();
          return;
        }
        if (message.v < this.version) {
          return;
        }
        if (this.inflightOp) {
          var transformErr = transformX(this.inflightOp, message);
          if (transformErr)
            return this._hardRollback(transformErr);
        }
        for (var i = 0; i < this.pendingOps.length; i++) {
          var transformErr = transformX(this.pendingOps[i], message);
          if (transformErr)
            return this._hardRollback(transformErr);
        }
        this.version++;
        try {
          this._otApply(message, false);
        } catch (error) {
          return this._hardRollback(error);
        }
      };
      Doc.prototype._onConnectionStateChanged = function() {
        if (this.connection.canSend) {
          this.flush();
          this._resubscribe();
        } else {
          if (this.inflightOp) {
            this.pendingOps.unshift(this.inflightOp);
            this.inflightOp = null;
          }
          this.subscribed = false;
          if (this.inflightSubscribe) {
            if (this.inflightSubscribe.wantSubscribe) {
              this.pendingSubscribe.unshift(this.inflightSubscribe);
              this.inflightSubscribe = null;
            } else {
              this._handleSubscribe();
            }
          }
          if (this.inflightFetch.length) {
            this.pendingFetch = this.pendingFetch.concat(this.inflightFetch);
            this.inflightFetch.length = 0;
          }
        }
      };
      Doc.prototype._resubscribe = function() {
        if (!this.pendingSubscribe.length && this.wantSubscribe) {
          return this.subscribe();
        }
        var willFetch = this.pendingSubscribe.some(function(request) {
          return request.wantSubscribe;
        });
        if (!willFetch && this.pendingFetch.length)
          this.fetch();
        this._flushSubscribe();
      };
      Doc.prototype.fetch = function(callback) {
        this._fetch({}, callback);
      };
      Doc.prototype._fetch = function(options, callback) {
        this.pendingFetch.push(callback);
        var shouldSend = this.connection.canSend && (options.force || !this.inflightFetch.length);
        if (!shouldSend)
          return;
        this.inflightFetch.push(this.pendingFetch.shift());
        this.connection.sendFetch(this);
      };
      Doc.prototype.subscribe = function(callback) {
        var wantSubscribe = true;
        this._queueSubscribe(wantSubscribe, callback);
      };
      Doc.prototype.unsubscribe = function(callback) {
        var wantSubscribe = false;
        this._queueSubscribe(wantSubscribe, callback);
      };
      Doc.prototype._queueSubscribe = function(wantSubscribe, callback) {
        var lastRequest = this.pendingSubscribe[this.pendingSubscribe.length - 1] || this.inflightSubscribe;
        var isDuplicateRequest = lastRequest && lastRequest.wantSubscribe === wantSubscribe;
        if (isDuplicateRequest) {
          lastRequest.callback = combineCallbacks([lastRequest.callback, callback]);
          return;
        }
        this.pendingSubscribe.push({
          wantSubscribe: !!wantSubscribe,
          callback
        });
        this._flushSubscribe();
      };
      Doc.prototype._flushSubscribe = function() {
        if (this.inflightSubscribe || !this.pendingSubscribe.length)
          return;
        if (this.connection.canSend) {
          this.inflightSubscribe = this.pendingSubscribe.shift();
          this.wantSubscribe = this.inflightSubscribe.wantSubscribe;
          if (this.wantSubscribe) {
            this.connection.sendSubscribe(this);
          } else {
            this.subscribed = false;
            this.connection.sendUnsubscribe(this);
          }
          return;
        }
        if (!this.pendingSubscribe[0].wantSubscribe) {
          this.inflightSubscribe = this.pendingSubscribe.shift();
          var doc2 = this;
          util.nextTick(function() {
            doc2._handleSubscribe();
          });
        }
      };
      function combineCallbacks(callbacks) {
        callbacks = callbacks.filter(util.truthy);
        if (!callbacks.length)
          return null;
        return function(error) {
          util.callEach(callbacks, error);
        };
      }
      Doc.prototype.flush = function() {
        if (!this.connection.canSend || this.inflightOp)
          return;
        if (!this.paused && this.pendingOps.length) {
          this._sendOp();
        }
      };
      function setNoOp(op) {
        delete op.op;
        delete op.create;
        delete op.del;
      }
      function transformX(client, server) {
        if (client.del)
          return setNoOp(server);
        if (server.del) {
          return new ShareDBError(ERROR_CODE.ERR_DOC_WAS_DELETED, "Document was deleted");
        }
        if (server.create) {
          return new ShareDBError(ERROR_CODE.ERR_DOC_ALREADY_CREATED, "Document already created");
        }
        if (!("op" in server))
          return;
        if (client.create) {
          return new ShareDBError(ERROR_CODE.ERR_DOC_ALREADY_CREATED, "Document already created");
        }
        if (client.type.transformX) {
          var result = client.type.transformX(client.op, server.op);
          client.op = result[0];
          server.op = result[1];
        } else {
          var clientOp = client.type.transform(client.op, server.op, "left");
          var serverOp = client.type.transform(server.op, client.op, "right");
          client.op = clientOp;
          server.op = serverOp;
        }
      }
      Doc.prototype._otApply = function(op, source) {
        if ("op" in op) {
          if (!this.type) {
            throw new ShareDBError(
              ERROR_CODE.ERR_DOC_DOES_NOT_EXIST,
              "Cannot apply op to uncreated document. " + this.collection + "." + this.id
            );
          }
          this.emit("before op batch", op.op, source);
          if (!source && this.type === types.defaultType && op.op.length > 1) {
            if (!this.applyStack)
              this.applyStack = [];
            var stackLength = this.applyStack.length;
            for (var i = 0; i < op.op.length; i++) {
              var component = op.op[i];
              var componentOp = { op: [component] };
              this.emit("before op", componentOp.op, source, op.src);
              for (var j = stackLength; j < this.applyStack.length; j++) {
                var transformErr = transformX(this.applyStack[j], componentOp);
                if (transformErr)
                  return this._hardRollback(transformErr);
              }
              this._setData(this.type.apply(this.data, componentOp.op));
              this.emit("op", componentOp.op, source, op.src);
            }
            this.emit("op batch", op.op, source);
            this._popApplyStack(stackLength);
            return;
          }
          this.emit("before op", op.op, source, op.src);
          this._setData(this.type.apply(this.data, op.op));
          this.emit("op", op.op, source, op.src);
          this.emit("op batch", op.op, source);
          return;
        }
        if (op.create) {
          this._setType(op.create.type);
          if (this.type.deserialize) {
            if (this.type.createDeserialized) {
              this._setData(this.type.createDeserialized(op.create.data));
            } else {
              this._setData(this.type.deserialize(this.type.create(op.create.data)));
            }
          } else {
            this._setData(this.type.create(op.create.data));
          }
          this.emit("create", source);
          return;
        }
        if (op.del) {
          var oldData = this.data;
          this._setType(null);
          this.emit("del", oldData, source);
          return;
        }
      };
      Doc.prototype._sendOp = function() {
        if (!this.connection.canSend)
          return;
        var src = this.connection.id;
        if (!this.inflightOp) {
          this.inflightOp = this.pendingOps.shift();
        }
        var op = this.inflightOp;
        if (!op) {
          var err = new ShareDBError(ERROR_CODE.ERR_INFLIGHT_OP_MISSING, "No op to send on call to _sendOp");
          return this.emit("error", err);
        }
        op.sentAt = Date.now();
        op.retries = op.retries == null ? 0 : op.retries + 1;
        if (op.seq == null) {
          if (this.connection.seq >= util.MAX_SAFE_INTEGER) {
            return this.emit("error", new ShareDBError(
              ERROR_CODE.ERR_CONNECTION_SEQ_INTEGER_OVERFLOW,
              "Connection seq has exceeded the max safe integer, maybe from being open for too long"
            ));
          }
          op.seq = this.connection.seq++;
        }
        this.connection.sendOp(this, op);
        if (op.src == null)
          op.src = src;
      };
      Doc.prototype._submit = function(op, source, callback) {
        if (!source)
          source = true;
        if ("op" in op) {
          if (!this.type) {
            var err = new ShareDBError(
              ERROR_CODE.ERR_DOC_DOES_NOT_EXIST,
              "Cannot submit op. Document has not been created. " + this.collection + "." + this.id
            );
            if (callback)
              return callback(err);
            return this.emit("error", err);
          }
          if (this.type.normalize)
            op.op = this.type.normalize(op.op);
        }
        try {
          this._pushOp(op, source, callback);
          this._otApply(op, source);
        } catch (error) {
          return this._hardRollback(error);
        }
        var doc2 = this;
        util.nextTick(function() {
          doc2.flush();
        });
      };
      Doc.prototype._pushOp = function(op, source, callback) {
        op.source = source;
        if (this.applyStack) {
          this.applyStack.push(op);
        } else {
          var composed = this._tryCompose(op);
          if (composed) {
            composed.callbacks.push(callback);
            return;
          }
        }
        op.type = this.type;
        op.callbacks = [callback];
        this.pendingOps.push(op);
      };
      Doc.prototype._popApplyStack = function(to) {
        if (to > 0) {
          this.applyStack.length = to;
          return;
        }
        var op = this.applyStack[0];
        this.applyStack = null;
        if (!op)
          return;
        var i = this.pendingOps.indexOf(op);
        if (i === -1)
          return;
        var ops = this.pendingOps.splice(i);
        for (var i = 0; i < ops.length; i++) {
          var op = ops[i];
          var composed = this._tryCompose(op);
          if (composed) {
            composed.callbacks = composed.callbacks.concat(op.callbacks);
          } else {
            this.pendingOps.push(op);
          }
        }
      };
      Doc.prototype._tryCompose = function(op) {
        if (this.preventCompose)
          return;
        var last = this.pendingOps[this.pendingOps.length - 1];
        if (!last || last.sentAt)
          return;
        if (this.submitSource && !deepEqual(op.source, last.source))
          return;
        if (last.create && "op" in op) {
          last.create.data = this.type.apply(last.create.data, op.op);
          return last;
        }
        if ("op" in last && "op" in op && this.type.compose) {
          last.op = this.type.compose(last.op, op.op);
          return last;
        }
      };
      Doc.prototype.submitOp = function(component, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = null;
        }
        var op = { op: component };
        var source = options && options.source;
        this._submit(op, source, callback);
      };
      Doc.prototype.create = function(data, type, options, callback) {
        if (typeof type === "function") {
          callback = type;
          options = null;
          type = null;
        } else if (typeof options === "function") {
          callback = options;
          options = null;
        }
        if (!type) {
          type = types.defaultType.uri;
        }
        if (this.type) {
          var err = new ShareDBError(ERROR_CODE.ERR_DOC_ALREADY_CREATED, "Document already exists");
          if (callback)
            return callback(err);
          return this.emit("error", err);
        }
        var op = { create: { type, data } };
        var source = options && options.source;
        this._submit(op, source, callback);
      };
      Doc.prototype.del = function(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = null;
        }
        if (!this.type) {
          var err = new ShareDBError(ERROR_CODE.ERR_DOC_DOES_NOT_EXIST, "Document does not exist");
          if (callback)
            return callback(err);
          return this.emit("error", err);
        }
        var op = { del: true };
        var source = options && options.source;
        this._submit(op, source, callback);
      };
      Doc.prototype.pause = function() {
        this.paused = true;
      };
      Doc.prototype.resume = function() {
        this.paused = false;
        this.flush();
      };
      Doc.prototype.toSnapshot = function() {
        return {
          v: this.version,
          data: clone(this.data),
          type: this.type.uri
        };
      };
      Doc.prototype._opAcknowledged = function(message) {
        if (this.inflightOp.create) {
          this.version = message.v;
        } else if (message.v !== this.version) {
          logger.warn("Invalid version from server. Expected: " + this.version + " Received: " + message.v, message);
          return this.fetch();
        }
        if (message[ACTIONS.fixup]) {
          for (var i = 0; i < message[ACTIONS.fixup].length; i++) {
            var fixupOp = message[ACTIONS.fixup][i];
            for (var j = 0; j < this.pendingOps.length; j++) {
              var transformErr = transformX(this.pendingOps[i], fixupOp);
              if (transformErr)
                return this._hardRollback(transformErr);
            }
            try {
              this._otApply(fixupOp, false);
            } catch (error) {
              return this._hardRollback(error);
            }
          }
        }
        this.version++;
        this._clearInflightOp();
      };
      Doc.prototype._rollback = function(err) {
        var op = this.inflightOp;
        if (!("op" in op && op.type.invert)) {
          return this._hardRollback(err);
        }
        try {
          op.op = op.type.invert(op.op);
        } catch (error) {
          return this._hardRollback(err);
        }
        for (var i = 0; i < this.pendingOps.length; i++) {
          var transformErr = transformX(this.pendingOps[i], op);
          if (transformErr)
            return this._hardRollback(transformErr);
        }
        try {
          this._otApply(op, false);
        } catch (error) {
          return this._hardRollback(error);
        }
        if (err.code === ERROR_CODE.ERR_OP_SUBMIT_REJECTED) {
          return this._clearInflightOp(null);
        }
        this._clearInflightOp(err);
      };
      Doc.prototype._hardRollback = function(err) {
        var pendingOps = this.pendingOps;
        var inflightOp = this.inflightOp;
        this._setType(null);
        this.version = null;
        this.inflightOp = null;
        this.pendingOps = [];
        var doc2 = this;
        this._fetch({ force: true }, function(fetchError) {
          if (fetchError) {
            logger.error("Hard rollback doc fetch failed.", fetchError, inflightOp);
            doc2.emit("error", new ShareDBError(
              ERROR_CODE.ERR_HARD_ROLLBACK_FETCH_FAILED,
              "Hard rollback fetch failed: " + fetchError.message
            ));
          }
          if (err.code === ERROR_CODE.ERR_OP_SUBMIT_REJECTED) {
            if (inflightOp) {
              util.callEach(inflightOp.callbacks);
              inflightOp = null;
            }
            if (!pendingOps.length)
              return;
            err = new ShareDBError(
              ERROR_CODE.ERR_PENDING_OP_REMOVED_BY_OP_SUBMIT_REJECTED,
              "Discarding pending op because of hard rollback during ERR_OP_SUBMIT_REJECTED"
            );
          }
          if (inflightOp)
            pendingOps.unshift(inflightOp);
          var allOpsHadCallbacks = !!pendingOps.length;
          for (var i = 0; i < pendingOps.length; i++) {
            allOpsHadCallbacks = util.callEach(pendingOps[i].callbacks, err) && allOpsHadCallbacks;
          }
          if (err && !allOpsHadCallbacks)
            doc2.emit("error", err);
        });
      };
      Doc.prototype._clearInflightOp = function(err) {
        var inflightOp = this.inflightOp;
        this.inflightOp = null;
        var called = util.callEach(inflightOp.callbacks, err);
        this.flush();
        this._emitNothingPending();
        if (err && !called)
          return this.emit("error", err);
      };
    }
  });

  // node_modules/sharedb/lib/client/query.js
  var require_query = __commonJS({
    "node_modules/sharedb/lib/client/query.js"(exports, module) {
      init_mithril_shim();
      var emitter = require_emitter();
      var ACTIONS = require_message_actions().ACTIONS;
      var util = require_util();
      module.exports = Query;
      function Query(action, connection2, id, collection, query, options, callback) {
        emitter.EventEmitter.call(this);
        this.action = action;
        this.connection = connection2;
        this.id = id;
        this.collection = collection;
        this.query = query;
        this.results = null;
        if (options && options.results) {
          this.results = options.results;
          delete options.results;
        }
        this.extra = void 0;
        this.options = options;
        this.callback = callback;
        this.ready = false;
        this.sent = false;
      }
      emitter.mixin(Query);
      Query.prototype.hasPending = function() {
        return !this.ready;
      };
      Query.prototype.send = function() {
        if (!this.connection.canSend)
          return;
        var message = {
          a: this.action,
          id: this.id,
          c: this.collection,
          q: this.query
        };
        if (this.options) {
          message.o = this.options;
        }
        if (this.results) {
          var results = [];
          for (var i = 0; i < this.results.length; i++) {
            var doc2 = this.results[i];
            results.push([doc2.id, doc2.version]);
          }
          message.r = results;
        }
        this.connection.send(message);
        this.sent = true;
      };
      Query.prototype.destroy = function(callback) {
        if (this.connection.canSend && this.action === ACTIONS.querySubscribe) {
          this.connection.send({ a: ACTIONS.queryUnsubscribe, id: this.id });
        }
        this.connection._destroyQuery(this);
        if (callback)
          util.nextTick(callback);
      };
      Query.prototype._onConnectionStateChanged = function() {
        if (this.connection.canSend && !this.sent) {
          this.send();
        } else {
          this.sent = false;
        }
      };
      Query.prototype._handleFetch = function(err, data, extra) {
        this.connection._destroyQuery(this);
        this._handleResponse(err, data, extra);
      };
      Query.prototype._handleSubscribe = function(err, data, extra) {
        this._handleResponse(err, data, extra);
      };
      Query.prototype._handleResponse = function(err, data, extra) {
        var callback = this.callback;
        this.callback = null;
        if (err)
          return this._finishResponse(err, callback);
        if (!data)
          return this._finishResponse(null, callback);
        var query = this;
        var wait = 1;
        var finish = function(err2) {
          if (err2)
            return query._finishResponse(err2, callback);
          if (--wait)
            return;
          query._finishResponse(null, callback);
        };
        if (Array.isArray(data)) {
          wait += data.length;
          this.results = this._ingestSnapshots(data, finish);
          this.extra = extra;
        } else {
          for (var id in data) {
            wait++;
            var snapshot = data[id];
            var doc2 = this.connection.get(snapshot.c || this.collection, id);
            doc2.ingestSnapshot(snapshot, finish);
          }
        }
        finish();
      };
      Query.prototype._ingestSnapshots = function(snapshots, finish) {
        var results = [];
        for (var i = 0; i < snapshots.length; i++) {
          var snapshot = snapshots[i];
          var doc2 = this.connection.get(snapshot.c || this.collection, snapshot.d);
          doc2.ingestSnapshot(snapshot, finish);
          results.push(doc2);
        }
        return results;
      };
      Query.prototype._finishResponse = function(err, callback) {
        this.emit("ready");
        this.ready = true;
        if (err) {
          this.connection._destroyQuery(this);
          if (callback)
            return callback(err);
          return this.emit("error", err);
        }
        if (callback)
          callback(null, this.results, this.extra);
      };
      Query.prototype._handleError = function(err) {
        this.emit("error", err);
      };
      Query.prototype._handleDiff = function(diff) {
        for (var i = 0; i < diff.length; i++) {
          var d = diff[i];
          if (d.type === "insert")
            d.values = this._ingestSnapshots(d.values);
        }
        for (var i = 0; i < diff.length; i++) {
          var d = diff[i];
          switch (d.type) {
            case "insert":
              var newDocs = d.values;
              Array.prototype.splice.apply(this.results, [d.index, 0].concat(newDocs));
              this.emit("insert", newDocs, d.index);
              break;
            case "remove":
              var howMany = d.howMany || 1;
              var removed = this.results.splice(d.index, howMany);
              this.emit("remove", removed, d.index);
              break;
            case "move":
              var howMany = d.howMany || 1;
              var docs = this.results.splice(d.from, howMany);
              Array.prototype.splice.apply(this.results, [d.to, 0].concat(docs));
              this.emit("move", docs, d.from, d.to);
              break;
          }
        }
        this.emit("changed", this.results);
      };
      Query.prototype._handleExtra = function(extra) {
        this.extra = extra;
        this.emit("extra", extra);
      };
    }
  });

  // node_modules/sharedb/lib/client/presence/local-presence.js
  var require_local_presence = __commonJS({
    "node_modules/sharedb/lib/client/presence/local-presence.js"(exports, module) {
      init_mithril_shim();
      var emitter = require_emitter();
      var ACTIONS = require_message_actions().ACTIONS;
      var util = require_util();
      module.exports = LocalPresence;
      function LocalPresence(presence, presenceId) {
        emitter.EventEmitter.call(this);
        if (!presenceId || typeof presenceId !== "string") {
          throw new Error("LocalPresence presenceId must be a string");
        }
        this.presence = presence;
        this.presenceId = presenceId;
        this.connection = presence.connection;
        this.presenceVersion = 0;
        this.value = null;
        this._pendingMessages = [];
        this._callbacksByPresenceVersion = {};
      }
      emitter.mixin(LocalPresence);
      LocalPresence.prototype.submit = function(value, callback) {
        this.value = value;
        this.send(callback);
      };
      LocalPresence.prototype.send = function(callback) {
        var message = this._message();
        this._pendingMessages.push(message);
        this._callbacksByPresenceVersion[message.pv] = callback;
        this._sendPending();
      };
      LocalPresence.prototype.destroy = function(callback) {
        var presence = this;
        this.submit(null, function(error) {
          if (error)
            return presence._callbackOrEmit(error, callback);
          delete presence.presence.localPresences[presence.presenceId];
          if (callback)
            callback();
        });
      };
      LocalPresence.prototype._sendPending = function() {
        if (!this.connection.canSend)
          return;
        var presence = this;
        this._pendingMessages.forEach(function(message) {
          presence.connection.send(message);
        });
        this._pendingMessages = [];
      };
      LocalPresence.prototype._ack = function(error, presenceVersion) {
        var callback = this._getCallback(presenceVersion);
        this._callbackOrEmit(error, callback);
      };
      LocalPresence.prototype._message = function() {
        return {
          a: ACTIONS.presence,
          ch: this.presence.channel,
          id: this.presenceId,
          p: this.value,
          pv: this.presenceVersion++
        };
      };
      LocalPresence.prototype._getCallback = function(presenceVersion) {
        var callback = this._callbacksByPresenceVersion[presenceVersion];
        delete this._callbacksByPresenceVersion[presenceVersion];
        return callback;
      };
      LocalPresence.prototype._callbackOrEmit = function(error, callback) {
        if (callback)
          return util.nextTick(callback, error);
        if (error)
          this.emit("error", error);
      };
    }
  });

  // node_modules/sharedb/lib/client/presence/remote-presence.js
  var require_remote_presence = __commonJS({
    "node_modules/sharedb/lib/client/presence/remote-presence.js"(exports, module) {
      init_mithril_shim();
      var util = require_util();
      module.exports = RemotePresence;
      function RemotePresence(presence, presenceId) {
        this.presence = presence;
        this.presenceId = presenceId;
        this.connection = this.presence.connection;
        this.value = null;
        this.presenceVersion = 0;
      }
      RemotePresence.prototype.receiveUpdate = function(message) {
        if (message.pv < this.presenceVersion)
          return;
        this.value = message.p;
        this.presenceVersion = message.pv;
        this.presence._updateRemotePresence(this);
      };
      RemotePresence.prototype.destroy = function(callback) {
        delete this.presence._remotePresenceInstances[this.presenceId];
        delete this.presence.remotePresences[this.presenceId];
        if (callback)
          util.nextTick(callback);
      };
    }
  });

  // node_modules/async/dist/async.js
  var require_async = __commonJS({
    "node_modules/async/dist/async.js"(exports, module) {
      init_mithril_shim();
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.async = {});
      })(exports, function(exports2) {
        "use strict";
        function apply(fn, ...args) {
          return (...callArgs) => fn(...args, ...callArgs);
        }
        function initialParams(fn) {
          return function(...args) {
            var callback = args.pop();
            return fn.call(this, args, callback);
          };
        }
        var hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
        var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
        var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
        function fallback(fn) {
          setTimeout(fn, 0);
        }
        function wrap(defer) {
          return (fn, ...args) => defer(() => fn(...args));
        }
        var _defer;
        if (hasQueueMicrotask) {
          _defer = queueMicrotask;
        } else if (hasSetImmediate) {
          _defer = setImmediate;
        } else if (hasNextTick) {
          _defer = process.nextTick;
        } else {
          _defer = fallback;
        }
        var setImmediate$1 = wrap(_defer);
        function asyncify(func) {
          if (isAsync(func)) {
            return function(...args) {
              const callback = args.pop();
              const promise = func.apply(this, args);
              return handlePromise(promise, callback);
            };
          }
          return initialParams(function(args, callback) {
            var result;
            try {
              result = func.apply(this, args);
            } catch (e) {
              return callback(e);
            }
            if (result && typeof result.then === "function") {
              return handlePromise(result, callback);
            } else {
              callback(null, result);
            }
          });
        }
        function handlePromise(promise, callback) {
          return promise.then((value) => {
            invokeCallback(callback, null, value);
          }, (err) => {
            invokeCallback(callback, err && err.message ? err : new Error(err));
          });
        }
        function invokeCallback(callback, error, value) {
          try {
            callback(error, value);
          } catch (err) {
            setImmediate$1((e) => {
              throw e;
            }, err);
          }
        }
        function isAsync(fn) {
          return fn[Symbol.toStringTag] === "AsyncFunction";
        }
        function isAsyncGenerator(fn) {
          return fn[Symbol.toStringTag] === "AsyncGenerator";
        }
        function isAsyncIterable(obj) {
          return typeof obj[Symbol.asyncIterator] === "function";
        }
        function wrapAsync(asyncFn) {
          if (typeof asyncFn !== "function")
            throw new Error("expected a function");
          return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
        }
        function awaitify(asyncFn, arity = asyncFn.length) {
          if (!arity)
            throw new Error("arity is undefined");
          function awaitable(...args) {
            if (typeof args[arity - 1] === "function") {
              return asyncFn.apply(this, args);
            }
            return new Promise((resolve, reject2) => {
              args[arity - 1] = (err, ...cbArgs) => {
                if (err)
                  return reject2(err);
                resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
              };
              asyncFn.apply(this, args);
            });
          }
          return awaitable;
        }
        function applyEach(eachfn) {
          return function applyEach2(fns, ...callArgs) {
            const go = awaitify(function(callback) {
              var that = this;
              return eachfn(fns, (fn, cb) => {
                wrapAsync(fn).apply(that, callArgs.concat(cb));
              }, callback);
            });
            return go;
          };
        }
        function _asyncMap(eachfn, arr, iteratee, callback) {
          arr = arr || [];
          var results = [];
          var counter = 0;
          var _iteratee = wrapAsync(iteratee);
          return eachfn(arr, (value, _, iterCb) => {
            var index2 = counter++;
            _iteratee(value, (err, v) => {
              results[index2] = v;
              iterCb(err);
            });
          }, (err) => {
            callback(err, results);
          });
        }
        function isArrayLike(value) {
          return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
        }
        const breakLoop = {};
        function once(fn) {
          function wrapper(...args) {
            if (fn === null)
              return;
            var callFn = fn;
            fn = null;
            callFn.apply(this, args);
          }
          Object.assign(wrapper, fn);
          return wrapper;
        }
        function getIterator(coll) {
          return coll[Symbol.iterator] && coll[Symbol.iterator]();
        }
        function createArrayIterator(coll) {
          var i = -1;
          var len = coll.length;
          return function next() {
            return ++i < len ? { value: coll[i], key: i } : null;
          };
        }
        function createES2015Iterator(iterator) {
          var i = -1;
          return function next() {
            var item = iterator.next();
            if (item.done)
              return null;
            i++;
            return { value: item.value, key: i };
          };
        }
        function createObjectIterator(obj) {
          var okeys = obj ? Object.keys(obj) : [];
          var i = -1;
          var len = okeys.length;
          return function next() {
            var key = okeys[++i];
            if (key === "__proto__") {
              return next();
            }
            return i < len ? { value: obj[key], key } : null;
          };
        }
        function createIterator(coll) {
          if (isArrayLike(coll)) {
            return createArrayIterator(coll);
          }
          var iterator = getIterator(coll);
          return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
        }
        function onlyOnce(fn) {
          return function(...args) {
            if (fn === null)
              throw new Error("Callback was already called.");
            var callFn = fn;
            fn = null;
            callFn.apply(this, args);
          };
        }
        function asyncEachOfLimit(generator, limit, iteratee, callback) {
          let done = false;
          let canceled = false;
          let awaiting = false;
          let running = 0;
          let idx = 0;
          function replenish() {
            if (running >= limit || awaiting || done)
              return;
            awaiting = true;
            generator.next().then(({ value, done: iterDone }) => {
              if (canceled || done)
                return;
              awaiting = false;
              if (iterDone) {
                done = true;
                if (running <= 0) {
                  callback(null);
                }
                return;
              }
              running++;
              iteratee(value, idx, iterateeCallback);
              idx++;
              replenish();
            }).catch(handleError);
          }
          function iterateeCallback(err, result) {
            running -= 1;
            if (canceled)
              return;
            if (err)
              return handleError(err);
            if (err === false) {
              done = true;
              canceled = true;
              return;
            }
            if (result === breakLoop || done && running <= 0) {
              done = true;
              return callback(null);
            }
            replenish();
          }
          function handleError(err) {
            if (canceled)
              return;
            awaiting = false;
            done = true;
            callback(err);
          }
          replenish();
        }
        var eachOfLimit = (limit) => {
          return (obj, iteratee, callback) => {
            callback = once(callback);
            if (limit <= 0) {
              throw new RangeError("concurrency limit cannot be less than 1");
            }
            if (!obj) {
              return callback(null);
            }
            if (isAsyncGenerator(obj)) {
              return asyncEachOfLimit(obj, limit, iteratee, callback);
            }
            if (isAsyncIterable(obj)) {
              return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
            }
            var nextElem = createIterator(obj);
            var done = false;
            var canceled = false;
            var running = 0;
            var looping = false;
            function iterateeCallback(err, value) {
              if (canceled)
                return;
              running -= 1;
              if (err) {
                done = true;
                callback(err);
              } else if (err === false) {
                done = true;
                canceled = true;
              } else if (value === breakLoop || done && running <= 0) {
                done = true;
                return callback(null);
              } else if (!looping) {
                replenish();
              }
            }
            function replenish() {
              looping = true;
              while (running < limit && !done) {
                var elem = nextElem();
                if (elem === null) {
                  done = true;
                  if (running <= 0) {
                    callback(null);
                  }
                  return;
                }
                running += 1;
                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
              }
              looping = false;
            }
            replenish();
          };
        };
        function eachOfLimit$1(coll, limit, iteratee, callback) {
          return eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
        }
        var eachOfLimit$2 = awaitify(eachOfLimit$1, 4);
        function eachOfArrayLike(coll, iteratee, callback) {
          callback = once(callback);
          var index2 = 0, completed = 0, { length } = coll, canceled = false;
          if (length === 0) {
            callback(null);
          }
          function iteratorCallback(err, value) {
            if (err === false) {
              canceled = true;
            }
            if (canceled === true)
              return;
            if (err) {
              callback(err);
            } else if (++completed === length || value === breakLoop) {
              callback(null);
            }
          }
          for (; index2 < length; index2++) {
            iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
          }
        }
        function eachOfGeneric(coll, iteratee, callback) {
          return eachOfLimit$2(coll, Infinity, iteratee, callback);
        }
        function eachOf(coll, iteratee, callback) {
          var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
          return eachOfImplementation(coll, wrapAsync(iteratee), callback);
        }
        var eachOf$1 = awaitify(eachOf, 3);
        function map(coll, iteratee, callback) {
          return _asyncMap(eachOf$1, coll, iteratee, callback);
        }
        var map$1 = awaitify(map, 3);
        var applyEach$1 = applyEach(map$1);
        function eachOfSeries(coll, iteratee, callback) {
          return eachOfLimit$2(coll, 1, iteratee, callback);
        }
        var eachOfSeries$1 = awaitify(eachOfSeries, 3);
        function mapSeries(coll, iteratee, callback) {
          return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
        }
        var mapSeries$1 = awaitify(mapSeries, 3);
        var applyEachSeries = applyEach(mapSeries$1);
        const PROMISE_SYMBOL = Symbol("promiseCallback");
        function promiseCallback() {
          let resolve, reject2;
          function callback(err, ...args) {
            if (err)
              return reject2(err);
            resolve(args.length > 1 ? args : args[0]);
          }
          callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
            resolve = res, reject2 = rej;
          });
          return callback;
        }
        function auto(tasks, concurrency, callback) {
          if (typeof concurrency !== "number") {
            callback = concurrency;
            concurrency = null;
          }
          callback = once(callback || promiseCallback());
          var numTasks = Object.keys(tasks).length;
          if (!numTasks) {
            return callback(null);
          }
          if (!concurrency) {
            concurrency = numTasks;
          }
          var results = {};
          var runningTasks = 0;
          var canceled = false;
          var hasError = false;
          var listeners = /* @__PURE__ */ Object.create(null);
          var readyTasks = [];
          var readyToCheck = [];
          var uncheckedDependencies = {};
          Object.keys(tasks).forEach((key) => {
            var task = tasks[key];
            if (!Array.isArray(task)) {
              enqueueTask(key, [task]);
              readyToCheck.push(key);
              return;
            }
            var dependencies = task.slice(0, task.length - 1);
            var remainingDependencies = dependencies.length;
            if (remainingDependencies === 0) {
              enqueueTask(key, task);
              readyToCheck.push(key);
              return;
            }
            uncheckedDependencies[key] = remainingDependencies;
            dependencies.forEach((dependencyName) => {
              if (!tasks[dependencyName]) {
                throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
              }
              addListener(dependencyName, () => {
                remainingDependencies--;
                if (remainingDependencies === 0) {
                  enqueueTask(key, task);
                }
              });
            });
          });
          checkForDeadlocks();
          processQueue();
          function enqueueTask(key, task) {
            readyTasks.push(() => runTask(key, task));
          }
          function processQueue() {
            if (canceled)
              return;
            if (readyTasks.length === 0 && runningTasks === 0) {
              return callback(null, results);
            }
            while (readyTasks.length && runningTasks < concurrency) {
              var run = readyTasks.shift();
              run();
            }
          }
          function addListener(taskName, fn) {
            var taskListeners = listeners[taskName];
            if (!taskListeners) {
              taskListeners = listeners[taskName] = [];
            }
            taskListeners.push(fn);
          }
          function taskComplete(taskName) {
            var taskListeners = listeners[taskName] || [];
            taskListeners.forEach((fn) => fn());
            processQueue();
          }
          function runTask(key, task) {
            if (hasError)
              return;
            var taskCallback = onlyOnce((err, ...result) => {
              runningTasks--;
              if (err === false) {
                canceled = true;
                return;
              }
              if (result.length < 2) {
                [result] = result;
              }
              if (err) {
                var safeResults = {};
                Object.keys(results).forEach((rkey) => {
                  safeResults[rkey] = results[rkey];
                });
                safeResults[key] = result;
                hasError = true;
                listeners = /* @__PURE__ */ Object.create(null);
                if (canceled)
                  return;
                callback(err, safeResults);
              } else {
                results[key] = result;
                taskComplete(key);
              }
            });
            runningTasks++;
            var taskFn = wrapAsync(task[task.length - 1]);
            if (task.length > 1) {
              taskFn(results, taskCallback);
            } else {
              taskFn(taskCallback);
            }
          }
          function checkForDeadlocks() {
            var currentTask;
            var counter = 0;
            while (readyToCheck.length) {
              currentTask = readyToCheck.pop();
              counter++;
              getDependents(currentTask).forEach((dependent) => {
                if (--uncheckedDependencies[dependent] === 0) {
                  readyToCheck.push(dependent);
                }
              });
            }
            if (counter !== numTasks) {
              throw new Error(
                "async.auto cannot execute tasks due to a recursive dependency"
              );
            }
          }
          function getDependents(taskName) {
            var result = [];
            Object.keys(tasks).forEach((key) => {
              const task = tasks[key];
              if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
                result.push(key);
              }
            });
            return result;
          }
          return callback[PROMISE_SYMBOL];
        }
        var FN_ARGS = /^(?:async\s+)?(?:function)?\s*\w*\s*\(\s*([^)]+)\s*\)(?:\s*{)/;
        var ARROW_FN_ARGS = /^(?:async\s+)?\(?\s*([^)=]+)\s*\)?(?:\s*=>)/;
        var FN_ARG_SPLIT = /,/;
        var FN_ARG = /(=.+)?(\s*)$/;
        function stripComments(string) {
          let stripped = "";
          let index2 = 0;
          let endBlockComment = string.indexOf("*/");
          while (index2 < string.length) {
            if (string[index2] === "/" && string[index2 + 1] === "/") {
              let endIndex = string.indexOf("\n", index2);
              index2 = endIndex === -1 ? string.length : endIndex;
            } else if (endBlockComment !== -1 && string[index2] === "/" && string[index2 + 1] === "*") {
              let endIndex = string.indexOf("*/", index2);
              if (endIndex !== -1) {
                index2 = endIndex + 2;
                endBlockComment = string.indexOf("*/", index2);
              } else {
                stripped += string[index2];
                index2++;
              }
            } else {
              stripped += string[index2];
              index2++;
            }
          }
          return stripped;
        }
        function parseParams(func) {
          const src = stripComments(func.toString());
          let match = src.match(FN_ARGS);
          if (!match) {
            match = src.match(ARROW_FN_ARGS);
          }
          if (!match)
            throw new Error("could not parse args in autoInject\nSource:\n" + src);
          let [, args] = match;
          return args.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg) => arg.replace(FN_ARG, "").trim());
        }
        function autoInject(tasks, callback) {
          var newTasks = {};
          Object.keys(tasks).forEach((key) => {
            var taskFn = tasks[key];
            var params;
            var fnIsAsync = isAsync(taskFn);
            var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
            if (Array.isArray(taskFn)) {
              params = [...taskFn];
              taskFn = params.pop();
              newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
            } else if (hasNoDeps) {
              newTasks[key] = taskFn;
            } else {
              params = parseParams(taskFn);
              if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
                throw new Error("autoInject task functions require explicit parameters.");
              }
              if (!fnIsAsync)
                params.pop();
              newTasks[key] = params.concat(newTask);
            }
            function newTask(results, taskCb) {
              var newArgs = params.map((name) => results[name]);
              newArgs.push(taskCb);
              wrapAsync(taskFn)(...newArgs);
            }
          });
          return auto(newTasks, callback);
        }
        class DLL {
          constructor() {
            this.head = this.tail = null;
            this.length = 0;
          }
          removeLink(node) {
            if (node.prev)
              node.prev.next = node.next;
            else
              this.head = node.next;
            if (node.next)
              node.next.prev = node.prev;
            else
              this.tail = node.prev;
            node.prev = node.next = null;
            this.length -= 1;
            return node;
          }
          empty() {
            while (this.head)
              this.shift();
            return this;
          }
          insertAfter(node, newNode) {
            newNode.prev = node;
            newNode.next = node.next;
            if (node.next)
              node.next.prev = newNode;
            else
              this.tail = newNode;
            node.next = newNode;
            this.length += 1;
          }
          insertBefore(node, newNode) {
            newNode.prev = node.prev;
            newNode.next = node;
            if (node.prev)
              node.prev.next = newNode;
            else
              this.head = newNode;
            node.prev = newNode;
            this.length += 1;
          }
          unshift(node) {
            if (this.head)
              this.insertBefore(this.head, node);
            else
              setInitial(this, node);
          }
          push(node) {
            if (this.tail)
              this.insertAfter(this.tail, node);
            else
              setInitial(this, node);
          }
          shift() {
            return this.head && this.removeLink(this.head);
          }
          pop() {
            return this.tail && this.removeLink(this.tail);
          }
          toArray() {
            return [...this];
          }
          *[Symbol.iterator]() {
            var cur = this.head;
            while (cur) {
              yield cur.data;
              cur = cur.next;
            }
          }
          remove(testFn) {
            var curr = this.head;
            while (curr) {
              var { next } = curr;
              if (testFn(curr)) {
                this.removeLink(curr);
              }
              curr = next;
            }
            return this;
          }
        }
        function setInitial(dll, node) {
          dll.length = 1;
          dll.head = dll.tail = node;
        }
        function queue(worker, concurrency, payload) {
          if (concurrency == null) {
            concurrency = 1;
          } else if (concurrency === 0) {
            throw new RangeError("Concurrency must not be zero");
          }
          var _worker = wrapAsync(worker);
          var numRunning = 0;
          var workersList = [];
          const events = {
            error: [],
            drain: [],
            saturated: [],
            unsaturated: [],
            empty: []
          };
          function on(event, handler) {
            events[event].push(handler);
          }
          function once2(event, handler) {
            const handleAndRemove = (...args) => {
              off(event, handleAndRemove);
              handler(...args);
            };
            events[event].push(handleAndRemove);
          }
          function off(event, handler) {
            if (!event)
              return Object.keys(events).forEach((ev) => events[ev] = []);
            if (!handler)
              return events[event] = [];
            events[event] = events[event].filter((ev) => ev !== handler);
          }
          function trigger(event, ...args) {
            events[event].forEach((handler) => handler(...args));
          }
          var processingScheduled = false;
          function _insert(data, insertAtFront, rejectOnError, callback) {
            if (callback != null && typeof callback !== "function") {
              throw new Error("task callback must be a function");
            }
            q.started = true;
            var res, rej;
            function promiseCallback2(err, ...args) {
              if (err)
                return rejectOnError ? rej(err) : res();
              if (args.length <= 1)
                return res(args[0]);
              res(args);
            }
            var item = q._createTaskItem(
              data,
              rejectOnError ? promiseCallback2 : callback || promiseCallback2
            );
            if (insertAtFront) {
              q._tasks.unshift(item);
            } else {
              q._tasks.push(item);
            }
            if (!processingScheduled) {
              processingScheduled = true;
              setImmediate$1(() => {
                processingScheduled = false;
                q.process();
              });
            }
            if (rejectOnError || !callback) {
              return new Promise((resolve, reject2) => {
                res = resolve;
                rej = reject2;
              });
            }
          }
          function _createCB(tasks) {
            return function(err, ...args) {
              numRunning -= 1;
              for (var i = 0, l = tasks.length; i < l; i++) {
                var task = tasks[i];
                var index2 = workersList.indexOf(task);
                if (index2 === 0) {
                  workersList.shift();
                } else if (index2 > 0) {
                  workersList.splice(index2, 1);
                }
                task.callback(err, ...args);
                if (err != null) {
                  trigger("error", err, task.data);
                }
              }
              if (numRunning <= q.concurrency - q.buffer) {
                trigger("unsaturated");
              }
              if (q.idle()) {
                trigger("drain");
              }
              q.process();
            };
          }
          function _maybeDrain(data) {
            if (data.length === 0 && q.idle()) {
              setImmediate$1(() => trigger("drain"));
              return true;
            }
            return false;
          }
          const eventMethod = (name) => (handler) => {
            if (!handler) {
              return new Promise((resolve, reject2) => {
                once2(name, (err, data) => {
                  if (err)
                    return reject2(err);
                  resolve(data);
                });
              });
            }
            off(name);
            on(name, handler);
          };
          var isProcessing = false;
          var q = {
            _tasks: new DLL(),
            _createTaskItem(data, callback) {
              return {
                data,
                callback
              };
            },
            *[Symbol.iterator]() {
              yield* q._tasks[Symbol.iterator]();
            },
            concurrency,
            payload,
            buffer: concurrency / 4,
            started: false,
            paused: false,
            push(data, callback) {
              if (Array.isArray(data)) {
                if (_maybeDrain(data))
                  return;
                return data.map((datum) => _insert(datum, false, false, callback));
              }
              return _insert(data, false, false, callback);
            },
            pushAsync(data, callback) {
              if (Array.isArray(data)) {
                if (_maybeDrain(data))
                  return;
                return data.map((datum) => _insert(datum, false, true, callback));
              }
              return _insert(data, false, true, callback);
            },
            kill() {
              off();
              q._tasks.empty();
            },
            unshift(data, callback) {
              if (Array.isArray(data)) {
                if (_maybeDrain(data))
                  return;
                return data.map((datum) => _insert(datum, true, false, callback));
              }
              return _insert(data, true, false, callback);
            },
            unshiftAsync(data, callback) {
              if (Array.isArray(data)) {
                if (_maybeDrain(data))
                  return;
                return data.map((datum) => _insert(datum, true, true, callback));
              }
              return _insert(data, true, true, callback);
            },
            remove(testFn) {
              q._tasks.remove(testFn);
            },
            process() {
              if (isProcessing) {
                return;
              }
              isProcessing = true;
              while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
                var tasks = [], data = [];
                var l = q._tasks.length;
                if (q.payload)
                  l = Math.min(l, q.payload);
                for (var i = 0; i < l; i++) {
                  var node = q._tasks.shift();
                  tasks.push(node);
                  workersList.push(node);
                  data.push(node.data);
                }
                numRunning += 1;
                if (q._tasks.length === 0) {
                  trigger("empty");
                }
                if (numRunning === q.concurrency) {
                  trigger("saturated");
                }
                var cb = onlyOnce(_createCB(tasks));
                _worker(data, cb);
              }
              isProcessing = false;
            },
            length() {
              return q._tasks.length;
            },
            running() {
              return numRunning;
            },
            workersList() {
              return workersList;
            },
            idle() {
              return q._tasks.length + numRunning === 0;
            },
            pause() {
              q.paused = true;
            },
            resume() {
              if (q.paused === false) {
                return;
              }
              q.paused = false;
              setImmediate$1(q.process);
            }
          };
          Object.defineProperties(q, {
            saturated: {
              writable: false,
              value: eventMethod("saturated")
            },
            unsaturated: {
              writable: false,
              value: eventMethod("unsaturated")
            },
            empty: {
              writable: false,
              value: eventMethod("empty")
            },
            drain: {
              writable: false,
              value: eventMethod("drain")
            },
            error: {
              writable: false,
              value: eventMethod("error")
            }
          });
          return q;
        }
        function cargo(worker, payload) {
          return queue(worker, 1, payload);
        }
        function cargo$1(worker, concurrency, payload) {
          return queue(worker, concurrency, payload);
        }
        function reduce(coll, memo, iteratee, callback) {
          callback = once(callback);
          var _iteratee = wrapAsync(iteratee);
          return eachOfSeries$1(coll, (x, i, iterCb) => {
            _iteratee(memo, x, (err, v) => {
              memo = v;
              iterCb(err);
            });
          }, (err) => callback(err, memo));
        }
        var reduce$1 = awaitify(reduce, 4);
        function seq(...functions) {
          var _functions = functions.map(wrapAsync);
          return function(...args) {
            var that = this;
            var cb = args[args.length - 1];
            if (typeof cb == "function") {
              args.pop();
            } else {
              cb = promiseCallback();
            }
            reduce$1(
              _functions,
              args,
              (newargs, fn, iterCb) => {
                fn.apply(that, newargs.concat((err, ...nextargs) => {
                  iterCb(err, nextargs);
                }));
              },
              (err, results) => cb(err, ...results)
            );
            return cb[PROMISE_SYMBOL];
          };
        }
        function compose(...args) {
          return seq(...args.reverse());
        }
        function mapLimit(coll, limit, iteratee, callback) {
          return _asyncMap(eachOfLimit(limit), coll, iteratee, callback);
        }
        var mapLimit$1 = awaitify(mapLimit, 4);
        function concatLimit(coll, limit, iteratee, callback) {
          var _iteratee = wrapAsync(iteratee);
          return mapLimit$1(coll, limit, (val, iterCb) => {
            _iteratee(val, (err, ...args) => {
              if (err)
                return iterCb(err);
              return iterCb(err, args);
            });
          }, (err, mapResults) => {
            var result = [];
            for (var i = 0; i < mapResults.length; i++) {
              if (mapResults[i]) {
                result = result.concat(...mapResults[i]);
              }
            }
            return callback(err, result);
          });
        }
        var concatLimit$1 = awaitify(concatLimit, 4);
        function concat(coll, iteratee, callback) {
          return concatLimit$1(coll, Infinity, iteratee, callback);
        }
        var concat$1 = awaitify(concat, 3);
        function concatSeries(coll, iteratee, callback) {
          return concatLimit$1(coll, 1, iteratee, callback);
        }
        var concatSeries$1 = awaitify(concatSeries, 3);
        function constant(...args) {
          return function(...ignoredArgs) {
            var callback = ignoredArgs.pop();
            return callback(null, ...args);
          };
        }
        function _createTester(check, getResult) {
          return (eachfn, arr, _iteratee, cb) => {
            var testPassed = false;
            var testResult;
            const iteratee = wrapAsync(_iteratee);
            eachfn(arr, (value, _, callback) => {
              iteratee(value, (err, result) => {
                if (err || err === false)
                  return callback(err);
                if (check(result) && !testResult) {
                  testPassed = true;
                  testResult = getResult(true, value);
                  return callback(null, breakLoop);
                }
                callback();
              });
            }, (err) => {
              if (err)
                return cb(err);
              cb(null, testPassed ? testResult : getResult(false));
            });
          };
        }
        function detect(coll, iteratee, callback) {
          return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
        }
        var detect$1 = awaitify(detect, 3);
        function detectLimit(coll, limit, iteratee, callback) {
          return _createTester((bool) => bool, (res, item) => item)(eachOfLimit(limit), coll, iteratee, callback);
        }
        var detectLimit$1 = awaitify(detectLimit, 4);
        function detectSeries(coll, iteratee, callback) {
          return _createTester((bool) => bool, (res, item) => item)(eachOfLimit(1), coll, iteratee, callback);
        }
        var detectSeries$1 = awaitify(detectSeries, 3);
        function consoleFunc(name) {
          return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
            if (typeof console === "object") {
              if (err) {
                if (console.error) {
                  console.error(err);
                }
              } else if (console[name]) {
                resultArgs.forEach((x) => console[name](x));
              }
            }
          });
        }
        var dir = consoleFunc("dir");
        function doWhilst(iteratee, test, callback) {
          callback = onlyOnce(callback);
          var _fn = wrapAsync(iteratee);
          var _test = wrapAsync(test);
          var results;
          function next(err, ...args) {
            if (err)
              return callback(err);
            if (err === false)
              return;
            results = args;
            _test(...args, check);
          }
          function check(err, truth) {
            if (err)
              return callback(err);
            if (err === false)
              return;
            if (!truth)
              return callback(null, ...results);
            _fn(next);
          }
          return check(null, true);
        }
        var doWhilst$1 = awaitify(doWhilst, 3);
        function doUntil(iteratee, test, callback) {
          const _test = wrapAsync(test);
          return doWhilst$1(iteratee, (...args) => {
            const cb = args.pop();
            _test(...args, (err, truth) => cb(err, !truth));
          }, callback);
        }
        function _withoutIndex(iteratee) {
          return (value, index2, callback) => iteratee(value, callback);
        }
        function eachLimit(coll, iteratee, callback) {
          return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
        }
        var each = awaitify(eachLimit, 3);
        function eachLimit$1(coll, limit, iteratee, callback) {
          return eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
        }
        var eachLimit$2 = awaitify(eachLimit$1, 4);
        function eachSeries(coll, iteratee, callback) {
          return eachLimit$2(coll, 1, iteratee, callback);
        }
        var eachSeries$1 = awaitify(eachSeries, 3);
        function ensureAsync(fn) {
          if (isAsync(fn))
            return fn;
          return function(...args) {
            var callback = args.pop();
            var sync = true;
            args.push((...innerArgs) => {
              if (sync) {
                setImmediate$1(() => callback(...innerArgs));
              } else {
                callback(...innerArgs);
              }
            });
            fn.apply(this, args);
            sync = false;
          };
        }
        function every(coll, iteratee, callback) {
          return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
        }
        var every$1 = awaitify(every, 3);
        function everyLimit(coll, limit, iteratee, callback) {
          return _createTester((bool) => !bool, (res) => !res)(eachOfLimit(limit), coll, iteratee, callback);
        }
        var everyLimit$1 = awaitify(everyLimit, 4);
        function everySeries(coll, iteratee, callback) {
          return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
        }
        var everySeries$1 = awaitify(everySeries, 3);
        function filterArray(eachfn, arr, iteratee, callback) {
          var truthValues = new Array(arr.length);
          eachfn(arr, (x, index2, iterCb) => {
            iteratee(x, (err, v) => {
              truthValues[index2] = !!v;
              iterCb(err);
            });
          }, (err) => {
            if (err)
              return callback(err);
            var results = [];
            for (var i = 0; i < arr.length; i++) {
              if (truthValues[i])
                results.push(arr[i]);
            }
            callback(null, results);
          });
        }
        function filterGeneric(eachfn, coll, iteratee, callback) {
          var results = [];
          eachfn(coll, (x, index2, iterCb) => {
            iteratee(x, (err, v) => {
              if (err)
                return iterCb(err);
              if (v) {
                results.push({ index: index2, value: x });
              }
              iterCb(err);
            });
          }, (err) => {
            if (err)
              return callback(err);
            callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
          });
        }
        function _filter(eachfn, coll, iteratee, callback) {
          var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
          return filter2(eachfn, coll, wrapAsync(iteratee), callback);
        }
        function filter(coll, iteratee, callback) {
          return _filter(eachOf$1, coll, iteratee, callback);
        }
        var filter$1 = awaitify(filter, 3);
        function filterLimit(coll, limit, iteratee, callback) {
          return _filter(eachOfLimit(limit), coll, iteratee, callback);
        }
        var filterLimit$1 = awaitify(filterLimit, 4);
        function filterSeries(coll, iteratee, callback) {
          return _filter(eachOfSeries$1, coll, iteratee, callback);
        }
        var filterSeries$1 = awaitify(filterSeries, 3);
        function forever(fn, errback) {
          var done = onlyOnce(errback);
          var task = wrapAsync(ensureAsync(fn));
          function next(err) {
            if (err)
              return done(err);
            if (err === false)
              return;
            task(next);
          }
          return next();
        }
        var forever$1 = awaitify(forever, 2);
        function groupByLimit(coll, limit, iteratee, callback) {
          var _iteratee = wrapAsync(iteratee);
          return mapLimit$1(coll, limit, (val, iterCb) => {
            _iteratee(val, (err, key) => {
              if (err)
                return iterCb(err);
              return iterCb(err, { key, val });
            });
          }, (err, mapResults) => {
            var result = {};
            var { hasOwnProperty } = Object.prototype;
            for (var i = 0; i < mapResults.length; i++) {
              if (mapResults[i]) {
                var { key } = mapResults[i];
                var { val } = mapResults[i];
                if (hasOwnProperty.call(result, key)) {
                  result[key].push(val);
                } else {
                  result[key] = [val];
                }
              }
            }
            return callback(err, result);
          });
        }
        var groupByLimit$1 = awaitify(groupByLimit, 4);
        function groupBy(coll, iteratee, callback) {
          return groupByLimit$1(coll, Infinity, iteratee, callback);
        }
        function groupBySeries(coll, iteratee, callback) {
          return groupByLimit$1(coll, 1, iteratee, callback);
        }
        var log = consoleFunc("log");
        function mapValuesLimit(obj, limit, iteratee, callback) {
          callback = once(callback);
          var newObj = {};
          var _iteratee = wrapAsync(iteratee);
          return eachOfLimit(limit)(obj, (val, key, next) => {
            _iteratee(val, key, (err, result) => {
              if (err)
                return next(err);
              newObj[key] = result;
              next(err);
            });
          }, (err) => callback(err, newObj));
        }
        var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
        function mapValues(obj, iteratee, callback) {
          return mapValuesLimit$1(obj, Infinity, iteratee, callback);
        }
        function mapValuesSeries(obj, iteratee, callback) {
          return mapValuesLimit$1(obj, 1, iteratee, callback);
        }
        function memoize(fn, hasher = (v) => v) {
          var memo = /* @__PURE__ */ Object.create(null);
          var queues = /* @__PURE__ */ Object.create(null);
          var _fn = wrapAsync(fn);
          var memoized = initialParams((args, callback) => {
            var key = hasher(...args);
            if (key in memo) {
              setImmediate$1(() => callback(null, ...memo[key]));
            } else if (key in queues) {
              queues[key].push(callback);
            } else {
              queues[key] = [callback];
              _fn(...args, (err, ...resultArgs) => {
                if (!err) {
                  memo[key] = resultArgs;
                }
                var q = queues[key];
                delete queues[key];
                for (var i = 0, l = q.length; i < l; i++) {
                  q[i](err, ...resultArgs);
                }
              });
            }
          });
          memoized.memo = memo;
          memoized.unmemoized = fn;
          return memoized;
        }
        var _defer$1;
        if (hasNextTick) {
          _defer$1 = process.nextTick;
        } else if (hasSetImmediate) {
          _defer$1 = setImmediate;
        } else {
          _defer$1 = fallback;
        }
        var nextTick = wrap(_defer$1);
        var parallel = awaitify((eachfn, tasks, callback) => {
          var results = isArrayLike(tasks) ? [] : {};
          eachfn(tasks, (task, key, taskCb) => {
            wrapAsync(task)((err, ...result) => {
              if (result.length < 2) {
                [result] = result;
              }
              results[key] = result;
              taskCb(err);
            });
          }, (err) => callback(err, results));
        }, 3);
        function parallel$1(tasks, callback) {
          return parallel(eachOf$1, tasks, callback);
        }
        function parallelLimit(tasks, limit, callback) {
          return parallel(eachOfLimit(limit), tasks, callback);
        }
        function queue$1(worker, concurrency) {
          var _worker = wrapAsync(worker);
          return queue((items, cb) => {
            _worker(items[0], cb);
          }, concurrency, 1);
        }
        class Heap {
          constructor() {
            this.heap = [];
            this.pushCount = Number.MIN_SAFE_INTEGER;
          }
          get length() {
            return this.heap.length;
          }
          empty() {
            this.heap = [];
            return this;
          }
          percUp(index2) {
            let p;
            while (index2 > 0 && smaller(this.heap[index2], this.heap[p = parent(index2)])) {
              let t = this.heap[index2];
              this.heap[index2] = this.heap[p];
              this.heap[p] = t;
              index2 = p;
            }
          }
          percDown(index2) {
            let l;
            while ((l = leftChi(index2)) < this.heap.length) {
              if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) {
                l = l + 1;
              }
              if (smaller(this.heap[index2], this.heap[l])) {
                break;
              }
              let t = this.heap[index2];
              this.heap[index2] = this.heap[l];
              this.heap[l] = t;
              index2 = l;
            }
          }
          push(node) {
            node.pushCount = ++this.pushCount;
            this.heap.push(node);
            this.percUp(this.heap.length - 1);
          }
          unshift(node) {
            return this.heap.push(node);
          }
          shift() {
            let [top] = this.heap;
            this.heap[0] = this.heap[this.heap.length - 1];
            this.heap.pop();
            this.percDown(0);
            return top;
          }
          toArray() {
            return [...this];
          }
          *[Symbol.iterator]() {
            for (let i = 0; i < this.heap.length; i++) {
              yield this.heap[i].data;
            }
          }
          remove(testFn) {
            let j = 0;
            for (let i = 0; i < this.heap.length; i++) {
              if (!testFn(this.heap[i])) {
                this.heap[j] = this.heap[i];
                j++;
              }
            }
            this.heap.splice(j);
            for (let i = parent(this.heap.length - 1); i >= 0; i--) {
              this.percDown(i);
            }
            return this;
          }
        }
        function leftChi(i) {
          return (i << 1) + 1;
        }
        function parent(i) {
          return (i + 1 >> 1) - 1;
        }
        function smaller(x, y) {
          if (x.priority !== y.priority) {
            return x.priority < y.priority;
          } else {
            return x.pushCount < y.pushCount;
          }
        }
        function priorityQueue(worker, concurrency) {
          var q = queue$1(worker, concurrency);
          var {
            push,
            pushAsync
          } = q;
          q._tasks = new Heap();
          q._createTaskItem = ({ data, priority }, callback) => {
            return {
              data,
              priority,
              callback
            };
          };
          function createDataItems(tasks, priority) {
            if (!Array.isArray(tasks)) {
              return { data: tasks, priority };
            }
            return tasks.map((data) => {
              return { data, priority };
            });
          }
          q.push = function(data, priority = 0, callback) {
            return push(createDataItems(data, priority), callback);
          };
          q.pushAsync = function(data, priority = 0, callback) {
            return pushAsync(createDataItems(data, priority), callback);
          };
          delete q.unshift;
          delete q.unshiftAsync;
          return q;
        }
        function race(tasks, callback) {
          callback = once(callback);
          if (!Array.isArray(tasks))
            return callback(new TypeError("First argument to race must be an array of functions"));
          if (!tasks.length)
            return callback();
          for (var i = 0, l = tasks.length; i < l; i++) {
            wrapAsync(tasks[i])(callback);
          }
        }
        var race$1 = awaitify(race, 2);
        function reduceRight(array, memo, iteratee, callback) {
          var reversed = [...array].reverse();
          return reduce$1(reversed, memo, iteratee, callback);
        }
        function reflect(fn) {
          var _fn = wrapAsync(fn);
          return initialParams(function reflectOn(args, reflectCallback) {
            args.push((error, ...cbArgs) => {
              let retVal = {};
              if (error) {
                retVal.error = error;
              }
              if (cbArgs.length > 0) {
                var value = cbArgs;
                if (cbArgs.length <= 1) {
                  [value] = cbArgs;
                }
                retVal.value = value;
              }
              reflectCallback(null, retVal);
            });
            return _fn.apply(this, args);
          });
        }
        function reflectAll(tasks) {
          var results;
          if (Array.isArray(tasks)) {
            results = tasks.map(reflect);
          } else {
            results = {};
            Object.keys(tasks).forEach((key) => {
              results[key] = reflect.call(this, tasks[key]);
            });
          }
          return results;
        }
        function reject(eachfn, arr, _iteratee, callback) {
          const iteratee = wrapAsync(_iteratee);
          return _filter(eachfn, arr, (value, cb) => {
            iteratee(value, (err, v) => {
              cb(err, !v);
            });
          }, callback);
        }
        function reject$1(coll, iteratee, callback) {
          return reject(eachOf$1, coll, iteratee, callback);
        }
        var reject$2 = awaitify(reject$1, 3);
        function rejectLimit(coll, limit, iteratee, callback) {
          return reject(eachOfLimit(limit), coll, iteratee, callback);
        }
        var rejectLimit$1 = awaitify(rejectLimit, 4);
        function rejectSeries(coll, iteratee, callback) {
          return reject(eachOfSeries$1, coll, iteratee, callback);
        }
        var rejectSeries$1 = awaitify(rejectSeries, 3);
        function constant$1(value) {
          return function() {
            return value;
          };
        }
        const DEFAULT_TIMES = 5;
        const DEFAULT_INTERVAL = 0;
        function retry(opts, task, callback) {
          var options = {
            times: DEFAULT_TIMES,
            intervalFunc: constant$1(DEFAULT_INTERVAL)
          };
          if (arguments.length < 3 && typeof opts === "function") {
            callback = task || promiseCallback();
            task = opts;
          } else {
            parseTimes(options, opts);
            callback = callback || promiseCallback();
          }
          if (typeof task !== "function") {
            throw new Error("Invalid arguments for async.retry");
          }
          var _task = wrapAsync(task);
          var attempt = 1;
          function retryAttempt() {
            _task((err, ...args) => {
              if (err === false)
                return;
              if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
                setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
              } else {
                callback(err, ...args);
              }
            });
          }
          retryAttempt();
          return callback[PROMISE_SYMBOL];
        }
        function parseTimes(acc, t) {
          if (typeof t === "object") {
            acc.times = +t.times || DEFAULT_TIMES;
            acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);
            acc.errorFilter = t.errorFilter;
          } else if (typeof t === "number" || typeof t === "string") {
            acc.times = +t || DEFAULT_TIMES;
          } else {
            throw new Error("Invalid arguments for async.retry");
          }
        }
        function retryable(opts, task) {
          if (!task) {
            task = opts;
            opts = null;
          }
          let arity = opts && opts.arity || task.length;
          if (isAsync(task)) {
            arity += 1;
          }
          var _task = wrapAsync(task);
          return initialParams((args, callback) => {
            if (args.length < arity - 1 || callback == null) {
              args.push(callback);
              callback = promiseCallback();
            }
            function taskFn(cb) {
              _task(...args, cb);
            }
            if (opts)
              retry(opts, taskFn, callback);
            else
              retry(taskFn, callback);
            return callback[PROMISE_SYMBOL];
          });
        }
        function series(tasks, callback) {
          return parallel(eachOfSeries$1, tasks, callback);
        }
        function some(coll, iteratee, callback) {
          return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
        }
        var some$1 = awaitify(some, 3);
        function someLimit(coll, limit, iteratee, callback) {
          return _createTester(Boolean, (res) => res)(eachOfLimit(limit), coll, iteratee, callback);
        }
        var someLimit$1 = awaitify(someLimit, 4);
        function someSeries(coll, iteratee, callback) {
          return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
        }
        var someSeries$1 = awaitify(someSeries, 3);
        function sortBy(coll, iteratee, callback) {
          var _iteratee = wrapAsync(iteratee);
          return map$1(coll, (x, iterCb) => {
            _iteratee(x, (err, criteria) => {
              if (err)
                return iterCb(err);
              iterCb(err, { value: x, criteria });
            });
          }, (err, results) => {
            if (err)
              return callback(err);
            callback(null, results.sort(comparator).map((v) => v.value));
          });
          function comparator(left, right) {
            var a = left.criteria, b = right.criteria;
            return a < b ? -1 : a > b ? 1 : 0;
          }
        }
        var sortBy$1 = awaitify(sortBy, 3);
        function timeout(asyncFn, milliseconds, info) {
          var fn = wrapAsync(asyncFn);
          return initialParams((args, callback) => {
            var timedOut = false;
            var timer;
            function timeoutCallback() {
              var name = asyncFn.name || "anonymous";
              var error = new Error('Callback function "' + name + '" timed out.');
              error.code = "ETIMEDOUT";
              if (info) {
                error.info = info;
              }
              timedOut = true;
              callback(error);
            }
            args.push((...cbArgs) => {
              if (!timedOut) {
                callback(...cbArgs);
                clearTimeout(timer);
              }
            });
            timer = setTimeout(timeoutCallback, milliseconds);
            fn(...args);
          });
        }
        function range(size) {
          var result = Array(size);
          while (size--) {
            result[size] = size;
          }
          return result;
        }
        function timesLimit(count, limit, iteratee, callback) {
          var _iteratee = wrapAsync(iteratee);
          return mapLimit$1(range(count), limit, _iteratee, callback);
        }
        function times(n, iteratee, callback) {
          return timesLimit(n, Infinity, iteratee, callback);
        }
        function timesSeries(n, iteratee, callback) {
          return timesLimit(n, 1, iteratee, callback);
        }
        function transform(coll, accumulator, iteratee, callback) {
          if (arguments.length <= 3 && typeof accumulator === "function") {
            callback = iteratee;
            iteratee = accumulator;
            accumulator = Array.isArray(coll) ? [] : {};
          }
          callback = once(callback || promiseCallback());
          var _iteratee = wrapAsync(iteratee);
          eachOf$1(coll, (v, k, cb) => {
            _iteratee(accumulator, v, k, cb);
          }, (err) => callback(err, accumulator));
          return callback[PROMISE_SYMBOL];
        }
        function tryEach(tasks, callback) {
          var error = null;
          var result;
          return eachSeries$1(tasks, (task, taskCb) => {
            wrapAsync(task)((err, ...args) => {
              if (err === false)
                return taskCb(err);
              if (args.length < 2) {
                [result] = args;
              } else {
                result = args;
              }
              error = err;
              taskCb(err ? null : {});
            });
          }, () => callback(error, result));
        }
        var tryEach$1 = awaitify(tryEach);
        function unmemoize(fn) {
          return (...args) => {
            return (fn.unmemoized || fn)(...args);
          };
        }
        function whilst(test, iteratee, callback) {
          callback = onlyOnce(callback);
          var _fn = wrapAsync(iteratee);
          var _test = wrapAsync(test);
          var results = [];
          function next(err, ...rest) {
            if (err)
              return callback(err);
            results = rest;
            if (err === false)
              return;
            _test(check);
          }
          function check(err, truth) {
            if (err)
              return callback(err);
            if (err === false)
              return;
            if (!truth)
              return callback(null, ...results);
            _fn(next);
          }
          return _test(check);
        }
        var whilst$1 = awaitify(whilst, 3);
        function until(test, iteratee, callback) {
          const _test = wrapAsync(test);
          return whilst$1((cb) => _test((err, truth) => cb(err, !truth)), iteratee, callback);
        }
        function waterfall(tasks, callback) {
          callback = once(callback);
          if (!Array.isArray(tasks))
            return callback(new Error("First argument to waterfall must be an array of functions"));
          if (!tasks.length)
            return callback();
          var taskIndex = 0;
          function nextTask(args) {
            var task = wrapAsync(tasks[taskIndex++]);
            task(...args, onlyOnce(next));
          }
          function next(err, ...args) {
            if (err === false)
              return;
            if (err || taskIndex === tasks.length) {
              return callback(err, ...args);
            }
            nextTask(args);
          }
          nextTask([]);
        }
        var waterfall$1 = awaitify(waterfall);
        var index = {
          apply,
          applyEach: applyEach$1,
          applyEachSeries,
          asyncify,
          auto,
          autoInject,
          cargo,
          cargoQueue: cargo$1,
          compose,
          concat: concat$1,
          concatLimit: concatLimit$1,
          concatSeries: concatSeries$1,
          constant,
          detect: detect$1,
          detectLimit: detectLimit$1,
          detectSeries: detectSeries$1,
          dir,
          doUntil,
          doWhilst: doWhilst$1,
          each,
          eachLimit: eachLimit$2,
          eachOf: eachOf$1,
          eachOfLimit: eachOfLimit$2,
          eachOfSeries: eachOfSeries$1,
          eachSeries: eachSeries$1,
          ensureAsync,
          every: every$1,
          everyLimit: everyLimit$1,
          everySeries: everySeries$1,
          filter: filter$1,
          filterLimit: filterLimit$1,
          filterSeries: filterSeries$1,
          forever: forever$1,
          groupBy,
          groupByLimit: groupByLimit$1,
          groupBySeries,
          log,
          map: map$1,
          mapLimit: mapLimit$1,
          mapSeries: mapSeries$1,
          mapValues,
          mapValuesLimit: mapValuesLimit$1,
          mapValuesSeries,
          memoize,
          nextTick,
          parallel: parallel$1,
          parallelLimit,
          priorityQueue,
          queue: queue$1,
          race: race$1,
          reduce: reduce$1,
          reduceRight,
          reflect,
          reflectAll,
          reject: reject$2,
          rejectLimit: rejectLimit$1,
          rejectSeries: rejectSeries$1,
          retry,
          retryable,
          seq,
          series,
          setImmediate: setImmediate$1,
          some: some$1,
          someLimit: someLimit$1,
          someSeries: someSeries$1,
          sortBy: sortBy$1,
          timeout,
          times,
          timesLimit,
          timesSeries,
          transform,
          tryEach: tryEach$1,
          unmemoize,
          until,
          waterfall: waterfall$1,
          whilst: whilst$1,
          all: every$1,
          allLimit: everyLimit$1,
          allSeries: everySeries$1,
          any: some$1,
          anyLimit: someLimit$1,
          anySeries: someSeries$1,
          find: detect$1,
          findLimit: detectLimit$1,
          findSeries: detectSeries$1,
          flatMap: concat$1,
          flatMapLimit: concatLimit$1,
          flatMapSeries: concatSeries$1,
          forEach: each,
          forEachSeries: eachSeries$1,
          forEachLimit: eachLimit$2,
          forEachOf: eachOf$1,
          forEachOfSeries: eachOfSeries$1,
          forEachOfLimit: eachOfLimit$2,
          inject: reduce$1,
          foldl: reduce$1,
          foldr: reduceRight,
          select: filter$1,
          selectLimit: filterLimit$1,
          selectSeries: filterSeries$1,
          wrapSync: asyncify,
          during: whilst$1,
          doDuring: doWhilst$1
        };
        exports2.default = index;
        exports2.apply = apply;
        exports2.applyEach = applyEach$1;
        exports2.applyEachSeries = applyEachSeries;
        exports2.asyncify = asyncify;
        exports2.auto = auto;
        exports2.autoInject = autoInject;
        exports2.cargo = cargo;
        exports2.cargoQueue = cargo$1;
        exports2.compose = compose;
        exports2.concat = concat$1;
        exports2.concatLimit = concatLimit$1;
        exports2.concatSeries = concatSeries$1;
        exports2.constant = constant;
        exports2.detect = detect$1;
        exports2.detectLimit = detectLimit$1;
        exports2.detectSeries = detectSeries$1;
        exports2.dir = dir;
        exports2.doUntil = doUntil;
        exports2.doWhilst = doWhilst$1;
        exports2.each = each;
        exports2.eachLimit = eachLimit$2;
        exports2.eachOf = eachOf$1;
        exports2.eachOfLimit = eachOfLimit$2;
        exports2.eachOfSeries = eachOfSeries$1;
        exports2.eachSeries = eachSeries$1;
        exports2.ensureAsync = ensureAsync;
        exports2.every = every$1;
        exports2.everyLimit = everyLimit$1;
        exports2.everySeries = everySeries$1;
        exports2.filter = filter$1;
        exports2.filterLimit = filterLimit$1;
        exports2.filterSeries = filterSeries$1;
        exports2.forever = forever$1;
        exports2.groupBy = groupBy;
        exports2.groupByLimit = groupByLimit$1;
        exports2.groupBySeries = groupBySeries;
        exports2.log = log;
        exports2.map = map$1;
        exports2.mapLimit = mapLimit$1;
        exports2.mapSeries = mapSeries$1;
        exports2.mapValues = mapValues;
        exports2.mapValuesLimit = mapValuesLimit$1;
        exports2.mapValuesSeries = mapValuesSeries;
        exports2.memoize = memoize;
        exports2.nextTick = nextTick;
        exports2.parallel = parallel$1;
        exports2.parallelLimit = parallelLimit;
        exports2.priorityQueue = priorityQueue;
        exports2.queue = queue$1;
        exports2.race = race$1;
        exports2.reduce = reduce$1;
        exports2.reduceRight = reduceRight;
        exports2.reflect = reflect;
        exports2.reflectAll = reflectAll;
        exports2.reject = reject$2;
        exports2.rejectLimit = rejectLimit$1;
        exports2.rejectSeries = rejectSeries$1;
        exports2.retry = retry;
        exports2.retryable = retryable;
        exports2.seq = seq;
        exports2.series = series;
        exports2.setImmediate = setImmediate$1;
        exports2.some = some$1;
        exports2.someLimit = someLimit$1;
        exports2.someSeries = someSeries$1;
        exports2.sortBy = sortBy$1;
        exports2.timeout = timeout;
        exports2.times = times;
        exports2.timesLimit = timesLimit;
        exports2.timesSeries = timesSeries;
        exports2.transform = transform;
        exports2.tryEach = tryEach$1;
        exports2.unmemoize = unmemoize;
        exports2.until = until;
        exports2.waterfall = waterfall$1;
        exports2.whilst = whilst$1;
        exports2.all = every$1;
        exports2.allLimit = everyLimit$1;
        exports2.allSeries = everySeries$1;
        exports2.any = some$1;
        exports2.anyLimit = someLimit$1;
        exports2.anySeries = someSeries$1;
        exports2.find = detect$1;
        exports2.findLimit = detectLimit$1;
        exports2.findSeries = detectSeries$1;
        exports2.flatMap = concat$1;
        exports2.flatMapLimit = concatLimit$1;
        exports2.flatMapSeries = concatSeries$1;
        exports2.forEach = each;
        exports2.forEachSeries = eachSeries$1;
        exports2.forEachLimit = eachLimit$2;
        exports2.forEachOf = eachOf$1;
        exports2.forEachOfSeries = eachOfSeries$1;
        exports2.forEachOfLimit = eachOfLimit$2;
        exports2.inject = reduce$1;
        exports2.foldl = reduce$1;
        exports2.foldr = reduceRight;
        exports2.select = filter$1;
        exports2.selectLimit = filterLimit$1;
        exports2.selectSeries = filterSeries$1;
        exports2.wrapSync = asyncify;
        exports2.during = whilst$1;
        exports2.doDuring = doWhilst$1;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/hat/index.js
  var require_hat = __commonJS({
    "node_modules/hat/index.js"(exports, module) {
      init_mithril_shim();
      var hat = module.exports = function(bits, base) {
        if (!base)
          base = 16;
        if (bits === void 0)
          bits = 128;
        if (bits <= 0)
          return "0";
        var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
        for (var i = 2; digits === Infinity; i *= 2) {
          digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
        }
        var rem = digits - Math.floor(digits);
        var res = "";
        for (var i = 0; i < Math.floor(digits); i++) {
          var x = Math.floor(Math.random() * base).toString(base);
          res = x + res;
        }
        if (rem) {
          var b = Math.pow(base, rem);
          var x = Math.floor(Math.random() * b).toString(base);
          res = x + res;
        }
        var parsed = parseInt(res, base);
        if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
          return hat(bits, base);
        } else
          return res;
      };
      hat.rack = function(bits, base, expandBy) {
        var fn = function(data) {
          var iters = 0;
          do {
            if (iters++ > 10) {
              if (expandBy)
                bits += expandBy;
              else
                throw new Error("too many ID collisions, use more bits");
            }
            var id = hat(bits, base);
          } while (Object.hasOwnProperty.call(hats, id));
          hats[id] = data;
          return id;
        };
        var hats = fn.hats = {};
        fn.get = function(id) {
          return fn.hats[id];
        };
        fn.set = function(id, value) {
          fn.hats[id] = value;
          return fn;
        };
        fn.bits = bits || 128;
        fn.base = base || 16;
        return fn;
      };
    }
  });

  // node_modules/sharedb/lib/client/presence/presence.js
  var require_presence = __commonJS({
    "node_modules/sharedb/lib/client/presence/presence.js"(exports, module) {
      init_mithril_shim();
      var emitter = require_emitter();
      var LocalPresence = require_local_presence();
      var RemotePresence = require_remote_presence();
      var util = require_util();
      var async = require_async();
      var hat = require_hat();
      var ACTIONS = require_message_actions().ACTIONS;
      module.exports = Presence;
      function Presence(connection2, channel) {
        emitter.EventEmitter.call(this);
        if (!channel || typeof channel !== "string") {
          throw new Error("Presence channel must be provided");
        }
        this.connection = connection2;
        this.channel = channel;
        this.wantSubscribe = false;
        this.subscribed = false;
        this.remotePresences = {};
        this.localPresences = {};
        this._remotePresenceInstances = {};
        this._subscriptionCallbacksBySeq = {};
        this._wantsDestroy = false;
      }
      emitter.mixin(Presence);
      Presence.prototype.subscribe = function(callback) {
        this._sendSubscriptionAction(true, callback);
      };
      Presence.prototype.unsubscribe = function(callback) {
        this._sendSubscriptionAction(false, callback);
      };
      Presence.prototype.create = function(id) {
        if (this._wantsDestroy) {
          throw new Error("Presence is being destroyed");
        }
        id = id || hat();
        var localPresence = this._createLocalPresence(id);
        this.localPresences[id] = localPresence;
        return localPresence;
      };
      Presence.prototype.destroy = function(callback) {
        this._wantsDestroy = true;
        var presence = this;
        var localIds = Object.keys(presence.localPresences);
        this.unsubscribe(function(error) {
          if (error)
            return presence._callbackOrEmit(error, callback);
          var remoteIds = Object.keys(presence._remotePresenceInstances);
          async.parallel(
            [
              function(next) {
                async.each(localIds, function(presenceId, next2) {
                  presence.localPresences[presenceId].destroy(next2);
                }, next);
              },
              function(next) {
                if (!presence._wantsDestroy)
                  return next();
                async.each(remoteIds, function(presenceId, next2) {
                  presence._remotePresenceInstances[presenceId].destroy(next2);
                }, next);
              }
            ],
            function(error2) {
              if (presence._wantsDestroy)
                delete presence.connection._presences[presence.channel];
              presence._callbackOrEmit(error2, callback);
            }
          );
        });
      };
      Presence.prototype._sendSubscriptionAction = function(wantSubscribe, callback) {
        wantSubscribe = !!wantSubscribe;
        if (wantSubscribe === this.wantSubscribe) {
          if (!callback)
            return;
          if (wantSubscribe === this.subscribed)
            return util.nextTick(callback);
          if (Object.keys(this._subscriptionCallbacksBySeq).length) {
            return this._combineSubscribeCallbackWithLastAdded(callback);
          }
        }
        this.wantSubscribe = wantSubscribe;
        var action = this.wantSubscribe ? ACTIONS.presenceSubscribe : ACTIONS.presenceUnsubscribe;
        var seq = this.connection._presenceSeq++;
        this._subscriptionCallbacksBySeq[seq] = callback;
        if (this.connection.canSend) {
          this.connection._sendPresenceAction(action, seq, this);
        }
      };
      Presence.prototype._requestRemotePresence = function() {
        this.connection._requestRemotePresence(this.channel);
      };
      Presence.prototype._handleSubscribe = function(error, seq) {
        if (this.wantSubscribe)
          this.subscribed = true;
        var callback = this._subscriptionCallback(seq);
        this._callbackOrEmit(error, callback);
      };
      Presence.prototype._handleUnsubscribe = function(error, seq) {
        this.subscribed = false;
        var callback = this._subscriptionCallback(seq);
        this._callbackOrEmit(error, callback);
      };
      Presence.prototype._receiveUpdate = function(error, message) {
        var localPresence = util.dig(this.localPresences, message.id);
        if (localPresence)
          return localPresence._ack(error, message.pv);
        if (error)
          return this.emit("error", error);
        var presence = this;
        var remotePresence = util.digOrCreate(this._remotePresenceInstances, message.id, function() {
          return presence._createRemotePresence(message.id);
        });
        remotePresence.receiveUpdate(message);
      };
      Presence.prototype._updateRemotePresence = function(remotePresence) {
        this.remotePresences[remotePresence.presenceId] = remotePresence.value;
        if (remotePresence.value === null)
          this._removeRemotePresence(remotePresence.presenceId);
        this.emit("receive", remotePresence.presenceId, remotePresence.value);
      };
      Presence.prototype._broadcastAllLocalPresence = function(error) {
        if (error)
          return this.emit("error", error);
        for (var id in this.localPresences) {
          var localPresence = this.localPresences[id];
          if (localPresence.value !== null)
            localPresence.send();
        }
      };
      Presence.prototype._removeRemotePresence = function(id) {
        this._remotePresenceInstances[id].destroy();
        delete this._remotePresenceInstances[id];
        delete this.remotePresences[id];
      };
      Presence.prototype._onConnectionStateChanged = function() {
        if (!this.connection.canSend) {
          this.subscribed = false;
          return;
        }
        this._resubscribe();
        for (var id in this.localPresences) {
          this.localPresences[id]._sendPending();
        }
      };
      Presence.prototype._resubscribe = function() {
        var callbacks = [];
        for (var seq in this._subscriptionCallbacksBySeq) {
          var callback = this._subscriptionCallback(seq);
          callbacks.push(callback);
        }
        if (!this.wantSubscribe)
          return this._callEachOrEmit(callbacks);
        var presence = this;
        this.subscribe(function(error) {
          presence._callEachOrEmit(callbacks, error);
        });
      };
      Presence.prototype._subscriptionCallback = function(seq) {
        var callback = this._subscriptionCallbacksBySeq[seq];
        delete this._subscriptionCallbacksBySeq[seq];
        return callback;
      };
      Presence.prototype._callbackOrEmit = function(error, callback) {
        if (callback)
          return util.nextTick(callback, error);
        if (error)
          this.emit("error", error);
      };
      Presence.prototype._createLocalPresence = function(id) {
        return new LocalPresence(this, id);
      };
      Presence.prototype._createRemotePresence = function(id) {
        return new RemotePresence(this, id);
      };
      Presence.prototype._callEachOrEmit = function(callbacks, error) {
        var called = util.callEach(callbacks, error);
        if (!called && error)
          this.emit("error", error);
      };
      Presence.prototype._combineSubscribeCallbackWithLastAdded = function(callback) {
        var seqs = Object.keys(this._subscriptionCallbacksBySeq);
        var lastSeq = seqs[seqs.length - 1];
        var originalCallback = this._subscriptionCallbacksBySeq[lastSeq];
        if (!originalCallback)
          return this._subscriptionCallbacksBySeq[lastSeq] = callback;
        this._subscriptionCallbacksBySeq[lastSeq] = function(error) {
          originalCallback(error);
          callback(error);
        };
      };
    }
  });

  // node_modules/sharedb/lib/client/presence/local-doc-presence.js
  var require_local_doc_presence = __commonJS({
    "node_modules/sharedb/lib/client/presence/local-doc-presence.js"(exports, module) {
      init_mithril_shim();
      var LocalPresence = require_local_presence();
      var ShareDBError = require_error();
      var util = require_util();
      var ERROR_CODE = ShareDBError.CODES;
      module.exports = LocalDocPresence;
      function LocalDocPresence(presence, presenceId) {
        LocalPresence.call(this, presence, presenceId);
        this.collection = this.presence.collection;
        this.id = this.presence.id;
        this._doc = this.connection.get(this.collection, this.id);
        this._emitter = this.connection._docPresenceEmitter;
        this._isSending = false;
        this._docDataVersionByPresenceVersion = {};
        this._opHandler = this._transformAgainstOp.bind(this);
        this._createOrDelHandler = this._handleCreateOrDel.bind(this);
        this._loadHandler = this._handleLoad.bind(this);
        this._destroyHandler = this.destroy.bind(this);
        this._registerWithDoc();
      }
      LocalDocPresence.prototype = Object.create(LocalPresence.prototype);
      LocalDocPresence.prototype.submit = function(value, callback) {
        if (!this._doc.type) {
          if (value === null)
            return this._callbackOrEmit(null, callback);
          var error = {
            code: ERROR_CODE.ERR_DOC_DOES_NOT_EXIST,
            message: "Cannot submit presence. Document has not been created"
          };
          return this._callbackOrEmit(error, callback);
        }
        ;
        this._docDataVersionByPresenceVersion[this.presenceVersion] = this._doc._dataStateVersion;
        LocalPresence.prototype.submit.call(this, value, callback);
      };
      LocalDocPresence.prototype.destroy = function(callback) {
        this._emitter.removeEventListener(this._doc, "op", this._opHandler);
        this._emitter.removeEventListener(this._doc, "create", this._createOrDelHandler);
        this._emitter.removeEventListener(this._doc, "del", this._createOrDelHandler);
        this._emitter.removeEventListener(this._doc, "load", this._loadHandler);
        this._emitter.removeEventListener(this._doc, "destroy", this._destroyHandler);
        LocalPresence.prototype.destroy.call(this, callback);
      };
      LocalDocPresence.prototype._sendPending = function() {
        if (this._isSending)
          return;
        this._isSending = true;
        var presence = this;
        this._doc.whenNothingPending(function() {
          presence._isSending = false;
          if (!presence.connection.canSend)
            return;
          presence._pendingMessages.forEach(function(message) {
            message.t = presence._doc.type.uri;
            message.v = presence._doc.version;
            presence.connection.send(message);
          });
          presence._pendingMessages = [];
          presence._docDataVersionByPresenceVersion = {};
        });
      };
      LocalDocPresence.prototype._registerWithDoc = function() {
        this._emitter.addEventListener(this._doc, "op", this._opHandler);
        this._emitter.addEventListener(this._doc, "create", this._createOrDelHandler);
        this._emitter.addEventListener(this._doc, "del", this._createOrDelHandler);
        this._emitter.addEventListener(this._doc, "load", this._loadHandler);
        this._emitter.addEventListener(this._doc, "destroy", this._destroyHandler);
      };
      LocalDocPresence.prototype._transformAgainstOp = function(op, source) {
        var presence = this;
        var docDataVersion = this._doc._dataStateVersion;
        this._pendingMessages.forEach(function(message) {
          var messageDocDataVersion = presence._docDataVersionByPresenceVersion[message.pv];
          if (messageDocDataVersion >= docDataVersion)
            return;
          try {
            message.p = presence._transformPresence(message.p, op, source);
            presence._docDataVersionByPresenceVersion[message.pv] = docDataVersion;
          } catch (error) {
            var callback = presence._getCallback(message.pv);
            presence._callbackOrEmit(error, callback);
          }
        });
        try {
          this.value = this._transformPresence(this.value, op, source);
        } catch (error) {
          this.emit("error", error);
        }
      };
      LocalDocPresence.prototype._handleCreateOrDel = function() {
        this._pendingMessages.forEach(function(message) {
          message.p = null;
        });
        this.value = null;
      };
      LocalDocPresence.prototype._handleLoad = function() {
        this.value = null;
        this._pendingMessages = [];
        this._docDataVersionByPresenceVersion = {};
      };
      LocalDocPresence.prototype._message = function() {
        var message = LocalPresence.prototype._message.call(this);
        message.c = this.collection, message.d = this.id, message.v = null;
        message.t = null;
        return message;
      };
      LocalDocPresence.prototype._transformPresence = function(value, op, source) {
        var type = this._doc.type;
        if (!util.supportsPresence(type)) {
          throw new ShareDBError(
            ERROR_CODE.ERR_TYPE_DOES_NOT_SUPPORT_PRESENCE,
            "Type does not support presence: " + type.name
          );
        }
        return type.transformPresence(value, op, source);
      };
    }
  });

  // node_modules/sharedb/lib/ot.js
  var require_ot = __commonJS({
    "node_modules/sharedb/lib/ot.js"(exports) {
      init_mithril_shim();
      var types = require_types();
      var ShareDBError = require_error();
      var util = require_util();
      var ERROR_CODE = ShareDBError.CODES;
      exports.checkOp = function(op) {
        if (op == null || typeof op !== "object") {
          return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, "Op must be an object");
        }
        if (op.create != null) {
          if (typeof op.create !== "object") {
            return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, "Create data must be an object");
          }
          var typeName = op.create.type;
          if (typeof typeName !== "string") {
            return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, "Missing create type");
          }
          var type = types.map[typeName];
          if (type == null || typeof type !== "object") {
            return new ShareDBError(ERROR_CODE.ERR_DOC_TYPE_NOT_RECOGNIZED, "Unknown type");
          }
        } else if (op.del != null) {
          if (op.del !== true)
            return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, "del value must be true");
        } else if (!("op" in op)) {
          return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, "Missing op, create, or del");
        }
        if (op.src != null && typeof op.src !== "string") {
          return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, "src must be a string");
        }
        if (op.seq != null && typeof op.seq !== "number") {
          return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, "seq must be a number");
        }
        if (op.src == null && op.seq != null || op.src != null && op.seq == null) {
          return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, "Both src and seq must be set together");
        }
        if (op.m != null && typeof op.m !== "object") {
          return new ShareDBError(ERROR_CODE.ERR_OT_OP_BADLY_FORMED, "op.m must be an object or null");
        }
      };
      exports.normalizeType = function(typeName) {
        return types.map[typeName] && types.map[typeName].uri;
      };
      exports.apply = function(snapshot, op) {
        if (typeof snapshot !== "object") {
          return new ShareDBError(ERROR_CODE.ERR_APPLY_SNAPSHOT_NOT_PROVIDED, "Missing snapshot");
        }
        if (snapshot.v != null && op.v != null && snapshot.v !== op.v) {
          return new ShareDBError(ERROR_CODE.ERR_APPLY_OP_VERSION_DOES_NOT_MATCH_SNAPSHOT, "Version mismatch");
        }
        if (op.create) {
          if (snapshot.type)
            return new ShareDBError(ERROR_CODE.ERR_DOC_ALREADY_CREATED, "Document already exists");
          var create = op.create;
          var type = types.map[create.type];
          if (!type)
            return new ShareDBError(ERROR_CODE.ERR_DOC_TYPE_NOT_RECOGNIZED, "Unknown type");
          try {
            snapshot.data = type.create(create.data);
            snapshot.type = type.uri;
            snapshot.v++;
          } catch (err2) {
            return err2;
          }
        } else if (op.del) {
          snapshot.data = void 0;
          snapshot.type = null;
          snapshot.v++;
        } else if ("op" in op) {
          var err = applyOpEdit(snapshot, op.op);
          if (err)
            return err;
          snapshot.v++;
        } else {
          snapshot.v++;
        }
      };
      function applyOpEdit(snapshot, edit) {
        if (!snapshot.type)
          return new ShareDBError(ERROR_CODE.ERR_DOC_DOES_NOT_EXIST, "Document does not exist");
        if (edit === void 0)
          return new ShareDBError(ERROR_CODE.ERR_OT_OP_NOT_PROVIDED, "Missing op");
        var type = types.map[snapshot.type];
        if (!type)
          return new ShareDBError(ERROR_CODE.ERR_DOC_TYPE_NOT_RECOGNIZED, "Unknown type");
        try {
          snapshot.data = type.apply(snapshot.data, edit);
        } catch (err) {
          return new ShareDBError(ERROR_CODE.ERR_OT_OP_NOT_APPLIED, err.message);
        }
      }
      exports.transform = function(type, op, appliedOp) {
        if (op.v != null && op.v !== appliedOp.v) {
          return new ShareDBError(ERROR_CODE.ERR_OP_VERSION_MISMATCH_DURING_TRANSFORM, "Version mismatch");
        }
        if (appliedOp.del) {
          if (op.create || "op" in op) {
            return new ShareDBError(ERROR_CODE.ERR_DOC_WAS_DELETED, "Document was deleted");
          }
        } else if (appliedOp.create && ("op" in op || op.create || op.del) || "op" in appliedOp && op.create) {
          return new ShareDBError(ERROR_CODE.ERR_DOC_ALREADY_CREATED, "Document was created remotely");
        } else if ("op" in appliedOp && "op" in op) {
          if (!type)
            return new ShareDBError(ERROR_CODE.ERR_DOC_DOES_NOT_EXIST, "Document does not exist");
          if (typeof type === "string") {
            type = types.map[type];
            if (!type)
              return new ShareDBError(ERROR_CODE.ERR_DOC_TYPE_NOT_RECOGNIZED, "Unknown type");
          }
          try {
            op.op = type.transform(op.op, appliedOp.op, "left");
          } catch (err) {
            return err;
          }
        }
        if (op.v != null)
          op.v++;
      };
      exports.applyOps = function(snapshot, ops, options) {
        options = options || {};
        for (var index = 0; index < ops.length; index++) {
          var op = ops[index];
          if (options._normalizeLegacyJson0Ops) {
            try {
              normalizeLegacyJson0Ops(snapshot, op);
            } catch (error2) {
              return new ShareDBError(
                ERROR_CODE.ERR_OT_LEGACY_JSON0_OP_CANNOT_BE_NORMALIZED,
                "Cannot normalize legacy json0 op"
              );
            }
          }
          snapshot.v = op.v;
          var error = exports.apply(snapshot, op);
          if (error)
            return error;
        }
      };
      exports.transformPresence = function(presence, op, isOwnOp) {
        var opError = this.checkOp(op);
        if (opError)
          return opError;
        var type = presence.t;
        if (typeof type === "string") {
          type = types.map[type];
        }
        if (!type)
          return { code: ERROR_CODE.ERR_DOC_TYPE_NOT_RECOGNIZED, message: "Unknown type" };
        if (!util.supportsPresence(type)) {
          return { code: ERROR_CODE.ERR_TYPE_DOES_NOT_SUPPORT_PRESENCE, message: "Type does not support presence" };
        }
        if (op.create || op.del) {
          presence.p = null;
          presence.v++;
          return;
        }
        try {
          presence.p = presence.p === null ? null : type.transformPresence(presence.p, op.op, isOwnOp);
        } catch (error) {
          return { code: ERROR_CODE.ERR_PRESENCE_TRANSFORM_FAILED, message: error.message || error };
        }
        presence.v++;
      };
      function normalizeLegacyJson0Ops(snapshot, json0Op) {
        if (snapshot.type !== types.defaultType.uri)
          return;
        var components = json0Op.op;
        if (!components)
          return;
        var data = snapshot.data;
        if (components.length > 1)
          data = util.clone(data);
        for (var i = 0; i < components.length; i++) {
          var component = components[i];
          if (typeof component.lm === "string")
            component.lm = +component.lm;
          var path3 = component.p;
          var element = data;
          for (var j = 0; j < path3.length; j++) {
            var key = path3[j];
            if (Object.prototype.toString.call(element) == "[object Array]")
              path3[j] = +key;
            else if (element.constructor === Object)
              path3[j] = key.toString();
            element = element[key];
          }
          if (i < components.length - 1)
            data = types.defaultType.apply(data, [component]);
        }
      }
    }
  });

  // node_modules/sharedb/lib/client/presence/remote-doc-presence.js
  var require_remote_doc_presence = __commonJS({
    "node_modules/sharedb/lib/client/presence/remote-doc-presence.js"(exports, module) {
      init_mithril_shim();
      var RemotePresence = require_remote_presence();
      var ot = require_ot();
      module.exports = RemoteDocPresence;
      function RemoteDocPresence(presence, presenceId) {
        RemotePresence.call(this, presence, presenceId);
        this.collection = this.presence.collection;
        this.id = this.presence.id;
        this.src = null;
        this.presenceVersion = null;
        this._doc = this.connection.get(this.collection, this.id);
        this._emitter = this.connection._docPresenceEmitter;
        this._pending = null;
        this._opCache = null;
        this._pendingSetPending = false;
        this._opHandler = this._handleOp.bind(this);
        this._createDelHandler = this._handleCreateDel.bind(this);
        this._loadHandler = this._handleLoad.bind(this);
        this._registerWithDoc();
      }
      RemoteDocPresence.prototype = Object.create(RemotePresence.prototype);
      RemoteDocPresence.prototype.receiveUpdate = function(message) {
        if (this._pending && message.pv < this._pending.pv)
          return;
        this.src = message.src;
        this._pending = message;
        this._setPendingPresence();
      };
      RemoteDocPresence.prototype.destroy = function(callback) {
        this._emitter.removeEventListener(this._doc, "op", this._opHandler);
        this._emitter.removeEventListener(this._doc, "create", this._createDelHandler);
        this._emitter.removeEventListener(this._doc, "del", this._createDelHandler);
        this._emitter.removeEventListener(this._doc, "load", this._loadHandler);
        RemotePresence.prototype.destroy.call(this, callback);
      };
      RemoteDocPresence.prototype._registerWithDoc = function() {
        this._emitter.addEventListener(this._doc, "op", this._opHandler);
        this._emitter.addEventListener(this._doc, "create", this._createDelHandler);
        this._emitter.addEventListener(this._doc, "del", this._createDelHandler);
        this._emitter.addEventListener(this._doc, "load", this._loadHandler);
      };
      RemoteDocPresence.prototype._setPendingPresence = function() {
        if (this._pendingSetPending)
          return;
        this._pendingSetPending = true;
        var presence = this;
        this._doc.whenNothingPending(function() {
          presence._pendingSetPending = false;
          if (!presence._pending)
            return;
          if (presence._pending.pv < presence.presenceVersion)
            return presence._pending = null;
          if (presence._pending.v > presence._doc.version) {
            return presence._doc.fetch();
          }
          if (!presence._catchUpStalePresence())
            return;
          presence.value = presence._pending.p;
          presence.presenceVersion = presence._pending.pv;
          presence._pending = null;
          presence.presence._updateRemotePresence(presence);
        });
      };
      RemoteDocPresence.prototype._handleOp = function(op, source, connectionId) {
        var isOwnOp = connectionId === this.src;
        this._transformAgainstOp(op, isOwnOp);
        this._cacheOp(op, isOwnOp);
        this._setPendingPresence();
      };
      RemotePresence.prototype._handleCreateDel = function() {
        this._cacheOp(null);
        this._setPendingPresence();
      };
      RemotePresence.prototype._handleLoad = function() {
        this.value = null;
        this._pending = null;
        this._opCache = null;
        this.presence._updateRemotePresence(this);
      };
      RemoteDocPresence.prototype._transformAgainstOp = function(op, isOwnOp) {
        if (!this.value)
          return;
        try {
          this.value = this._doc.type.transformPresence(this.value, op, isOwnOp);
        } catch (error) {
          return this.presence.emit("error", error);
        }
        this.presence._updateRemotePresence(this);
      };
      RemoteDocPresence.prototype._catchUpStalePresence = function() {
        if (this._pending.v >= this._doc.version)
          return true;
        if (!this._opCache) {
          this._startCachingOps();
          this._doc.fetch();
          this.presence._requestRemotePresence();
          return false;
        }
        while (this._opCache[this._pending.v]) {
          var item = this._opCache[this._pending.v];
          var op = item.op;
          var isOwnOp = item.isOwnOp;
          if (op === null) {
            this._pending.p = null;
            this._pending.v++;
          } else {
            ot.transformPresence(this._pending, op, isOwnOp);
          }
        }
        var hasCaughtUp = this._pending.v >= this._doc.version;
        if (hasCaughtUp) {
          this._stopCachingOps();
        }
        return hasCaughtUp;
      };
      RemoteDocPresence.prototype._startCachingOps = function() {
        this._opCache = [];
      };
      RemoteDocPresence.prototype._stopCachingOps = function() {
        this._opCache = null;
      };
      RemoteDocPresence.prototype._cacheOp = function(op, isOwnOp) {
        if (this._opCache) {
          op = op ? { op } : null;
          this._opCache[this._doc.version - 1] = { op, isOwnOp };
        }
      };
    }
  });

  // node_modules/sharedb/lib/client/presence/doc-presence.js
  var require_doc_presence = __commonJS({
    "node_modules/sharedb/lib/client/presence/doc-presence.js"(exports, module) {
      init_mithril_shim();
      var Presence = require_presence();
      var LocalDocPresence = require_local_doc_presence();
      var RemoteDocPresence = require_remote_doc_presence();
      function DocPresence(connection2, collection, id) {
        var channel = DocPresence.channel(collection, id);
        Presence.call(this, connection2, channel);
        this.collection = collection;
        this.id = id;
      }
      module.exports = DocPresence;
      DocPresence.prototype = Object.create(Presence.prototype);
      DocPresence.channel = function(collection, id) {
        return collection + "." + id;
      };
      DocPresence.prototype._createLocalPresence = function(id) {
        return new LocalDocPresence(this, id);
      };
      DocPresence.prototype._createRemotePresence = function(id) {
        return new RemoteDocPresence(this, id);
      };
    }
  });

  // node_modules/sharedb/lib/snapshot.js
  var require_snapshot = __commonJS({
    "node_modules/sharedb/lib/snapshot.js"(exports, module) {
      init_mithril_shim();
      module.exports = Snapshot;
      function Snapshot(id, version, type, data, meta) {
        this.id = id;
        this.v = version;
        this.type = type;
        this.data = data;
        this.m = meta;
      }
    }
  });

  // node_modules/sharedb/lib/client/snapshot-request/snapshot-request.js
  var require_snapshot_request = __commonJS({
    "node_modules/sharedb/lib/client/snapshot-request/snapshot-request.js"(exports, module) {
      init_mithril_shim();
      var Snapshot = require_snapshot();
      var emitter = require_emitter();
      module.exports = SnapshotRequest;
      function SnapshotRequest(connection2, requestId, collection, id, callback) {
        emitter.EventEmitter.call(this);
        if (typeof callback !== "function") {
          throw new Error("Callback is required for SnapshotRequest");
        }
        this.requestId = requestId;
        this.connection = connection2;
        this.id = id;
        this.collection = collection;
        this.callback = callback;
        this.sent = false;
      }
      emitter.mixin(SnapshotRequest);
      SnapshotRequest.prototype.send = function() {
        if (!this.connection.canSend) {
          return;
        }
        this.connection.send(this._message());
        this.sent = true;
      };
      SnapshotRequest.prototype._onConnectionStateChanged = function() {
        if (this.connection.canSend) {
          if (!this.sent)
            this.send();
        } else {
          this.sent = false;
        }
      };
      SnapshotRequest.prototype._handleResponse = function(error, message) {
        this.emit("ready");
        if (error) {
          return this.callback(error);
        }
        var metadata = message.meta ? message.meta : null;
        var snapshot = new Snapshot(this.id, message.v, message.type, message.data, metadata);
        this.callback(null, snapshot);
      };
    }
  });

  // node_modules/sharedb/lib/client/snapshot-request/snapshot-version-request.js
  var require_snapshot_version_request = __commonJS({
    "node_modules/sharedb/lib/client/snapshot-request/snapshot-version-request.js"(exports, module) {
      init_mithril_shim();
      var SnapshotRequest = require_snapshot_request();
      var util = require_util();
      var ACTIONS = require_message_actions().ACTIONS;
      module.exports = SnapshotVersionRequest;
      function SnapshotVersionRequest(connection2, requestId, collection, id, version, callback) {
        SnapshotRequest.call(this, connection2, requestId, collection, id, callback);
        if (!util.isValidVersion(version)) {
          throw new Error("Snapshot version must be a positive integer or null");
        }
        this.version = version;
      }
      SnapshotVersionRequest.prototype = Object.create(SnapshotRequest.prototype);
      SnapshotVersionRequest.prototype._message = function() {
        return {
          a: ACTIONS.snapshotFetch,
          id: this.requestId,
          c: this.collection,
          d: this.id,
          v: this.version
        };
      };
    }
  });

  // node_modules/sharedb/lib/client/snapshot-request/snapshot-timestamp-request.js
  var require_snapshot_timestamp_request = __commonJS({
    "node_modules/sharedb/lib/client/snapshot-request/snapshot-timestamp-request.js"(exports, module) {
      init_mithril_shim();
      var SnapshotRequest = require_snapshot_request();
      var util = require_util();
      var ACTIONS = require_message_actions().ACTIONS;
      module.exports = SnapshotTimestampRequest;
      function SnapshotTimestampRequest(connection2, requestId, collection, id, timestamp, callback) {
        SnapshotRequest.call(this, connection2, requestId, collection, id, callback);
        if (!util.isValidTimestamp(timestamp)) {
          throw new Error("Snapshot timestamp must be a positive integer or null");
        }
        this.timestamp = timestamp;
      }
      SnapshotTimestampRequest.prototype = Object.create(SnapshotRequest.prototype);
      SnapshotTimestampRequest.prototype._message = function() {
        return {
          a: ACTIONS.snapshotFetchByTimestamp,
          id: this.requestId,
          c: this.collection,
          d: this.id,
          ts: this.timestamp
        };
      };
    }
  });

  // node_modules/sharedb/lib/client/presence/doc-presence-emitter.js
  var require_doc_presence_emitter = __commonJS({
    "node_modules/sharedb/lib/client/presence/doc-presence-emitter.js"(exports, module) {
      init_mithril_shim();
      var util = require_util();
      var EventEmitter = require_events().EventEmitter;
      var EVENTS = [
        "create",
        "del",
        "destroy",
        "load",
        "op"
      ];
      module.exports = DocPresenceEmitter;
      function DocPresenceEmitter() {
        this._docs = {};
        this._forwarders = {};
        this._emitters = {};
      }
      DocPresenceEmitter.prototype.addEventListener = function(doc2, event, listener) {
        this._registerDoc(doc2);
        var emitter = util.dig(this._emitters, doc2.collection, doc2.id);
        emitter.on(event, listener);
      };
      DocPresenceEmitter.prototype.removeEventListener = function(doc2, event, listener) {
        var emitter = util.dig(this._emitters, doc2.collection, doc2.id);
        if (!emitter)
          return;
        emitter.off(event, listener);
        if (emitter._eventsCount === 1)
          this._unregisterDoc(doc2);
      };
      DocPresenceEmitter.prototype._registerDoc = function(doc2) {
        var alreadyRegistered = true;
        util.digOrCreate(this._docs, doc2.collection, doc2.id, function() {
          alreadyRegistered = false;
          return doc2;
        });
        if (alreadyRegistered)
          return;
        var emitter = util.digOrCreate(this._emitters, doc2.collection, doc2.id, function() {
          var e = new EventEmitter();
          e.setMaxListeners(1e3);
          return e;
        });
        var self = this;
        EVENTS.forEach(function(event) {
          var forwarder = util.digOrCreate(self._forwarders, doc2.collection, doc2.id, event, function() {
            return emitter.emit.bind(emitter, event);
          });
          doc2.on(event, forwarder);
        });
        this.addEventListener(doc2, "destroy", this._unregisterDoc.bind(this, doc2));
      };
      DocPresenceEmitter.prototype._unregisterDoc = function(doc2) {
        var forwarders = util.dig(this._forwarders, doc2.collection, doc2.id);
        for (var event in forwarders) {
          doc2.off(event, forwarders[event]);
        }
        var emitter = util.dig(this._emitters, doc2.collection, doc2.id);
        emitter.removeAllListeners();
        util.digAndRemove(this._forwarders, doc2.collection, doc2.id);
        util.digAndRemove(this._emitters, doc2.collection, doc2.id);
        util.digAndRemove(this._docs, doc2.collection, doc2.id);
      };
    }
  });

  // node_modules/sharedb/lib/client/connection.js
  var require_connection = __commonJS({
    "node_modules/sharedb/lib/client/connection.js"(exports, module) {
      init_mithril_shim();
      var Doc = require_doc();
      var Query = require_query();
      var Presence = require_presence();
      var DocPresence = require_doc_presence();
      var SnapshotVersionRequest = require_snapshot_version_request();
      var SnapshotTimestampRequest = require_snapshot_timestamp_request();
      var emitter = require_emitter();
      var ShareDBError = require_error();
      var ACTIONS = require_message_actions().ACTIONS;
      var types = require_types();
      var util = require_util();
      var logger = require_logger2();
      var DocPresenceEmitter = require_doc_presence_emitter();
      var ERROR_CODE = ShareDBError.CODES;
      function connectionState(socket2) {
        if (socket2.readyState === 0 || socket2.readyState === 1)
          return "connecting";
        return "disconnected";
      }
      module.exports = Connection2;
      function Connection2(socket2) {
        emitter.EventEmitter.call(this);
        this.collections = {};
        this.nextQueryId = 1;
        this.nextSnapshotRequestId = 1;
        this.queries = {};
        this._presences = {};
        this._docPresenceEmitter = new DocPresenceEmitter();
        this._snapshotRequests = {};
        this.seq = 1;
        this._presenceSeq = 1;
        this.id = null;
        this.agent = null;
        this.debug = false;
        this.state = connectionState(socket2);
        this.bindToSocket(socket2);
      }
      emitter.mixin(Connection2);
      Connection2.prototype.bindToSocket = function(socket2) {
        if (this.socket) {
          this.socket.close();
          this.socket.onmessage = null;
          this.socket.onopen = null;
          this.socket.onerror = null;
          this.socket.onclose = null;
        }
        this.socket = socket2;
        var newState = connectionState(socket2);
        this._setState(newState);
        this.canSend = false;
        var connection2 = this;
        socket2.onmessage = function(event) {
          try {
            var data = typeof event.data === "string" ? JSON.parse(event.data) : event.data;
          } catch (err) {
            logger.warn("Failed to parse message", event);
            return;
          }
          if (connection2.debug)
            logger.info("RECV", JSON.stringify(data));
          var request = { data };
          connection2.emit("receive", request);
          if (!request.data)
            return;
          try {
            connection2.handleMessage(request.data);
          } catch (err) {
            util.nextTick(function() {
              connection2.emit("error", err);
            });
          }
        };
        if (socket2.readyState === 1) {
          connection2._initializeHandshake();
        }
        socket2.onopen = function() {
          connection2._setState("connecting");
          connection2._initializeHandshake();
        };
        socket2.onerror = function(err) {
          connection2.emit("connection error", err);
        };
        socket2.onclose = function(reason) {
          if (reason === "closed" || reason === "Closed") {
            connection2._setState("closed", reason);
          } else if (reason === "stopped" || reason === "Stopped by server") {
            connection2._setState("stopped", reason);
          } else {
            connection2._setState("disconnected", reason);
          }
        };
      };
      Connection2.prototype.handleMessage = function(message) {
        var err = null;
        if (message.error) {
          err = wrapErrorData(message.error, message);
          delete message.error;
        }
        switch (message.a) {
          case ACTIONS.initLegacy:
            return this._handleLegacyInit(message);
          case ACTIONS.handshake:
            return this._handleHandshake(err, message);
          case ACTIONS.queryFetch:
            var query = this.queries[message.id];
            if (query)
              query._handleFetch(err, message.data, message.extra);
            return;
          case ACTIONS.querySubscribe:
            var query = this.queries[message.id];
            if (query)
              query._handleSubscribe(err, message.data, message.extra);
            return;
          case ACTIONS.queryUnsubscribe:
            return;
          case ACTIONS.queryUpdate:
            var query = this.queries[message.id];
            if (!query)
              return;
            if (err)
              return query._handleError(err);
            if (message.diff)
              query._handleDiff(message.diff);
            if (message.hasOwnProperty("extra"))
              query._handleExtra(message.extra);
            return;
          case ACTIONS.bulkFetch:
            return this._handleBulkMessage(err, message, "_handleFetch");
          case ACTIONS.bulkSubscribe:
          case ACTIONS.bulkUnsubscribe:
            return this._handleBulkMessage(err, message, "_handleSubscribe");
          case ACTIONS.snapshotFetch:
          case ACTIONS.snapshotFetchByTimestamp:
            return this._handleSnapshotFetch(err, message);
          case ACTIONS.fetch:
            var doc2 = this.getExisting(message.c, message.d);
            if (doc2)
              doc2._handleFetch(err, message.data);
            return;
          case ACTIONS.subscribe:
          case ACTIONS.unsubscribe:
            var doc2 = this.getExisting(message.c, message.d);
            if (doc2)
              doc2._handleSubscribe(err, message.data);
            return;
          case ACTIONS.op:
            var doc2 = this.getExisting(message.c, message.d);
            if (doc2)
              doc2._handleOp(err, message);
            return;
          case ACTIONS.presence:
            return this._handlePresence(err, message);
          case ACTIONS.presenceSubscribe:
            return this._handlePresenceSubscribe(err, message);
          case ACTIONS.presenceUnsubscribe:
            return this._handlePresenceUnsubscribe(err, message);
          case ACTIONS.presenceRequest:
            return this._handlePresenceRequest(err, message);
          case ACTIONS.pingPong:
            return this._handlePingPong(err);
          default:
            logger.warn("Ignoring unrecognized message", message);
        }
      };
      function wrapErrorData(errorData, fullMessage) {
        var err = new Error(errorData.message);
        err.code = errorData.code;
        if (fullMessage) {
          err.data = fullMessage;
        }
        return err;
      }
      Connection2.prototype._handleBulkMessage = function(err, message, method) {
        if (message.data) {
          for (var id in message.data) {
            var dataForId = message.data[id];
            var doc2 = this.getExisting(message.c, id);
            if (doc2) {
              if (err) {
                doc2[method](err);
              } else if (dataForId.error) {
                doc2[method](wrapErrorData(dataForId.error));
              } else {
                doc2[method](null, dataForId);
              }
            }
          }
        } else if (Array.isArray(message.b)) {
          for (var i = 0; i < message.b.length; i++) {
            var id = message.b[i];
            var doc2 = this.getExisting(message.c, id);
            if (doc2)
              doc2[method](err);
          }
        } else if (message.b) {
          for (var id in message.b) {
            var doc2 = this.getExisting(message.c, id);
            if (doc2)
              doc2[method](err);
          }
        } else {
          logger.error("Invalid bulk message", message);
        }
      };
      Connection2.prototype._reset = function() {
        this.agent = null;
      };
      Connection2.prototype._setState = function(newState, reason) {
        if (this.state === newState)
          return;
        if (newState === "connecting" && this.state !== "disconnected" && this.state !== "stopped" && this.state !== "closed" || newState === "connected" && this.state !== "connecting") {
          var err = new ShareDBError(
            ERROR_CODE.ERR_CONNECTION_STATE_TRANSITION_INVALID,
            "Cannot transition directly from " + this.state + " to " + newState
          );
          return this.emit("error", err);
        }
        this.state = newState;
        this.canSend = newState === "connected";
        if (newState === "disconnected" || newState === "stopped" || newState === "closed") {
          this._reset();
        }
        this.startBulk();
        for (var id in this.queries) {
          var query = this.queries[id];
          query._onConnectionStateChanged();
        }
        for (var collection in this.collections) {
          var docs = this.collections[collection];
          for (var id in docs) {
            docs[id]._onConnectionStateChanged();
          }
        }
        for (var channel in this._presences) {
          this._presences[channel]._onConnectionStateChanged();
        }
        for (var id in this._snapshotRequests) {
          var snapshotRequest = this._snapshotRequests[id];
          snapshotRequest._onConnectionStateChanged();
        }
        this.endBulk();
        this.emit(newState, reason);
        this.emit("state", newState, reason);
      };
      Connection2.prototype.startBulk = function() {
        if (!this.bulk)
          this.bulk = {};
      };
      Connection2.prototype.endBulk = function() {
        if (this.bulk) {
          for (var collection in this.bulk) {
            var actions = this.bulk[collection];
            this._sendBulk("f", collection, actions.f);
            this._sendBulk("s", collection, actions.s);
            this._sendBulk("u", collection, actions.u);
          }
        }
        this.bulk = null;
      };
      Connection2.prototype._sendBulk = function(action, collection, values) {
        if (!values)
          return;
        var ids = [];
        var versions = {};
        var versionsCount = 0;
        var versionId;
        for (var id in values) {
          var value = values[id];
          if (value == null) {
            ids.push(id);
          } else {
            versions[id] = value;
            versionId = id;
            versionsCount++;
          }
        }
        if (ids.length === 1) {
          var id = ids[0];
          this.send({ a: action, c: collection, d: id });
        } else if (ids.length) {
          this.send({ a: "b" + action, c: collection, b: ids });
        }
        if (versionsCount === 1) {
          var version = versions[versionId];
          this.send({ a: action, c: collection, d: versionId, v: version });
        } else if (versionsCount) {
          this.send({ a: "b" + action, c: collection, b: versions });
        }
      };
      Connection2.prototype._sendActions = function(action, doc2, version) {
        this._addDoc(doc2);
        if (this.bulk) {
          var actions = this.bulk[doc2.collection] || (this.bulk[doc2.collection] = {});
          var versions = actions[action] || (actions[action] = {});
          var isDuplicate = versions.hasOwnProperty(doc2.id);
          versions[doc2.id] = version;
          return isDuplicate;
        } else {
          var message = { a: action, c: doc2.collection, d: doc2.id, v: version };
          this.send(message);
        }
      };
      Connection2.prototype.sendFetch = function(doc2) {
        return this._sendActions(ACTIONS.fetch, doc2, doc2.version);
      };
      Connection2.prototype.sendSubscribe = function(doc2) {
        return this._sendActions(ACTIONS.subscribe, doc2, doc2.version);
      };
      Connection2.prototype.sendUnsubscribe = function(doc2) {
        return this._sendActions(ACTIONS.unsubscribe, doc2);
      };
      Connection2.prototype.sendOp = function(doc2, op) {
        this._addDoc(doc2);
        var message = {
          a: ACTIONS.op,
          c: doc2.collection,
          d: doc2.id,
          v: doc2.version,
          src: op.src,
          seq: op.seq,
          x: {}
        };
        if ("op" in op)
          message.op = op.op;
        if (op.create)
          message.create = op.create;
        if (op.del)
          message.del = op.del;
        if (doc2.submitSource)
          message.x.source = op.source;
        this.send(message);
      };
      Connection2.prototype.send = function(message) {
        if (this.debug)
          logger.info("SEND", JSON.stringify(message));
        this.emit("send", message);
        this.socket.send(JSON.stringify(message));
      };
      Connection2.prototype.ping = function() {
        if (!this.canSend) {
          throw new ShareDBError(
            ERROR_CODE.ERR_CANNOT_PING_OFFLINE,
            "Socket must be CONNECTED to ping"
          );
        }
        var message = {
          a: ACTIONS.pingPong
        };
        this.send(message);
      };
      Connection2.prototype.close = function() {
        this.socket.close();
      };
      Connection2.prototype.getExisting = function(collection, id) {
        if (this.collections[collection])
          return this.collections[collection][id];
      };
      Connection2.prototype.get = function(collection, id) {
        var docs = this.collections[collection] || (this.collections[collection] = {});
        var doc2 = docs[id];
        if (!doc2) {
          doc2 = docs[id] = new Doc(this, collection, id);
          this.emit("doc", doc2);
        }
        doc2._wantsDestroy = false;
        return doc2;
      };
      Connection2.prototype._destroyDoc = function(doc2) {
        if (!doc2._wantsDestroy)
          return;
        util.digAndRemove(this.collections, doc2.collection, doc2.id);
        doc2.emit("destroy");
      };
      Connection2.prototype._addDoc = function(doc2) {
        var docs = this.collections[doc2.collection];
        if (!docs) {
          docs = this.collections[doc2.collection] = {};
        }
        if (docs[doc2.id] !== doc2) {
          docs[doc2.id] = doc2;
        }
      };
      Connection2.prototype._createQuery = function(action, collection, q, options, callback) {
        var id = this.nextQueryId++;
        var query = new Query(action, this, id, collection, q, options, callback);
        this.queries[id] = query;
        query.send();
        return query;
      };
      Connection2.prototype._destroyQuery = function(query) {
        delete this.queries[query.id];
      };
      Connection2.prototype.createFetchQuery = function(collection, q, options, callback) {
        return this._createQuery(ACTIONS.queryFetch, collection, q, options, callback);
      };
      Connection2.prototype.createSubscribeQuery = function(collection, q, options, callback) {
        return this._createQuery(ACTIONS.querySubscribe, collection, q, options, callback);
      };
      Connection2.prototype.hasPending = function() {
        return !!(this._firstDoc(hasPending) || this._firstQuery(hasPending) || this._firstSnapshotRequest());
      };
      function hasPending(object) {
        return object.hasPending();
      }
      Connection2.prototype.hasWritePending = function() {
        return !!this._firstDoc(hasWritePending);
      };
      function hasWritePending(object) {
        return object.hasWritePending();
      }
      Connection2.prototype.whenNothingPending = function(callback) {
        var doc2 = this._firstDoc(hasPending);
        if (doc2) {
          doc2.once("nothing pending", this._nothingPendingRetry(callback));
          return;
        }
        var query = this._firstQuery(hasPending);
        if (query) {
          query.once("ready", this._nothingPendingRetry(callback));
          return;
        }
        var snapshotRequest = this._firstSnapshotRequest();
        if (snapshotRequest) {
          snapshotRequest.once("ready", this._nothingPendingRetry(callback));
          return;
        }
        util.nextTick(callback);
      };
      Connection2.prototype._nothingPendingRetry = function(callback) {
        var connection2 = this;
        return function() {
          util.nextTick(function() {
            connection2.whenNothingPending(callback);
          });
        };
      };
      Connection2.prototype._firstDoc = function(fn) {
        for (var collection in this.collections) {
          var docs = this.collections[collection];
          for (var id in docs) {
            var doc2 = docs[id];
            if (fn(doc2)) {
              return doc2;
            }
          }
        }
      };
      Connection2.prototype._firstQuery = function(fn) {
        for (var id in this.queries) {
          var query = this.queries[id];
          if (fn(query)) {
            return query;
          }
        }
      };
      Connection2.prototype._firstSnapshotRequest = function() {
        for (var id in this._snapshotRequests) {
          return this._snapshotRequests[id];
        }
      };
      Connection2.prototype.fetchSnapshot = function(collection, id, version, callback) {
        if (typeof version === "function") {
          callback = version;
          version = null;
        }
        var requestId = this.nextSnapshotRequestId++;
        var snapshotRequest = new SnapshotVersionRequest(this, requestId, collection, id, version, callback);
        this._snapshotRequests[snapshotRequest.requestId] = snapshotRequest;
        snapshotRequest.send();
      };
      Connection2.prototype.fetchSnapshotByTimestamp = function(collection, id, timestamp, callback) {
        if (typeof timestamp === "function") {
          callback = timestamp;
          timestamp = null;
        }
        var requestId = this.nextSnapshotRequestId++;
        var snapshotRequest = new SnapshotTimestampRequest(this, requestId, collection, id, timestamp, callback);
        this._snapshotRequests[snapshotRequest.requestId] = snapshotRequest;
        snapshotRequest.send();
      };
      Connection2.prototype._handleSnapshotFetch = function(error, message) {
        var snapshotRequest = this._snapshotRequests[message.id];
        if (!snapshotRequest)
          return;
        delete this._snapshotRequests[message.id];
        snapshotRequest._handleResponse(error, message);
      };
      Connection2.prototype._handleLegacyInit = function(message) {
        if (message.protocolMinor)
          return this._initializeHandshake();
        this._initialize(message);
      };
      Connection2.prototype._initializeHandshake = function() {
        this.send({ a: ACTIONS.handshake, id: this.id });
      };
      Connection2.prototype._handleHandshake = function(error, message) {
        if (error)
          return this.emit("error", error);
        this._initialize(message);
      };
      Connection2.prototype._handlePingPong = function(error) {
        if (error)
          return this.emit("error", error);
        this.emit("pong");
      };
      Connection2.prototype._initialize = function(message) {
        if (this.state !== "connecting")
          return;
        if (message.protocol !== 1) {
          return this.emit("error", new ShareDBError(
            ERROR_CODE.ERR_PROTOCOL_VERSION_NOT_SUPPORTED,
            "Unsupported protocol version: " + message.protocol
          ));
        }
        if (types.map[message.type] !== types.defaultType) {
          return this.emit("error", new ShareDBError(
            ERROR_CODE.ERR_DEFAULT_TYPE_MISMATCH,
            message.type + " does not match the server default type"
          ));
        }
        if (typeof message.id !== "string") {
          return this.emit("error", new ShareDBError(
            ERROR_CODE.ERR_CLIENT_ID_BADLY_FORMED,
            "Client id must be a string"
          ));
        }
        this.id = message.id;
        this._setState("connected");
      };
      Connection2.prototype.getPresence = function(channel) {
        var connection2 = this;
        var presence = util.digOrCreate(this._presences, channel, function() {
          return new Presence(connection2, channel);
        });
        presence._wantsDestroy = false;
        return presence;
      };
      Connection2.prototype.getDocPresence = function(collection, id) {
        var channel = DocPresence.channel(collection, id);
        var connection2 = this;
        var presence = util.digOrCreate(this._presences, channel, function() {
          return new DocPresence(connection2, collection, id);
        });
        presence._wantsDestroy = false;
        return presence;
      };
      Connection2.prototype._sendPresenceAction = function(action, seq, presence) {
        this._addPresence(presence);
        var message = { a: action, ch: presence.channel, seq };
        this.send(message);
        return message.seq;
      };
      Connection2.prototype._addPresence = function(presence) {
        util.digOrCreate(this._presences, presence.channel, function() {
          return presence;
        });
      };
      Connection2.prototype._requestRemotePresence = function(channel) {
        this.send({ a: ACTIONS.presenceRequest, ch: channel });
      };
      Connection2.prototype._handlePresenceSubscribe = function(error, message) {
        var presence = util.dig(this._presences, message.ch);
        if (presence)
          presence._handleSubscribe(error, message.seq);
      };
      Connection2.prototype._handlePresenceUnsubscribe = function(error, message) {
        var presence = util.dig(this._presences, message.ch);
        if (presence)
          presence._handleUnsubscribe(error, message.seq);
      };
      Connection2.prototype._handlePresence = function(error, message) {
        var presence = util.dig(this._presences, message.ch);
        if (presence)
          presence._receiveUpdate(error, message);
      };
      Connection2.prototype._handlePresenceRequest = function(error, message) {
        var presence = util.dig(this._presences, message.ch);
        if (presence)
          presence._broadcastAllLocalPresence(error, message);
      };
    }
  });

  // node_modules/sharedb/lib/client/index.js
  var require_client = __commonJS({
    "node_modules/sharedb/lib/client/index.js"(exports) {
      init_mithril_shim();
      exports.Connection = require_connection();
      exports.Doc = require_doc();
      exports.Error = require_error();
      exports.Query = require_query();
      exports.types = require_types();
      exports.logger = require_logger2();
    }
  });

  // src/index.js
  init_mithril_shim();

  // src/discover.js
  init_mithril_shim();
  var import_mime_types = __toESM(require_mime_types());
  var import_mithril2 = __toESM(require_mithril());

  // src/filesystem.ts
  init_mithril_shim();
  var import_path = __toESM(require_path());
  var filesystem = {
    parent: null,
    version: 0,
    name: "",
    children: []
  };
  function createFile(filepath, content) {
    const node = resolveFile(filepath);
    if (node && "content" in node && node.content === content)
      return;
    const filename = import_path.default.basename(filepath);
    const dirname = import_path.default.dirname(filepath);
    const segments = dirname.split(import_path.default.sep).filter(Boolean);
    let parent = filesystem;
    filesystem.version++;
    for (let segment of segments) {
      parent = addDirectoryNode(parent, segment);
      parent.version = filesystem.version;
    }
    const k = addFileNode(parent, filename);
    let type = "text";
    if (typeof content !== "string") {
      type = content.type;
      content = content.value;
    }
    k.content = content;
    k.type = type;
    k.version = filesystem.version;
    notifyFSChange();
  }
  function resolveFile(filepath) {
    const filename = import_path.default.basename(filepath);
    const dirname = import_path.default.dirname(filepath);
    const segments = dirname.split(import_path.default.sep).filter(Boolean);
    let parent = filesystem;
    for (let segment in segments) {
      parent = parent.children.find(
        (e) => e.name === segment && "children" in e
      );
      if (!parent)
        return null;
    }
    if (filename)
      return parent.children.find((e) => e.name === filename);
    else
      return parent;
  }
  function deleteFile(filepath) {
    const x = resolveFile(filepath);
    if (x) {
      x.parent.children.splice(x.parent.children.indexOf(x), 1);
      filesystem.version++;
      let parent = x.parent;
      x.parent = null;
      while (parent) {
        parent.version = filesystem.version;
        parent = parent.parent;
      }
    }
    notifyFSChange();
  }
  function addDirectoryNode(parent, name) {
    let m3 = parent.children.find((e) => e.name === name);
    if (m3 && "children" in m3) {
      return m3;
    } else {
      if (m3)
        parent.children.splice(parent.children.indexOf(m3), 1);
      m3 = {
        children: [],
        name,
        parent,
        version: 0
      };
      parent.children.push(m3);
      return m3;
    }
  }
  function addFileNode(parent, name) {
    let m3 = parent.children.find((e) => e.name === name);
    if (m3 && "content" in m3) {
      return m3;
    } else {
      if (m3)
        parent.children.splice(parent.children.indexOf(m3), 1);
      m3 = {
        content: "",
        name,
        parent,
        type: "text",
        version: 0
      };
      parent.children.push(m3);
      return m3;
    }
  }
  var cbs = [];
  function notifyFSChange() {
    cbs.forEach((e) => e(filesystem));
  }

  // src/discover.js
  var import_path2 = __toESM(require_path());
  var read = [];
  async function readFile(file, type, basePath = window.location.href) {
    if (!file)
      return;
    const url = new URL(file, basePath);
    if (url.origin !== window.location.origin)
      return;
    if (read.includes(url.toString()))
      return;
    read.push(url.toString());
    await import_mithril2.default.request({
      method: "GET",
      url: url.toString(),
      responseType: isBinaryType(type) ? "blob" : "text"
    }).then(
      async (content) => {
        if (content && typeof content !== "string") {
          content = { type: "binary", value: await blobToBase64(content) };
        }
        if (type === "text/html" && import_path2.default.extname(url.pathname) !== ".html")
          createFile(url.pathname + "/index.html", content);
        else
          createFile(url.pathname, content);
        switch (type) {
          case "text/html":
            return await discoverFromHTML(content, url.href);
          case "text/css":
            return await discoverFromCSS(content, url.href);
        }
      },
      (e) => {
        console.warn("Failed to read: " + url.pathname + " " + basePath);
        deleteFile(url.pathname);
      }
    );
  }
  var parser = new DOMParser();
  async function discoverFromHTML(html, href) {
    const dom = parser.parseFromString(html, "text/html");
    const scripts = dom.getElementsByTagName("script");
    for (let script of scripts) {
      await readFile(script.getAttribute("src"), "application/javascript", href);
    }
    const styles = dom.getElementsByTagName("link");
    for (let style of styles) {
      await readFile(
        style.getAttribute("href"),
        style.rel === "stylesheet" ? "text/css" : (0, import_mime_types.lookup)(styles.href) || "",
        href
      );
    }
    const links = dom.getElementsByTagName("a");
    for (let link of links) {
      await readFile(link.getAttribute("href"), "text/html", href);
    }
    const imgs = document.getElementsByTagName("img");
    for (let img of imgs) {
      await readFile(img.getAttribute("src"), (0, import_mime_types.lookup)(styles.href), href);
    }
  }
  async function discoverFromCSS(cssText, href) {
    const dom = document;
    const style = dom.createElement("style");
    style.setAttribute("media", "(max-width: -1)");
    style.innerHTML = cssText;
    dom.head.append(style);
    const styleSheet = Array.from(dom.styleSheets).find(
      (ss) => ss.ownerNode == style
    );
    style.remove();
    async function readProperty(key, value) {
      const m3 = [];
      value.replace(
        /url\((['"]?)((?:[^\1\)\\]|\\.)+)\1\)/g,
        function(_, __, match) {
          if (!(match.startsWith("#") || match.startsWith("data:")))
            m3.push(match);
        }
      );
      if (!m3.length)
        return;
      await Promise.all(m3.map((url) => readFile(url, (0, import_mime_types.lookup)(url), href)));
    }
    await Promise.all(
      Array.from(styleSheet.cssRules).map(async function readCSSRule(rule) {
        if (rule instanceof CSSStyleRule || rule instanceof CSSFontFaceRule) {
          await Promise.all(
            [...rule.style].map((e) => readProperty(e, rule.style[e]))
          );
        } else if (rule instanceof CSSImportRule) {
          await readFile(rule.href, "text/css", href);
        } else if (rule instanceof CSSGroupingRule || rule instanceof CSSKeyframesRule) {
          await Promise.all(Array.from(styleSheet.cssRules).map(readCSSRule));
        }
      })
    );
  }
  function blobToBase64(blob) {
    return new Promise((resolve, _) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.readAsDataURL(blob);
    });
  }
  var isBinaryType = (type) => ![
    "text/html",
    "application/javascript",
    "text/css",
    "application/json"
  ].includes(type);

  // src/sync.js
  init_mithril_shim();

  // node_modules/reconnecting-websocket/dist/reconnecting-websocket-mjs.js
  init_mithril_shim();
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  function __extends(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __values(o) {
    var m3 = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m3)
      return m3.call(o);
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  }
  function __read(o, n) {
    var m3 = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m3)
      return o;
    var i = m3.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m3 = i["return"]))
          m3.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  }
  function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
    return ar;
  }
  var Event = function() {
    function Event2(type, target) {
      this.target = target;
      this.type = type;
    }
    return Event2;
  }();
  var ErrorEvent = function(_super) {
    __extends(ErrorEvent2, _super);
    function ErrorEvent2(error, target) {
      var _this = _super.call(this, "error", target) || this;
      _this.message = error.message;
      _this.error = error;
      return _this;
    }
    return ErrorEvent2;
  }(Event);
  var CloseEvent = function(_super) {
    __extends(CloseEvent2, _super);
    function CloseEvent2(code, reason, target) {
      if (code === void 0) {
        code = 1e3;
      }
      if (reason === void 0) {
        reason = "";
      }
      var _this = _super.call(this, "close", target) || this;
      _this.wasClean = true;
      _this.code = code;
      _this.reason = reason;
      return _this;
    }
    return CloseEvent2;
  }(Event);
  var getGlobalWebSocket = function() {
    if (typeof WebSocket !== "undefined") {
      return WebSocket;
    }
  };
  var isWebSocket = function(w) {
    return typeof w !== "undefined" && !!w && w.CLOSING === 2;
  };
  var DEFAULT = {
    maxReconnectionDelay: 1e4,
    minReconnectionDelay: 1e3 + Math.random() * 4e3,
    minUptime: 5e3,
    reconnectionDelayGrowFactor: 1.3,
    connectionTimeout: 4e3,
    maxRetries: Infinity,
    maxEnqueuedMessages: Infinity,
    startClosed: false,
    debug: false
  };
  var ReconnectingWebSocket = function() {
    function ReconnectingWebSocket2(url, protocols, options) {
      var _this = this;
      if (options === void 0) {
        options = {};
      }
      this._listeners = {
        error: [],
        message: [],
        open: [],
        close: []
      };
      this._retryCount = -1;
      this._shouldReconnect = true;
      this._connectLock = false;
      this._binaryType = "blob";
      this._closeCalled = false;
      this._messageQueue = [];
      this.onclose = null;
      this.onerror = null;
      this.onmessage = null;
      this.onopen = null;
      this._handleOpen = function(event) {
        _this._debug("open event");
        var _a = _this._options.minUptime, minUptime = _a === void 0 ? DEFAULT.minUptime : _a;
        clearTimeout(_this._connectTimeout);
        _this._uptimeTimeout = setTimeout(function() {
          return _this._acceptOpen();
        }, minUptime);
        _this._ws.binaryType = _this._binaryType;
        _this._messageQueue.forEach(function(message) {
          return _this._ws.send(message);
        });
        _this._messageQueue = [];
        if (_this.onopen) {
          _this.onopen(event);
        }
        _this._listeners.open.forEach(function(listener) {
          return _this._callEventListener(event, listener);
        });
      };
      this._handleMessage = function(event) {
        _this._debug("message event");
        if (_this.onmessage) {
          _this.onmessage(event);
        }
        _this._listeners.message.forEach(function(listener) {
          return _this._callEventListener(event, listener);
        });
      };
      this._handleError = function(event) {
        _this._debug("error event", event.message);
        _this._disconnect(void 0, event.message === "TIMEOUT" ? "timeout" : void 0);
        if (_this.onerror) {
          _this.onerror(event);
        }
        _this._debug("exec error listeners");
        _this._listeners.error.forEach(function(listener) {
          return _this._callEventListener(event, listener);
        });
        _this._connect();
      };
      this._handleClose = function(event) {
        _this._debug("close event");
        _this._clearTimeouts();
        if (_this._shouldReconnect) {
          _this._connect();
        }
        if (_this.onclose) {
          _this.onclose(event);
        }
        _this._listeners.close.forEach(function(listener) {
          return _this._callEventListener(event, listener);
        });
      };
      this._url = url;
      this._protocols = protocols;
      this._options = options;
      if (this._options.startClosed) {
        this._shouldReconnect = false;
      }
      this._connect();
    }
    Object.defineProperty(ReconnectingWebSocket2, "CONNECTING", {
      get: function() {
        return 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ReconnectingWebSocket2, "OPEN", {
      get: function() {
        return 1;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ReconnectingWebSocket2, "CLOSING", {
      get: function() {
        return 2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ReconnectingWebSocket2, "CLOSED", {
      get: function() {
        return 3;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ReconnectingWebSocket2.prototype, "CONNECTING", {
      get: function() {
        return ReconnectingWebSocket2.CONNECTING;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ReconnectingWebSocket2.prototype, "OPEN", {
      get: function() {
        return ReconnectingWebSocket2.OPEN;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ReconnectingWebSocket2.prototype, "CLOSING", {
      get: function() {
        return ReconnectingWebSocket2.CLOSING;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ReconnectingWebSocket2.prototype, "CLOSED", {
      get: function() {
        return ReconnectingWebSocket2.CLOSED;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ReconnectingWebSocket2.prototype, "binaryType", {
      get: function() {
        return this._ws ? this._ws.binaryType : this._binaryType;
      },
      set: function(value) {
        this._binaryType = value;
        if (this._ws) {
          this._ws.binaryType = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ReconnectingWebSocket2.prototype, "retryCount", {
      get: function() {
        return Math.max(this._retryCount, 0);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ReconnectingWebSocket2.prototype, "bufferedAmount", {
      get: function() {
        var bytes = this._messageQueue.reduce(function(acc, message) {
          if (typeof message === "string") {
            acc += message.length;
          } else if (message instanceof Blob) {
            acc += message.size;
          } else {
            acc += message.byteLength;
          }
          return acc;
        }, 0);
        return bytes + (this._ws ? this._ws.bufferedAmount : 0);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ReconnectingWebSocket2.prototype, "extensions", {
      get: function() {
        return this._ws ? this._ws.extensions : "";
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ReconnectingWebSocket2.prototype, "protocol", {
      get: function() {
        return this._ws ? this._ws.protocol : "";
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ReconnectingWebSocket2.prototype, "readyState", {
      get: function() {
        if (this._ws) {
          return this._ws.readyState;
        }
        return this._options.startClosed ? ReconnectingWebSocket2.CLOSED : ReconnectingWebSocket2.CONNECTING;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ReconnectingWebSocket2.prototype, "url", {
      get: function() {
        return this._ws ? this._ws.url : "";
      },
      enumerable: true,
      configurable: true
    });
    ReconnectingWebSocket2.prototype.close = function(code, reason) {
      if (code === void 0) {
        code = 1e3;
      }
      this._closeCalled = true;
      this._shouldReconnect = false;
      this._clearTimeouts();
      if (!this._ws) {
        this._debug("close enqueued: no ws instance");
        return;
      }
      if (this._ws.readyState === this.CLOSED) {
        this._debug("close: already closed");
        return;
      }
      this._ws.close(code, reason);
    };
    ReconnectingWebSocket2.prototype.reconnect = function(code, reason) {
      this._shouldReconnect = true;
      this._closeCalled = false;
      this._retryCount = -1;
      if (!this._ws || this._ws.readyState === this.CLOSED) {
        this._connect();
      } else {
        this._disconnect(code, reason);
        this._connect();
      }
    };
    ReconnectingWebSocket2.prototype.send = function(data) {
      if (this._ws && this._ws.readyState === this.OPEN) {
        this._debug("send", data);
        this._ws.send(data);
      } else {
        var _a = this._options.maxEnqueuedMessages, maxEnqueuedMessages = _a === void 0 ? DEFAULT.maxEnqueuedMessages : _a;
        if (this._messageQueue.length < maxEnqueuedMessages) {
          this._debug("enqueue", data);
          this._messageQueue.push(data);
        }
      }
    };
    ReconnectingWebSocket2.prototype.addEventListener = function(type, listener) {
      if (this._listeners[type]) {
        this._listeners[type].push(listener);
      }
    };
    ReconnectingWebSocket2.prototype.dispatchEvent = function(event) {
      var e_1, _a;
      var listeners = this._listeners[event.type];
      if (listeners) {
        try {
          for (var listeners_1 = __values(listeners), listeners_1_1 = listeners_1.next(); !listeners_1_1.done; listeners_1_1 = listeners_1.next()) {
            var listener = listeners_1_1.value;
            this._callEventListener(event, listener);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (listeners_1_1 && !listeners_1_1.done && (_a = listeners_1.return))
              _a.call(listeners_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
      return true;
    };
    ReconnectingWebSocket2.prototype.removeEventListener = function(type, listener) {
      if (this._listeners[type]) {
        this._listeners[type] = this._listeners[type].filter(function(l) {
          return l !== listener;
        });
      }
    };
    ReconnectingWebSocket2.prototype._debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this._options.debug) {
        console.log.apply(console, __spread(["RWS>"], args));
      }
    };
    ReconnectingWebSocket2.prototype._getNextDelay = function() {
      var _a = this._options, _b = _a.reconnectionDelayGrowFactor, reconnectionDelayGrowFactor = _b === void 0 ? DEFAULT.reconnectionDelayGrowFactor : _b, _c = _a.minReconnectionDelay, minReconnectionDelay = _c === void 0 ? DEFAULT.minReconnectionDelay : _c, _d = _a.maxReconnectionDelay, maxReconnectionDelay = _d === void 0 ? DEFAULT.maxReconnectionDelay : _d;
      var delay = 0;
      if (this._retryCount > 0) {
        delay = minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);
        if (delay > maxReconnectionDelay) {
          delay = maxReconnectionDelay;
        }
      }
      this._debug("next delay", delay);
      return delay;
    };
    ReconnectingWebSocket2.prototype._wait = function() {
      var _this = this;
      return new Promise(function(resolve) {
        setTimeout(resolve, _this._getNextDelay());
      });
    };
    ReconnectingWebSocket2.prototype._getNextUrl = function(urlProvider) {
      if (typeof urlProvider === "string") {
        return Promise.resolve(urlProvider);
      }
      if (typeof urlProvider === "function") {
        var url = urlProvider();
        if (typeof url === "string") {
          return Promise.resolve(url);
        }
        if (!!url.then) {
          return url;
        }
      }
      throw Error("Invalid URL");
    };
    ReconnectingWebSocket2.prototype._connect = function() {
      var _this = this;
      if (this._connectLock || !this._shouldReconnect) {
        return;
      }
      this._connectLock = true;
      var _a = this._options, _b = _a.maxRetries, maxRetries = _b === void 0 ? DEFAULT.maxRetries : _b, _c = _a.connectionTimeout, connectionTimeout = _c === void 0 ? DEFAULT.connectionTimeout : _c, _d = _a.WebSocket, WebSocket2 = _d === void 0 ? getGlobalWebSocket() : _d;
      if (this._retryCount >= maxRetries) {
        this._debug("max retries reached", this._retryCount, ">=", maxRetries);
        return;
      }
      this._retryCount++;
      this._debug("connect", this._retryCount);
      this._removeListeners();
      if (!isWebSocket(WebSocket2)) {
        throw Error("No valid WebSocket class provided");
      }
      this._wait().then(function() {
        return _this._getNextUrl(_this._url);
      }).then(function(url) {
        if (_this._closeCalled) {
          return;
        }
        _this._debug("connect", { url, protocols: _this._protocols });
        _this._ws = _this._protocols ? new WebSocket2(url, _this._protocols) : new WebSocket2(url);
        _this._ws.binaryType = _this._binaryType;
        _this._connectLock = false;
        _this._addListeners();
        _this._connectTimeout = setTimeout(function() {
          return _this._handleTimeout();
        }, connectionTimeout);
      });
    };
    ReconnectingWebSocket2.prototype._handleTimeout = function() {
      this._debug("timeout event");
      this._handleError(new ErrorEvent(Error("TIMEOUT"), this));
    };
    ReconnectingWebSocket2.prototype._disconnect = function(code, reason) {
      if (code === void 0) {
        code = 1e3;
      }
      this._clearTimeouts();
      if (!this._ws) {
        return;
      }
      this._removeListeners();
      try {
        this._ws.close(code, reason);
        this._handleClose(new CloseEvent(code, reason, this));
      } catch (error) {
      }
    };
    ReconnectingWebSocket2.prototype._acceptOpen = function() {
      this._debug("accept open");
      this._retryCount = 0;
    };
    ReconnectingWebSocket2.prototype._callEventListener = function(event, listener) {
      if ("handleEvent" in listener) {
        listener.handleEvent(event);
      } else {
        listener(event);
      }
    };
    ReconnectingWebSocket2.prototype._removeListeners = function() {
      if (!this._ws) {
        return;
      }
      this._debug("removeListeners");
      this._ws.removeEventListener("open", this._handleOpen);
      this._ws.removeEventListener("close", this._handleClose);
      this._ws.removeEventListener("message", this._handleMessage);
      this._ws.removeEventListener("error", this._handleError);
    };
    ReconnectingWebSocket2.prototype._addListeners = function() {
      if (!this._ws) {
        return;
      }
      this._debug("addListeners");
      this._ws.addEventListener("open", this._handleOpen);
      this._ws.addEventListener("close", this._handleClose);
      this._ws.addEventListener("message", this._handleMessage);
      this._ws.addEventListener("error", this._handleError);
    };
    ReconnectingWebSocket2.prototype._clearTimeouts = function() {
      clearTimeout(this._connectTimeout);
      clearTimeout(this._uptimeTimeout);
    };
    return ReconnectingWebSocket2;
  }();
  var reconnecting_websocket_mjs_default = ReconnectingWebSocket;

  // src/sync.js
  var import_client = __toESM(require_client());
  var socket = new reconnecting_websocket_mjs_default("ws://localhost:44761", [], {
    maxEnqueuedMessages: 0
  });
  var connection = new import_client.Connection(socket);
  var doc = connection.get("doc-collection", "doc-id");
  doc.subscribe((error) => {
    if (error)
      return console.error(error);
    if (!doc.type) {
      doc.create({ counter: 0 }, (error2) => {
        if (error2)
          console.error(error2);
      });
    }
    alert(doc);
  });
  doc.on("op", (op) => {
    console.log("count", doc.data.counter);
  });
  window.increment = () => {
    doc.submitOp([{ p: ["counter"], na: 1 }]);
  };

  // src/index.js
  readFile(".", "text/html").then((e) => console.log(resolveFile("/")));
})();
